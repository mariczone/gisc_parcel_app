"use strict";(self.webpackChunkparcel_app=self.webpackChunkparcel_app||[]).push([[3871],{986:(ue,Yt,W)=>{W.d(Yt,{E:()=>_t});const it=new(W(6879).Z);function _t(ft){if(null==ft)return["",!1];if(!it.hasBidiChar(ft))return[ft,!1];let Ft;return Ft="rtl"===it.checkContextual(ft)?"IDNNN":"ICNNN",[it.bidiTransform(ft,Ft,"VLYSN"),!0]}},17002:(ue,Yt,W)=>{W.d(Yt,{BN:()=>ut,Yc:()=>$,mx:()=>Ft});var Ot=W(15861),it=W(59318);const _t="woff2",ft=new Map;function Ft(Z){return L.apply(this,arguments)}function L(){return(L=(0,Ot.Z)(function*(Z){const Pt=$(Z);let wt=ft.get(Pt);if(wt)return wt;const N=new FontFace(Z.family,`url('${it.Z.fontsUrl}/woff2/${Pt}.${_t}') format('${_t}')`),D=document.fonts;return D.has(N)&&"loading"===N.status?N.loaded:(wt=N.load(),ft.set(Pt,wt),D.add(N),wt)})).apply(this,arguments)}function ut(Z){if(!Z)return"arial-unicode-ms";const Pt=Z.toLowerCase().split(" ").join("-");switch(Pt){case"serif":return"noto-serif";case"sans-serif":return"arial-unicode-ms";case"monospace":return"ubuntu-mono";case"fantasy":return"cabin-sketch";case"cursive":return"redressed";default:return Pt}}function $(Z){const Pt=function st(Z){if(!Z.weight)return"";switch(Z.weight.toLowerCase()){case"bold":case"bolder":return"-bold"}return""}(Z)+function ht(Z){if(!Z.style)return"";switch(Z.style.toLowerCase()){case"italic":case"oblique":return"-italic"}return""}(Z);return ut(Z.family)+(Pt.length>0?Pt:"-regular")}},72283:(ue,Yt,W)=>{W.d(Yt,{GP:()=>ft,QK:()=>E,XV:()=>ct,hh:()=>D,ov:()=>N,qh:()=>Ct,v1:()=>xt,wp:()=>wt,zY:()=>kt,zv:()=>St});var Ot=W(58817),it=W(91179),_t=W(97373);function ft(R){const et=(0,Ot.d9)(R);return function Pt(R){R&&((0,it.oU)(R)?Z(R.rings):(0,it.l9)(R)?Z(R.paths):(0,it.aW)(R)&&ht(R.points),Ft(R))}(et),et}function Ft(R){R&&((0,it.wp)(R)?R.y=-R.y:(0,it.oU)(R)?ut(R.rings):(0,it.l9)(R)?ut(R.paths):(0,it.aW)(R)&&L(R.points))}function L(R){if(R){const et=R.length;for(let yt=0;yt<et;yt++)R[yt][1]=-R[yt][1]}}function ut(R){if(R)for(const et of R)L(et)}function $(R){if(R)for(let et=R.length-1;et>0;--et)R[et][0]-=R[et-1][0],R[et][1]-=R[et-1][1]}function st(R){if(R)for(const et of R)$(et)}function ht(R){if(R){const et=R.length;for(let yt=1;yt<et;++yt)R[yt][0]+=R[yt-1][0],R[yt][1]+=R[yt-1][1]}}function Z(R){if(R)for(const et of R)ht(et)}function wt(R){R&&(Ft(R),(0,it.oU)(R)?st(R.rings):(0,it.l9)(R)?st(R.paths):(0,it.aW)(R)&&$(R.points))}function N(R){if(R)for(const et of R)D(et)}function D(R){R&&R.reverse()}function ct(R,et,yt){return[R[0]+(et[0]-R[0])*yt,R[1]+(et[1]-R[1])*yt]}function E(R){return!(!R||0===R.length)&&R[0][0]===R[R.length-1][0]&&R[0][1]===R[R.length-1][1]}function St(R){return R[4]}function Ct(R,et){R[4]=et}class xt{constructor(et,yt,Nt,dt=0){this.isClosed=!1,this.multiPath=null,this.acceptPolygon=yt,this.acceptPolyline=Nt,this.geomUnitsPerPoint=dt,this.pathCount=-1,this.pathIndex=-1,this.iteratePath=!1,et&&((0,it.oU)(et)?yt&&(this.multiPath=et.rings,this.isClosed=!0):(0,it.l9)(et)?Nt&&(this.multiPath=et.paths,this.isClosed=!1):(0,it.YX)(et)&&yt&&(this.multiPath=zt(et).rings,this.isClosed=!0),this.multiPath&&(this.pathCount=this.multiPath.length)),this.internalPlacement=new _t.u}next(){if(!this.multiPath)return null;for(;this.iteratePath||this.pathIndex<this.pathCount-1;){this.iteratePath||this.pathIndex++;const et=this.processPath(this.multiPath[this.pathIndex]);if(et)return et}return this.pathCount=-1,this.pathIndex=-1,this.multiPath=null,null}}class kt{constructor(et,yt,Nt,dt=0){this.isClosed=!1,this.multiPath=null,this.inputGeometries=et,this.acceptPolygon=yt,this.acceptPolyline=Nt,this.geomUnitsPerPoint=dt,this.pathCount=-1,this.pathIndex=-1,this.iteratePath=!1}next(){for(;;){if(!this.multiPath){let et=this.inputGeometries.next();for(;et;){if((0,it.oU)(et)?this.acceptPolygon&&(this.multiPath=et.rings,this.isClosed=!0):(0,it.l9)(et)?this.acceptPolyline&&(this.multiPath=et.paths,this.isClosed=!1):(0,it.YX)(et)&&this.acceptPolygon&&(this.multiPath=zt(et).rings,this.isClosed=!0),this.multiPath){this.pathCount=this.multiPath.length,this.pathIndex=-1;break}et=this.inputGeometries.next()}if(!this.multiPath)return null}for(;this.iteratePath||this.pathIndex<this.pathCount-1;){this.iteratePath||this.pathIndex++;const et=this.processPath(this.multiPath[this.pathIndex]);if(et)return et}this.pathCount=-1,this.pathIndex=-1,this.multiPath=null}}}function zt(R){return{rings:[[[R.xmin,R.ymin],[R.xmin,R.ymax],[R.xmax,R.ymax],[R.xmax,R.ymin],[R.xmin,R.ymin]]]}}},29214:(ue,Yt,W)=>{W.d(Yt,{MU:()=>Ft,ib:()=>ut,yn:()=>$}),W(58817);var it=W(13160);let ft;class Ft{constructor(ht){this._geometry=ht}next(){const ht=this._geometry;return this._geometry=null,ht}}function ut(st,ht){let Z,Pt;ft||(ft=new it.bN(0,0,0,1)),ft.reset(it.Vl.Polygon),ft.setPixelMargin(ht+1),ft.setExtent(512);for(const N of st.rings)if(N&&!(N.length<3)){Z=N[0][0],Pt=-N[0][1],ft.moveTo(Z,Pt);for(let D=1;D<N.length;D++)Z=N[D][0],Pt=-N[D][1],ft.lineTo(Z,Pt);ft.close()}const wt=ft.result(!1);if(wt){const N=[];for(const D of wt){const ct=[];N.push(ct);for(const E of D)ct.push([E.x,-E.y])}return{rings:N}}return{rings:[]}}function $(st,ht){let Z,Pt;ft||(ft=new it.bN(0,0,0,1)),ft.reset(it.Vl.LineString),ft.setPixelMargin(ht+1),ft.setExtent(512);for(const N of st.paths)if(N&&!(N.length<2)){Z=N[0][0],Pt=-N[0][1],ft.moveTo(Z,Pt);for(let D=1;D<N.length;D++)Z=N[D][0],Pt=-N[D][1],ft.lineTo(Z,Pt)}const wt=ft.result(!1);if(wt){const N=[];for(const D of wt){const ct=[];N.push(ct);for(const E of D)ct.push([E.x,-E.y])}return{paths:N}}return{paths:[]}}},95727:(ue,Yt,W)=>{W.d(Yt,{h:()=>Ee,W:()=>Le});var Ot=W(58817),it=W(91179),_t=W(72283);let ft=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(s,i,h,o,r){return new Ft(s,i,h)}}return f.instance=null,f})();class Ft{constructor(e,s,i){this._inputGeometries=e,this._angleTolerance=void 0!==s.angleTolerance?s.angleTolerance:120,this._maxCosAngle=Math.cos((1-Math.abs(this._angleTolerance)/180)*Math.PI)}next(){let e=this._inputGeometries.next();for(;e;){if((0,it.oU)(e)){this._isClosed=!0;const s=(0,Ot.d9)(e);return this._processMultipath(s.rings),s}if((0,it.l9)(e)){this._isClosed=!1;const s=(0,Ot.d9)(e);return this._processMultipath(s.paths),s}if((0,it.YX)(e)){if(this._maxCosAngle)return e;this._isClosed=!0;const s=[[e.xmin,e.ymin],[e.xmin,e.ymax],[e.xmax,e.ymax],[e.xmax,e.ymin],[e.xmin,e.ymin]];return this._processPath(s),{rings:[s]}}e=this._inputGeometries.next()}return null}_processMultipath(e){if(e)for(const s of e)this._processPath(s)}_processPath(e){if(e){let s,i,h,o,r,l,c=e.length,p=e[0];this._isClosed&&++c;for(let d=1;d<c;++d){let y;y=this._isClosed&&d===c-1?e[0]:e[d];const z=y[0]-p[0],T=y[1]-p[1],X=Math.sqrt(z*z+T*T);d>1&&X>0&&h>0&&(s*z+i*T)/X/h<=this._maxCosAngle&&(0,_t.qh)(p,1),1===d&&(o=z,r=T,l=X),X>0&&(p=y,s=z,i=T,h=X)}this._isClosed&&h>0&&l>0&&(s*o+i*r)/l/h<=this._maxCosAngle&&(0,_t.qh)(e[0],1)}}}var L=W(7547);const ut=.03;class ${constructor(){this._path=[]}path(){return this._path}addPath(e,s){s||e.reverse(),Array.prototype.push.apply(this._path,e),s||e.reverse()}static mergePath(e,s){s&&Array.prototype.push.apply(e,s)}startPath(e){this._path.push(e)}lineTo(e){this._path.push(e)}close(){const e=this._path;e.length>1&&(e[0][0]===e[e.length-1][0]&&e[0][1]===e[e.length-1][1]||e.push([e[0][0],e[0][1]]))}}class st{constructor(e=0,s=!1){}normalize(e){const s=Math.sqrt(e[0]*e[0]+e[1]*e[1]);0!==s&&(e[0]/=s,e[1]/=s)}calculateLength(e,s){const i=s[0]-e[0],h=s[1]-e[1];return Math.sqrt(i*i+h*h)}calculateSegLength(e,s){return this.calculateLength(e[s],e[s+1])}calculatePathLength(e){let s=0;const i=e?e.length:0;for(let h=0;h<i-1;++h)s+=this.calculateSegLength(e,h);return s}calculatePathArea(e){let s=0;const i=e?e.length:0;for(let h=0;h<i-1;++h)s+=(e[h+1][0]-e[h][0])*(e[h+1][1]+e[h][1]);return s/2}getCoord2D(e,s,i){return[e[0]+(s[0]-e[0])*i,e[1]+(s[1]-e[1])*i]}getSegCoord2D(e,s,i){return this.getCoord2D(e[s],e[s+1],i)}getAngle(e,s,i){return Math.atan2(s[1]-e[1],s[0]-e[0])}getSegAngle(e,s,i){return this.getAngle(e[s],e[s+1],i)}getAngleCS(e,s,i){const h=s[0]-e[0],o=s[1]-e[1],r=Math.sqrt(h*h+o*o);return r>0?[h/r,o/r]:[1,0]}getSegAngleCS(e,s,i){return this.getAngleCS(e[s],e[s+1],i)}cut(e,s,i,h){return[i<=0?e[s]:this.getSegCoord2D(e,s,i),h>=1?e[s+1]:this.getSegCoord2D(e,s,h)]}addSegment(e,s,i){i&&e.push(s[0]),e.push(s[1])}getSubCurve(e,s,i){const h=[];return this.appendSubCurve(h,e,s,i)?h:null}appendSubCurve(e,s,i,h){const o=s?s.length-1:0;let r=0,l=!0,c=0;for(;c<o;){const p=this.calculateSegLength(s,c);if(0!==p){if(l){if(r+p>i){let y=1,z=!1;r+p>=h&&(y=(h-r)/p,z=!0);const T=this.cut(s,c,(i-r)/p,y);if(T&&this.addSegment(e,T,l),z)break;l=!1}}else{if(r+p>h){const d=this.cut(s,c,0,(h-r)/p);d&&this.addSegment(e,d,l);break}this.addSegment(e,[s[c],s[c+1]],l)}r+=p,++c}else++c}return!0}getCIMPointAlong(e,s){const i=e?e.length-1:0;let h=0,o=-1;for(;o<i;){++o;const r=this.calculateSegLength(e,o);if(0!==r){if(h+r>s)return this.getCoord2D(e[o],e[o+1],(s-h)/r);h+=r}}return null}isEmpty(e,s){if(!e||e.length<=1)return!0;const i=e?e.length-1:0;let h=-1;for(;h<i;)if(++h,e[h+1][0]!==e[h][0]||e[h+1][1]!==e[h][1]||s&&e[h+1][2]!==e[h][2])return!1;return!0}offset(e,s,i,h,o){if(!e||e.length<2)return null;let r=0,l=e[r++],c=r;for(;r<e.length;){const z=e[r];z[0]===l[0]&&z[1]===l[1]||(r!==c&&(e[c]=e[r]),l=e[c++]),r++}const p=e[0][0]===e[c-1][0]&&e[0][1]===e[c-1][1];if(p&&--c,c<(p?3:2))return null;const d=[];l=p?e[c-1]:null;let y=e[0];for(let z=0;z<c;z++){const T=z===c-1?p?e[0]:null:e[z+1];if(l)if(T){const X=[T[0]-y[0],T[1]-y[1]];this.normalize(X);const J=[y[0]-l[0],y[1]-l[1]];this.normalize(J);const lt=J[0]*X[1]-J[1]*X[0],bt=J[0]*X[0]+J[1]*X[1];if(0===lt&&1===bt){y=T;continue}if(lt>=0==s<=0){if(bt<1){const Ut=[X[0]-J[0],X[1]-J[1]];this.normalize(Ut);const Dt=Math.sqrt((1+bt)/2);if(Dt>1/h){const Mt=-Math.abs(s)/Dt;d.push([y[0]-Ut[0]*Mt,y[1]-Ut[1]*Mt])}}}else switch(i){case L.id.Mitered:{const Ut=Math.sqrt((1+bt)/2);if(Ut>0&&1/Ut<h){const Dt=[X[0]-J[0],X[1]-J[1]];this.normalize(Dt);const Mt=Math.abs(s)/Ut;d.push([y[0]-Dt[0]*Mt,y[1]-Dt[1]*Mt]);break}}case L.id.Bevelled:d.push([y[0]+J[1]*s,y[1]-J[0]*s]),d.push([y[0]+X[1]*s,y[1]-X[0]*s]);break;case L.id.Rounded:if(bt<1){d.push([y[0]+J[1]*s,y[1]-J[0]*s]);const Ut=Math.floor(2.5*(1-bt));if(Ut>0){const Dt=1/Ut;let Mt=Dt;for(let qt=1;qt<Ut;qt++,Mt+=Dt){const Vt=[J[1]*(1-Mt)+X[1]*Mt,-J[0]*(1-Mt)-X[0]*Mt];this.normalize(Vt),d.push([y[0]+Vt[0]*s,y[1]+Vt[1]*s])}}d.push([y[0]+X[1]*s,y[1]-X[0]*s])}break;default:if(lt<0)d.push([y[0]+(J[1]+J[0])*s,y[1]+(J[1]-J[0])*s]),d.push([y[0]+(X[1]-X[0])*s,y[1]-(X[0]+X[1])*s]);else{const Ut=Math.sqrt((1+Math.abs(bt))/2),Dt=[X[0]-J[0],X[1]-J[1]];this.normalize(Dt);const Mt=s/Ut;d.push([y[0]-Dt[0]*Mt,y[1]-Dt[1]*Mt])}}}else{const X=[y[0]-l[0],y[1]-l[1]];this.normalize(X),d.push([y[0]+X[1]*s,y[1]-X[0]*s])}else{const X=[T[0]-y[0],T[1]-y[1]];this.normalize(X),d.push([y[0]+X[1]*s,y[1]-X[0]*s])}l=y,y=T}return d.length<(p?3:2)?null:(p&&d.push([d[0][0],d[0][1]]),d)}}const ht=1.7320508075688772,Pt=L.TF.OpenEnded;let wt=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(s,i,h,o,r){return new N(s,i,h)}}return f.instance=null,f})();class N extends _t.zY{constructor(e,s,i){super(e,!1,!0),this._curveHelper=new st,this._width=(void 0!==s.width?s.width:5)*i,this._arrowType=void 0!==s.geometricEffectArrowType?s.geometricEffectArrowType:void 0!==s.arrowType?s.arrowType:Pt,this._offsetFlattenError=ut*i}processPath(e){switch(this._arrowType){case L.TF.OpenEnded:default:return this._constructSimpleArrow(e,!0);case L.TF.Block:return this._constructSimpleArrow(e,!1);case L.TF.Crossed:return this._constructCrossedArrow(e)}}_constructSimpleArrow(e,s){const i=this._curveHelper.calculatePathLength(e);let h=this._width;i<2*h&&(h=i/2);const o=this._curveHelper.getSubCurve(e,0,i-h);if(!o)return null;const r=h/2;if(this._curveHelper.isEmpty(o,!1))return null;const l=this._constructOffset(o,-r);if(!l)return null;const c=this._constructOffset(o,r);if(!c)return null;const p=this._constructArrowBasePoint(l,-r/2);if(!p)return null;const d=this._constructArrowBasePoint(c,r/2);if(!d)return null;const y=e[e.length-1];s||(this._makeControlPoint(c,!0),this._makeControlPoint(l,!0));const z=new $;return z.addPath(c,!0),z.lineTo(d),this._makeControlPoint(z.path()),z.lineTo(y),this._makeControlPoint(z.path()),z.lineTo(p),this._makeControlPoint(z.path()),z.addPath(l,!1),s?{paths:[z.path()]}:(z.close(),{rings:[z.path()]})}_constructCrossedArrow(e){const s=this._curveHelper.calculatePathLength(e);let i=this._width;s<i*(1+ht+1)&&(i=s/(1+ht+1));const h=this._curveHelper.getSubCurve(e,0,s-i*(1+ht));if(!h)return null;const o=i/2;if(this._curveHelper.isEmpty(h,!1))return null;const r=this._constructOffset(h,o);if(!r)return null;const l=this._constructOffset(h,-o);if(!l)return null;const c=this._curveHelper.getSubCurve(e,0,s-i);if(!c||this._curveHelper.isEmpty(c,!1))return null;const p=this._constructOffset(c,o);if(!p)return null;const d=this._constructOffset(c,-o);if(!d)return null;const y=p[p.length-1],z=this._constructArrowBasePoint(p,o/2);if(!z)return null;const T=d[d.length-1],X=this._constructArrowBasePoint(d,-o/2);if(!X)return null;const J=e[e.length-1];this._makeControlPoint(r,!1),this._makeControlPoint(l,!1);const lt=new $;return lt.addPath(r,!0),this._makeControlPoint(lt.path()),lt.lineTo(T),lt.lineTo(X),this._makeControlPoint(lt.path()),lt.lineTo(J),this._makeControlPoint(lt.path()),lt.lineTo(z),this._makeControlPoint(lt.path()),lt.lineTo(y),this._makeControlPoint(lt.path()),lt.addPath(l,!1),{paths:[lt.path()]}}_constructOffset(e,s){return this._curveHelper.offset(e,s,L.id.Rounded,4,this._offsetFlattenError)}_constructArrowBasePoint(e,s){if(!e||e.length<2)return null;const i=e[e.length-2],h=e[e.length-1],o=[h[0]-i[0],h[1]-i[1]];return this._curveHelper.normalize(o),[h[0]+o[1]*s,h[1]-o[0]*s]}_makeControlPoint(e,s=!1){(0,_t.qh)(s?e[0]:e[e.length-1],1)}}W(29132);var ct=W(62208),E=W(29214),St=W(65234);let Ct=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(s,i,h,o,r){return new xt(s,i,h,o,r)}}return f.instance=null,f})();class xt{constructor(e,s,i,h,o){this._inputGeometries=e,this._tileKey=h,this._geometryEngine=o,this._curveHelper=new st,this._size=(void 0!==s.size?s.size:1)*i,this._offsetFlattenError=ut*i}next(){let e;for(;e=this._inputGeometries.next();){if(0===this._size)return e;if((0,it.YX)(e))if(this._size>0){const o=this._curveHelper.offset([[e.xmin,e.ymin],[e.xmin,e.ymax],[e.xmax,e.ymax],[e.xmax,e.ymin],[e.xmin,e.ymin]],this._size,L.id.Rounded,4,this._offsetFlattenError);if(o)return{rings:[o]}}else if(this._size<0&&Math.min(e.xmax-e.xmin,e.ymax-e.ymin)+2*this._size>0)return{xmin:e.xmin-this._size,xmax:e.xmax+this._size,ymin:e.ymin-this._size,ymax:e.ymax+this._size};const s=this._geometryEngine;if((0,ct.Wi)(s))return null;let i=e;if((!(0,it.oU)(e)||!this._tileKey||(i=(0,E.ib)(e,Math.abs(this._size)+1),i&&i.rings&&0!==i.rings.length))&&(!(0,it.l9)(e)||!this._tileKey||(i=(0,E.yn)(e,Math.abs(this._size)+1),i&&i.paths&&0!==i.paths.length)))return s.buffer(St.Z.WebMercator,i,this._size,1)}return null}}let kt=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(s,i,h,o,r){return new zt(s,i,h)}}return f.instance=null,f})();class zt{constructor(e,s,i){this._defaultPointSize=20,this._inputGeometries=e,this._geomUnitsPerPoint=i,this._rule=s.rule??L.Em.FullGeometry,this._defaultSize=this._defaultPointSize*i}next(){let e;for(;e=this._inputGeometries.next();){let s;if((0,it.wp)(e)?s=this._processGeom([[[e.x,e.y]]]):(0,it.aW)(e)?s=this._processGeom([e.points]):(0,it.l9)(e)?s=this._processGeom(e.paths):(0,it.oU)(e)&&(s=this._processGeom(e.rings)),s&&s.length)return{paths:s}}return null}_clone(e){return[e[0],e[1]]}_mid(e,s){return[(e[0]+s[0])/2,(e[1]+s[1])/2]}_mix(e,s,i,h){return[e[0]*s+i[0]*h,e[1]*s+i[1]*h]}_add(e,s){return[e[0]+s[0],e[1]+s[1]]}_add2(e,s,i){return[e[0]+s,e[1]+i]}_sub(e,s){return[e[0]-s[0],e[1]-s[1]]}_dist(e,s){return Math.sqrt((e[0]-s[0])*(e[0]-s[0])+(e[1]-s[1])*(e[1]-s[1]))}_norm(e){return Math.sqrt(e[0]*e[0]+e[1]*e[1])}_normalize(e,s=1){const i=s/this._norm(e);e[0]*=i,e[1]*=i}_leftPerpendicular(e){const i=e[0];e[0]=-e[1],e[1]=i}_leftPerp(e){return[-e[1],e[0]]}_rightPerpendicular(e){const i=-e[0];e[0]=e[1],e[1]=i}_rightPerp(e){return[e[1],-e[0]]}_dotProduct(e,s){return e[0]*s[0]+e[1]*s[1]}_crossProduct(e,s){return e[0]*s[1]-e[1]*s[0]}_rotateDirect(e,s,i){const o=e[0]*i+e[1]*s;e[0]=e[0]*s-e[1]*i,e[1]=o}_makeCtrlPt(e){const s=[e[0],e[1]];return(0,_t.qh)(s,1),s}_addAngledTicks(e,s,i,h){const o=this._sub(i,s);this._normalize(o);const r=this._crossProduct(o,this._sub(h,s));let l;l=r>0?this._rightPerp(o):this._leftPerp(o);const c=Math.abs(r)/2,p=[];p.push([s[0]+(l[0]-o[0])*c,s[1]+(l[1]-o[1])*c]),p.push(s),p.push(i),p.push([i[0]+(l[0]+o[0])*c,i[1]+(l[1]+o[1])*c]),e.push(p)}_addBezier2(e,s,i,h,o){if(0==o--)return void e.push(h);const r=this._mid(s,i),l=this._mid(i,h),c=this._mid(r,l);this._addBezier2(e,s,r,c,o),this._addBezier2(e,c,l,h,o)}_addBezier3(e,s,i,h,o,r){if(0==r--)return void e.push(o);const l=this._mid(s,i),c=this._mid(i,h),p=this._mid(h,o),d=this._mid(l,c),y=this._mid(c,p),z=this._mid(d,y);this._addBezier3(e,s,l,d,z,r),this._addBezier3(e,z,y,p,o,r)}_add90DegArc(e,s,i,h,o){const r=o??this._crossProduct(this._sub(i,s),this._sub(h,s))>0,l=this._mid(s,i),c=this._sub(l,s);r?this._leftPerpendicular(c):this._rightPerpendicular(c),l[0]+=c[0],l[1]+=c[1],this._addBezier3(e,s,this._mix(s,.33333,l,.66667),this._mix(i,.33333,l,.66667),i,4)}_addArrow(e,s,i){const h=s[0],o=s[1],r=s[s.length-1],l=this._sub(h,o);this._normalize(l);const c=this._crossProduct(l,this._sub(r,o)),p=.5*c,d=this._leftPerp(l),y=[r[0]-d[0]*c,r[1]-d[1]*c],z=s.length-1,T=[];T.push(i?[-d[0],-d[1]]:d);let X=[-l[0],-l[1]];for(let J=1;J<z-1;J++){const lt=this._sub(s[J+1],s[J]);this._normalize(lt);const bt=this._dotProduct(lt,X),Ut=this._crossProduct(lt,X),Dt=Math.sqrt((1+bt)/2),Mt=this._sub(lt,X);this._normalize(Mt),Mt[0]/=Dt,Mt[1]/=Dt,T.push(Ut<0?[-Mt[0],-Mt[1]]:Mt),X=lt}T.push(this._rightPerp(X));for(let J=T.length-1;J>0;J--)e.push([s[J][0]+T[J][0]*p,s[J][1]+T[J][1]*p]);e.push([y[0]+T[0][0]*p,y[1]+T[0][1]*p]),e.push([y[0]+T[0][0]*c,y[1]+T[0][1]*c]),e.push(h),e.push([y[0]-T[0][0]*c,y[1]-T[0][1]*c]),e.push([y[0]-T[0][0]*p,y[1]-T[0][1]*p]);for(let J=1;J<T.length;J++)e.push([s[J][0]-T[J][0]*p,s[J][1]-T[J][1]*p])}_cp2(e,s,i){return e.length>=2?e[1]:this._add2(e[0],s*this._defaultSize,i*this._defaultSize)}_cp3(e,s,i,h){if(e.length>=3)return e[2];const o=this._mix(e[0],1-i,s,i),r=this._sub(s,e[0]);return this._normalize(r),this._rightPerpendicular(r),[o[0]+r[0]*h*this._defaultSize,o[1]+r[1]*h*this._defaultSize]}_arrowPath(e){if(e.length>2)return e;const s=e[0],i=this._cp2(e,-4,0),h=this._sub(s,i);this._normalize(h);const o=this._rightPerp(h);return[s,i,[s[0]+(o[0]-h[0])*this._defaultSize,s[1]+(o[1]-h[1])*this._defaultSize]]}_arrowLastSeg(e){const s=e[0],i=this._cp2(e,-4,0);let h;if(e.length>=3)h=e[e.length-1];else{const o=this._sub(s,i);this._normalize(o);const r=this._rightPerp(o);h=[s[0]+(r[0]-o[0])*this._defaultSize,s[1]+(r[1]-o[1])*this._defaultSize]}return[i,h]}_processGeom(e){if(!e)return null;const s=[];for(const i of e){if(!i||0===i.length)continue;const h=i.length;let o=i[0];switch(this._rule){case L.Em.PerpendicularFromFirstSegment:{const r=this._cp2(i,0,-1),l=this._cp3(i,r,.5,4),c=[];c.push(l),c.push(this._mid(o,r)),s.push(c);break}case L.Em.ReversedFirstSegment:{const r=this._cp2(i,0,-1);s.push([r,o]);break}case L.Em.PerpendicularToSecondSegment:{const r=this._cp2(i,-4,1),l=this._cp3(i,r,.882353,-1.94),c=[];c.push(this._mid(r,l)),c.push(o),s.push(c);break}case L.Em.SecondSegmentWithTicks:{const r=this._cp2(i,-4,1),l=this._cp3(i,r,.882353,-1.94),c=this._sub(l,r);let p;p=this._crossProduct(c,this._sub(o,r))>0?this._rightPerp(p):this._leftPerp(c);const d=[];d.push([r[0]+(p[0]-c[0])/3,r[1]+(p[1]-c[1])/3]),d.push(r),d.push(l),d.push([l[0]+(p[0]+c[0])/3,l[1]+(p[1]+c[1])/3]),s.push(d);break}case L.Em.DoublePerpendicular:{const r=this._cp2(i,0,-1),l=this._cp3(i,r,.5,3),c=this._mid(o,r),p=this._sub(c,l);this._normalize(p);const d=this._crossProduct(p,this._sub(o,l));this._leftPerpendicular(p);const y=[];y.push(o),y.push([l[0]+p[0]*d,l[1]+p[1]*d]),s.push(y);const z=[];z.push([l[0]-p[0]*d,l[1]-p[1]*d]),z.push(r),s.push(z);break}case L.Em.OppositeToFirstSegment:{const r=this._cp2(i,0,-1),l=this._cp3(i,r,.5,3),c=this._mid(o,r),p=this._sub(c,l);this._normalize(p);const d=this._crossProduct(p,this._sub(o,l));this._leftPerpendicular(p);const y=[];y.push([l[0]+p[0]*d,l[1]+p[1]*d]),y.push([l[0]-p[0]*d,l[1]-p[1]*d]),s.push(y);break}case L.Em.TriplePerpendicular:{const r=this._cp2(i,0,-1),l=this._cp3(i,r,.5,4),c=this._mid(o,r),p=this._sub(c,l);this._normalize(p);const d=this._crossProduct(p,this._sub(o,l));this._leftPerpendicular(p);const y=[];y.push([l[0]+p[0]*d*.8,l[1]+p[1]*d*.8]),y.push([c[0]+.8*(o[0]-c[0]),c[1]+.8*(o[1]-c[1])]),s.push(y),s.push([l,c]);const z=[];z.push([l[0]-p[0]*d*.8,l[1]-p[1]*d*.8]),z.push([c[0]+.8*(r[0]-c[0]),c[1]+.8*(r[1]-c[1])]),s.push(z);break}case L.Em.HalfCircleFirstSegment:{const r=this._cp2(i,0,-1),l=this._cp3(i,r,.5,4),c=this._mid(o,r);let p=this._sub(r,o);const d=Math.cos(Math.PI/18),y=Math.sin(Math.PI/18),z=Math.sqrt((1+d)/2),T=Math.sqrt((1-d)/2),X=[];let J;this._crossProduct(p,this._sub(l,o))>0?(X.push(o),p=this._sub(o,c),J=r):(X.push(r),p=this._sub(r,c),J=o),this._rotateDirect(p,z,T),p[0]/=z,p[1]/=z;for(let lt=1;lt<=18;lt++)X.push(this._add(c,p)),this._rotateDirect(p,d,y);X.push(J),s.push(X);break}case L.Em.HalfCircleSecondSegment:{const r=this._cp2(i,0,-1),l=this._cp3(i,r,1,-1);let c=this._sub(o,r);this._normalize(c);const p=this._crossProduct(c,this._sub(l,r))/2;this._leftPerpendicular(c);const d=[r[0]+c[0]*p,r[1]+c[1]*p];c=this._sub(r,d);const y=Math.cos(Math.PI/18);let z=Math.sin(Math.PI/18);p>0&&(z=-z);const T=[r];for(let X=1;X<=18;X++)this._rotateDirect(c,y,z),T.push(this._add(d,c));s.push(T);break}case L.Em.HalfCircleExtended:{const r=this._cp2(i,0,-2),l=this._cp3(i,r,1,-1);let c;if(h>=4)c=i[3];else{const X=this._sub(o,r);c=this._add(l,X)}const p=this._dist(r,l)/2/.75,d=this._sub(r,o);this._normalize(d,p);const y=this._sub(l,c);this._normalize(y,p),s.push([c,l]);const T=[this._clone(l)];this._addBezier3(T,l,this._add(l,y),this._add(r,d),r,4),T.push(o),s.push(T);break}case L.Em.OpenCircle:{const r=this._cp2(i,-2,0),l=this._sub(r,o),c=Math.cos(Math.PI/18),p=-Math.sin(Math.PI/18),d=[r];for(let y=1;y<=33;y++)this._rotateDirect(l,c,p),d.push(this._add(o,l));s.push(d);break}case L.Em.CoverageEdgesWithTicks:{const r=this._cp2(i,0,-1);let l,c;if(h>=3)l=i[2];else{const z=this._sub(r,o),T=this._leftPerp(z);l=[o[0]+T[0]-.25*z[0],o[1]+T[1]-.25*z[1]]}if(h>=4)c=i[3];else{const z=this._mid(o,r),T=this._sub(o,r);this._normalize(T),this._leftPerpendicular(T);const X=this._crossProduct(T,this._sub(l,z));this._rightPerpendicular(T),c=[l[0]+T[0]*X*2,l[1]+T[1]*X*2]}const p=this._sub(r,o);let d,y;d=this._crossProduct(p,this._sub(l,o))>0?this._rightPerp(p):this._leftPerp(p),y=[],y.push(l),y.push(o),y.push([o[0]+(d[0]-p[0])/3,o[1]+(d[1]-p[1])/3]),s.push(y),d=this._crossProduct(p,this._sub(c,r))>0?this._rightPerp(d):this._leftPerp(p),y=[],y.push([r[0]+(d[0]+p[0])/3,r[1]+(d[1]+p[1])/3]),y.push(r),y.push(c),s.push(y);break}case L.Em.GapExtentWithDoubleTicks:{const r=this._cp2(i,0,2),l=this._cp3(i,r,0,1);let c;if(h>=4)c=i[3];else{const p=this._sub(r,o);c=this._add(l,p)}this._addAngledTicks(s,o,r,this._mid(l,c)),this._addAngledTicks(s,l,c,this._mid(o,r));break}case L.Em.GapExtentMidline:{const r=this._cp2(i,2,0),l=this._cp3(i,r,0,1);let c;if(h>=4)c=i[3];else{const d=this._sub(r,o);c=this._add(l,d)}const p=[];p.push(this._mid(o,l)),p.push(this._mid(r,c)),s.push(p);break}case L.Em.Chevron:{const r=this._cp2(i,-1,-1);let l;if(h>=3)l=i[2];else{const c=this._sub(r,o);this._leftPerpendicular(c),l=this._add(o,c)}s.push([r,this._makeCtrlPt(o),l]);break}case L.Em.PerpendicularWithArc:{const r=this._cp2(i,0,-2),l=this._cp3(i,r,.5,-1);let c=this._sub(r,o);const p=this._norm(c);c[0]/=p,c[1]/=p;const d=this._crossProduct(c,this._sub(l,o));let y=this._dotProduct(c,this._sub(l,o));y<.05*p?y=.05*p:y>.95*p&&(y=.95*p);const z=[o[0]+c[0]*y,o[1]+c[1]*y];this._leftPerpendicular(c);let T=[];T.push([z[0]-c[0]*d,z[1]-c[1]*d]),T.push([z[0]+c[0]*d,z[1]+c[1]*d]),s.push(T);const X=[r[0]+c[0]*d,r[1]+c[1]*d];c=this._sub(r,X);const J=Math.cos(Math.PI/18);let lt=Math.sin(Math.PI/18);d<0&&(lt=-lt),T=[o,r];for(let bt=1;bt<=9;bt++)this._rotateDirect(c,J,lt),T.push(this._add(X,c));s.push(T);break}case L.Em.ClosedHalfCircle:{const r=this._cp2(i,2,0),l=this._mid(o,r),c=this._sub(r,l),p=Math.cos(Math.PI/18),d=Math.sin(Math.PI/18),y=[o,r];for(let z=1;z<=18;z++)this._rotateDirect(c,p,d),y.push(this._add(l,c));s.push(y);break}case L.Em.TripleParallelExtended:{const r=this._cp2(i,0,-2),l=this._cp3(i,r,1,-2),c=this._mid(o,r),p=this._sub(l,r);this._normalize(p);const d=Math.abs(this._crossProduct(p,this._sub(c,r)))/2,y=this._dist(r,l),z=[r,o];z.push([o[0]+p[0]*y*.5,o[1]+p[1]*y*.5]),s.push(z);const T=[];T.push([c[0]-p[0]*d,c[1]-p[1]*d]),T.push([c[0]+p[0]*y*.375,c[1]+p[1]*y*.375]),(0,_t.qh)(T[T.length-1],1),T.push([c[0]+p[0]*y*.75,c[1]+p[1]*y*.75]),s.push(T),s.push([r,l]);break}case L.Em.ParallelWithTicks:{const r=this._cp2(i,3,0),l=this._cp3(i,r,.5,-1),c=this._sub(l,r);this._normalize(c);const p=this._crossProduct(c,this._sub(l,o));this._leftPerpendicular(c),this._addAngledTicks(s,o,r,l),this._addAngledTicks(s,this._mix(o,1,c,p),this._mix(r,1,c,p),this._mid(o,r));break}case L.Em.Parallel:{const r=this._cp2(i,3,0),l=this._cp3(i,r,.5,-1),c=this._sub(r,o);this._normalize(c);const p=this._leftPerp(c),d=this._crossProduct(c,this._sub(l,o));let y=[o,r];s.push(y),y=[],y.push([o[0]+p[0]*d,o[1]+p[1]*d]),y.push([r[0]+p[0]*d,r[1]+p[1]*d]),s.push(y);break}case L.Em.PerpendicularToFirstSegment:{const r=this._cp2(i,3,0),l=this._cp3(i,r,.5,-1),c=this._mid(o,r),p=this._sub(r,o);this._normalize(p);const d=this._crossProduct(p,this._sub(l,o));this._leftPerpendicular(p);const y=[];y.push([c[0]-p[0]*d*.25,c[1]-p[1]*d*.25]),y.push([c[0]+p[0]*d*1.25,c[1]+p[1]*d*1.25]),s.push(y);break}case L.Em.ParallelOffset:{const r=this._cp2(i,3,0),l=this._cp3(i,r,.5,-1),c=this._sub(r,o);this._normalize(c);const p=this._crossProduct(c,this._sub(l,o));this._leftPerpendicular(c);const d=[];d.push([o[0]-c[0]*p,o[1]-c[1]*p]),d.push([r[0]-c[0]*p,r[1]-c[1]*p]),s.push(d);const y=[];y.push([o[0]+c[0]*p,o[1]+c[1]*p]),y.push([r[0]+c[0]*p,r[1]+c[1]*p]),s.push(y);break}case L.Em.OffsetOpposite:{const r=this._cp2(i,3,0),l=this._cp3(i,r,.5,-1),c=this._sub(r,o);this._normalize(c);const p=this._crossProduct(c,this._sub(l,o));this._leftPerpendicular(c);const d=[];d.push([o[0]-c[0]*p,o[1]-c[1]*p]),d.push([r[0]-c[0]*p,r[1]-c[1]*p]),s.push(d);break}case L.Em.OffsetSame:{const r=this._cp2(i,3,0),l=this._cp3(i,r,.5,-1),c=this._sub(r,o);this._normalize(c);const p=this._crossProduct(c,this._sub(l,o));this._leftPerpendicular(c);const d=[];d.push([o[0]+c[0]*p,o[1]+c[1]*p]),d.push([r[0]+c[0]*p,r[1]+c[1]*p]),s.push(d);break}case L.Em.CircleWithArc:{let r=this._cp2(i,3,0);const l=this._cp3(i,r,.5,-1);let c,p;if(h>=4)c=i[3],p=this._crossProduct(this._sub(c,r),this._sub(l,r))>0;else{c=r,p=this._crossProduct(this._sub(c,o),this._sub(l,o))>0;const X=24*this._geomUnitsPerPoint,J=this._sub(c,o);this._normalize(J,X);const lt=Math.sqrt(2)/2;this._rotateDirect(J,lt,p?lt:-lt),r=this._add(o,J)}const d=this._sub(r,o),y=Math.cos(Math.PI/18),z=Math.sin(Math.PI/18),T=[r];for(let X=1;X<=36;X++)this._rotateDirect(d,y,z),T.push(this._add(o,d));this._add90DegArc(T,r,c,l,p),(0,_t.qh)(T[T.length-8],1),s.push(T);break}case L.Em.DoubleJog:{let r,l,c=this._cp2(i,-3,1);if(r=h>=3?i[2]:this._add(o,this._sub(o,c)),h>=4)l=i[3];else{const bt=o;o=c,l=r;const Ut=this._dist(o,bt),Dt=this._dist(l,bt);let Mt=30*this._geomUnitsPerPoint;.5*Ut<Mt&&(Mt=.5*Ut),.5*Dt<Mt&&(Mt=.5*Dt),c=this._mix(o,Mt/Ut,bt,(Ut-Mt)/Ut),r=this._mix(l,Mt/Dt,bt,(Dt-Mt)/Dt)}const p=this._mid(o,c),d=this._mid(l,r),y=this._dist(o,c),z=this._dist(r,l);let T=Math.min(y,z)/8;T=Math.min(T,24*this._geomUnitsPerPoint);const X=Math.cos(Math.PI/4);let J=this._sub(o,c);this._normalize(J,T),this._crossProduct(J,this._sub(l,c))>0?this._rotateDirect(J,X,-X):this._rotateDirect(J,X,X);let lt=[];lt.push(c),lt.push(this._add(p,J)),lt.push(this._sub(p,J)),lt.push(o),s.push(lt),J=this._sub(l,r),this._normalize(J,T),this._crossProduct(J,this._sub(o,r))<0?this._rotateDirect(J,X,X):this._rotateDirect(J,X,-X),lt=[],lt.push(r),lt.push(this._add(d,J)),lt.push(this._sub(d,J)),lt.push(l),s.push(lt);break}case L.Em.PerpendicularOffset:{const r=this._cp2(i,-4,1),l=this._cp3(i,r,.882353,-1.94),c=this._sub(l,r);this._crossProduct(c,this._sub(o,r))>0?this._rightPerpendicular(c):this._leftPerpendicular(c);const p=[c[0]/8,c[1]/8],d=this._sub(this._mid(r,l),p);s.push([d,o]);break}case L.Em.LineExcludingLastSegment:{const r=this._arrowPath(i),l=[];let c=r.length-2;for(;c--;)l.push(r[c]);s.push(l);break}case L.Em.MultivertexArrow:{const r=this._arrowPath(i),l=[];this._addArrow(l,r,!1),s.push(l);break}case L.Em.CrossedArrow:{const r=this._arrowPath(i),l=[];this._addArrow(l,r,!0),s.push(l);break}case L.Em.ChevronArrow:{const[r,l]=this._arrowLastSeg(i),c=10*this._geomUnitsPerPoint,p=this._sub(o,r);this._normalize(p);const d=this._crossProduct(p,this._sub(l,r)),y=this._leftPerp(p),z=[l[0]-y[0]*d*2,l[1]-y[1]*d*2],T=[];T.push([l[0]+p[0]*c,l[1]+p[1]*c]),T.push(o),T.push([z[0]+p[0]*c,z[1]+p[1]*c]),s.push(T);break}case L.Em.ChevronArrowOffset:{const[r,l]=this._arrowLastSeg(i),c=this._sub(o,r);this._normalize(c);const p=this._crossProduct(c,this._sub(l,r));this._leftPerpendicular(c);const d=[l[0]-c[0]*p,l[1]-c[1]*p],y=[];y.push([d[0]+c[0]*p*.5,d[1]+c[1]*p*.5]),y.push(this._mid(d,o)),y.push([d[0]-c[0]*p*.5,d[1]-c[1]*p*.5]),s.push(y);break}case L.Em.PartialFirstSegment:{const[r,l]=this._arrowLastSeg(i),c=this._sub(o,r);this._normalize(c);const p=this._crossProduct(c,this._sub(l,r));this._leftPerpendicular(c),s.push([r,[l[0]-c[0]*p,l[1]-c[1]*p]]);break}case L.Em.Arch:{const r=this._cp2(i,0,-1),l=this._cp3(i,r,.5,1),c=this._sub(o,r),p=this._mix(l,1,c,.55),d=this._mix(l,1,c,-.55),y=[o];this._addBezier2(y,o,p,l,4),this._addBezier2(y,l,d,r,4),s.push(y);break}case L.Em.CurvedParallelTicks:{const r=this._cp2(i,-4,1),l=this._cp3(i,r,.882353,-1.94),c=this._sub(l,r);this._crossProduct(c,this._sub(o,r))>0?this._rightPerpendicular(c):this._leftPerpendicular(c);const p=[c[0]/8,c[1]/8],d=this._sub(this._mid(r,l),p),y=this._sub(this._mix(r,.75,l,.25),p),z=this._sub(this._mix(r,.25,l,.75),p),T=[r];this._addBezier2(T,r,y,d,3),this._addBezier2(T,d,z,l,3),s.push(T);for(let X=0;X<8;X++){const J=T[2*X+1],lt=[this._clone(J)];lt.push(this._add(J,[c[0]/4,c[1]/4])),s.push(lt)}break}case L.Em.Arc90Degrees:{const r=this._cp2(i,0,-1),l=this._cp3(i,r,.5,1),c=[r];this._add90DegArc(c,r,o,l),s.push(c);break}default:s.push(i)}}return s}}let R=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(s,i,h,o,r){return new et(s,i,h)}}return f.instance=null,f})();class et extends _t.zY{constructor(e,s,i){super(e,!0,!0),this._curveHelper=new st,this._beginCut=(void 0!==s.beginCut?s.beginCut:1)*i,this._endCut=(void 0!==s.endCut?s.endCut:1)*i,this._middleCut=(void 0!==s.middleCut?s.middleCut:0)*i,this._invert=void 0!==s.invert&&s.invert,this._beginCut<0&&(this._beginCut=0),this._endCut<0&&(this._endCut=0),this._middleCut<0&&(this._middleCut=0)}processPath(e){const s=this._beginCut,i=this._endCut,h=this._middleCut,o=this._curveHelper.calculatePathLength(e),r=[];if(this._invert){if(0!==s||0!==i||0!==h)if(s+i+h>=o)r.push(e);else{let l=this._curveHelper.getSubCurve(e,0,s);l&&r.push(l),l=this._curveHelper.getSubCurve(e,.5*(o-h),.5*(o+h)),l&&r.push(l),l=this._curveHelper.getSubCurve(e,o-i,i),l&&r.push(l)}}else if(0===s&&0===i&&0===h)r.push(e);else if(!(s+i+h>=o))if(0===h){const l=this._curveHelper.getSubCurve(e,s,o-i);l&&r.push(l)}else{let l=this._curveHelper.getSubCurve(e,s,.5*(o-h));l&&r.push(l),l=this._curveHelper.getSubCurve(e,.5*(o+h),o-i),l&&r.push(l)}return 0===r.length?null:{paths:r}}}class Nt{constructor(){this._values=[],this.extPtGap=0,this.ctrlPtGap=0,this._length=0,this._currentValue=0}isEmpty(){return 0===this._values.length}size(){return this._values.length}init(e,s,i=!0){if(this._setEmpty(),!e||0===e.length)return!1;for(let h=0;h<e.length;h++){let o=Math.abs(e[h]);i&&o<1e-7&&(o=1e-7),this._values.push(o),this._length+=o}return s&&1&e.length&&(this._length*=2),0!==this._length&&(this.ctrlPtGap=this.extPtGap=0,this._currentValue=-1,!0)}scale(e){const s=this._values?this._values.length:0;for(let i=0;i<s;++i)this._values[i]*=e;this._length*=e,this.extPtGap*=e,this.ctrlPtGap*=e}addValue(e){this._length+=e,this._values.push(e)}firstValue(){return this._values[0]}lastValue(){return this._values[this._values.length-1]}nextValue(){return this._currentValue++,this._currentValue===this._values.length&&(this._currentValue=0),this._values[this._currentValue]}reset(){this._currentValue=-1}length(){return this._length}_setEmpty(){this.extPtGap=this.ctrlPtGap=this._length=0,this._currentValue=-1,this._values.length=0}}class dt{constructor(){this.pt=null,this.ca=0,this.sa=0}}var At,f;(f=At||(At={}))[f.FAIL=0]="FAIL",f[f.END=1]="END",f[f.CONTINUE=2]="CONTINUE";class mt{constructor(){this.reset()}reset(){this.segment=-1,this.segmentLength=0,this.abscissa=0,this.isPathEnd=!1,this.isPartEnd=!1}isValid(){return-1!==this.segment}copyTo(e){e.segment=this.segment,e.segmentLength=this.segmentLength,e.abscissa=this.abscissa,e.isPathEnd=this.isPathEnd,e.isPartEnd=this.isPartEnd}}class H extends st{constructor(e=0,s=!1){super(e,s),this._tolerance=ut,this._currentPosition=new mt}updateTolerance(e){this._tolerance=ut*e}init(e,s,i=!0){return i?(this._patternLength=s.length(),this._partExtPtGap=s.extPtGap,this._partCtrlPtGap=s.ctrlPtGap):(this._patternLength=0,this._partExtPtGap=0,this._partCtrlPtGap=0),this._currentPosition.reset(),this._partSegCount=0,this._path=e,this._seg=-1,this._setPosAtNextPart()}curPositionIsValid(){return this._currentPosition.isValid()}nextPosition(e,s=At.FAIL){const i=new mt;return!!this._nextPosition(e,i,null,s)&&(i.copyTo(this._currentPosition),!0)}curPointAndAngle(e){e.pt=this._getPoint(this._currentPosition);const[s,i]=this._getAngle(this._currentPosition);e.ca=s,e.sa=i}nextPointAndAngle(e,s,i=At.FAIL){const h=new mt;if(!this._nextPosition(e,h,null,i))return!1;h.copyTo(this._currentPosition),s.pt=this._getPoint(h);const[o,r]=this._getAngle(h);return s.ca=o,s.sa=r,!0}nextCurve(e){if(0===e)return null;const s=[],i=new mt;return this._nextPosition(e,i,s,At.END)?(i.copyTo(this._currentPosition),s):null}isPathEnd(){return this._currentPosition.isPathEnd}getPathEnd(){if(-1===this._currentPosition.segment)throw new Error("missing segment");return this._path[this._currentPosition.segment+1]}_nextPosition(e,s,i,h){if(this._currentPosition.isPathEnd)return!1;let o=this._currentPosition.abscissa;for(this._currentPosition.segmentLength>0&&(o/=this._currentPosition.segmentLength),this._currentPosition.copyTo(s);s.abscissa+e*this._partLengthRatio>s.segmentLength+this._tolerance;){if(i){if(0===i.length)if(0===o){const l=this._path[s.segment];i.push([l[0],l[1]])}else i.push(this.getSegCoord2D(this._path,s.segment,o));const r=this._path[s.segment+1];i.push([r[0],r[1]])}if(o=0,e-=(s.segmentLength-s.abscissa)/this._partLengthRatio,this._partSegCount)s.segment=this._nextSegment(),s.segmentLength=this.calculateSegLength(this._path,s.segment),s.abscissa=0,this._partSegCount--;else{if(!this._setPosAtNextPart())return h!==At.FAIL&&(s.segmentLength=this.calculateSegLength(this._path,s.segment),s.isPartEnd=!0,h===At.END?(s.abscissa=s.segmentLength,s.isPathEnd=!0):s.abscissa=s.segmentLength+e,!0);this._currentPosition.copyTo(s)}}if(s.abscissa+=e*this._partLengthRatio,i){if(0===i.length)if(0===o){const l=this._path[s.segment];i.push([l[0],l[1]])}else i.push(this.getSegCoord2D(this._path,s.segment,o));const r=s.abscissa/s.segmentLength;if(1===r){const l=this._path[s.segment+1];i.push([l[0],l[1]])}else i.push(this.getSegCoord2D(this._path,s.segment,r))}return this._partSegCount||Math.abs(s.abscissa-s.segmentLength)<this._tolerance&&(s.isPathEnd=this._partIsLast,s.isPartEnd=!0),!0}_getPoint(e){if(-1===e.segment)throw new Error("missing segment");return this.getSegCoord2D(this._path,e.segment,e.segmentLength<=0?0:e.abscissa/e.segmentLength)}_getAngle(e){if(-1===e.segment)throw new Error("missing segment");return this.getSegAngleCS(this._path,e.segment,e.segmentLength<=0?0:e.abscissa/e.segmentLength)}_setPosAtNextPart(){for(;this._partSegCount;)this._hasNextSegment()&&this._nextSegment(),this._partSegCount--;if(!this._hasNextSegment())return!1;for(this._partLength=0,this._partIsLast=!0,this._partSegCount=0;this._hasNextSegment();)if(this._partLength+=this.calculateSegLength(this._path,this._nextSegment()),this._partSegCount++,1===(0,_t.zv)(this._path[this._getEndPointIndex()])){this._partIsLast=!this._hasNextSegment();break}let e=this._partSegCount;for(;e;)this._previousSegment(),--e;this._currentPosition.segment=this._nextSegment(),this._currentPosition.segmentLength=this.calculateSegLength(this._path,this._currentPosition.segment),this._currentPosition.abscissa=0,this._currentPosition.isPathEnd=this._currentPosition.isPartEnd=!1,--this._partSegCount;const s=this._getStartPointIndex();this._ctrlPtBegin=1===(0,_t.zv)(this._path[s]);let i=s+this._partSegCount+1;if(i>=this._path.length&&(i=0),this._ctrlPtEnd=1===(0,_t.zv)(this._path[i]),this._patternLength>0){const h=this._ctrlPtBegin?this._partCtrlPtGap:this._partExtPtGap,o=this._ctrlPtEnd?this._partCtrlPtGap:this._partExtPtGap;let r=Math.round((this._partLength-(h+o))/this._patternLength);r<=0&&(r=h+o>0?0:1),this._partLengthRatio=this._partLength/(h+o+r*this._patternLength),this._partLengthRatio<.01&&(this._partLengthRatio=1)}else this._partLengthRatio=1;return!0}_hasNextSegment(){return this._seg<this._path.length-2}_previousSegment(){return--this._seg}_nextSegment(){return++this._seg}_getStartPointIndex(){return this._seg}_getEndPointIndex(){return this._seg+1}}let Q=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(s,i,h,o,r){return new B(s,i,h)}}return f.instance=null,f})();class B extends _t.zY{constructor(e,s,i){super(e,!0,!0),this._firstCurve=null,this._walker=new H,this._walker.updateTolerance(i),this._endings=s.lineDashEnding,this._customDashPos=-(s.offsetAlongLine??0)*i,this._offsetAtEnd=(s.customEndingOffset??0)*i,this._pattern=new Nt,this._pattern.init(s.dashTemplate,!0),this._pattern.scale(i)}processPath(e){if(0===this._pattern.length())return this.iteratePath=!1,{paths:[e]};if(!this.iteratePath){let h=!0;switch(this._endings){case L.sj.HalfPattern:case L.sj.HalfGap:default:this._pattern.extPtGap=0;break;case L.sj.FullPattern:this.isClosed||(this._pattern.extPtGap=.5*this._pattern.firstValue());break;case L.sj.FullGap:this.isClosed||(this._pattern.extPtGap=.5*this._pattern.lastValue());break;case L.sj.NoConstraint:this.isClosed||(h=!1);break;case L.sj.Custom:this.isClosed||(this._pattern.extPtGap=.5*this._offsetAtEnd)}const o=this._walker.calculatePathLength(e);if(this._pattern.isEmpty()||o<.1*this._pattern.length())return{paths:[e]};if(!this._walker.init(e,this._pattern,h))return{paths:[e]}}let s;if(this.iteratePath)s=this._pattern.nextValue();else{let h;switch(this._endings){case L.sj.HalfPattern:default:h=.5*this._pattern.firstValue();break;case L.sj.HalfGap:h=.5*-this._pattern.lastValue();break;case L.sj.FullGap:h=-this._pattern.lastValue();break;case L.sj.FullPattern:h=0;break;case L.sj.NoConstraint:case L.sj.Custom:h=-this._customDashPos}let o=h/this._pattern.length();o-=Math.floor(o),h=o*this._pattern.length(),this._pattern.reset(),s=this._pattern.nextValue();let r=!1;for(;h>=s;)h-=s,s=this._pattern.nextValue(),r=!r;s-=h,r?(this._walker.nextPosition(s),s=this._pattern.nextValue()):this.isClosed&&(this._firstCurve=this._walker.nextCurve(s),s=this._pattern.nextValue(),this._walker.nextPosition(s),s=this._pattern.nextValue())}let i=this._walker.nextCurve(s);return i?this._walker.isPathEnd()?(this.iteratePath=!1,this._firstCurve&&(this._firstCurve.splice(0,1),$.mergePath(i,this._firstCurve),this._firstCurve=null)):(s=this._pattern.nextValue(),!this._walker.nextPosition(s)||this._walker.isPathEnd()?(this.iteratePath=!1,this._firstCurve&&(i=this._firstCurve,this._firstCurve=null)):this.iteratePath=!0):(this.iteratePath=!1,i=this._firstCurve,this._firstCurve=null),{paths:[i]}}}let K=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(s,i,h,o,r){return new nt(s,i,h,o,r)}}return f.instance=null,f})();class nt{constructor(e,s,i,h,o){this._inputGeometries=e,this._tileKey=h,this._geometryEngine=o,this._width=(void 0!==s.width?s.width:2)*i,this._option=s.option}next(){let e;for(;e=this._inputGeometries.next();){if((0,it.YX)(e)&&this._width>0){if(Math.min(e.xmax-e.xmin,e.ymax-e.ymin)-2*this._width<0)return e;const s=[];return s.push([[e.xmin,e.ymin],[e.xmin,e.ymax],[e.xmax,e.ymax],[e.xmax,e.ymin],[e.xmin,e.ymin]]),s.push([[e.xmin+this._width,e.ymin+this._width],[e.xmax-this._width,e.ymin+this._width],[e.xmax-this._width,e.ymax-this._width],[e.xmin+this._width,e.ymax-this._width],[e.xmin+this._width,e.ymin+this._width]]),{rings:s}}if((0,it.oU)(e)){let s=null;const i=this._geometryEngine;let h=e;if(this._tileKey&&(h=(0,E.ib)(e,Math.abs(this._width)+1),!h||!h.rings||0===h.rings.length))continue;if((0,ct.pC)(i)&&(s=i.buffer(St.Z.WebMercator,h,-this._width,1)),this._width>0){const o=[];for(const r of e.rings)r&&o.push(r);if(s)for(const r of s.rings)r&&o.push(r.reverse());if(o.length)return{rings:o}}}}return null}}let pt=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(s,i,h,o,r){return new Tt(s,i,h)}}return f.instance=null,f})();class Tt extends _t.zY{constructor(e,s,i){super(e,!1,!0),this._curveHelper=new st,this._length=(void 0!==s.length?s.length:20)*i,this._angle=void 0!==s.angle?s.angle:225,this._position=void 0!==s.position?s.position:50,this._length<0&&(this._length=-this._length),this._position<20&&(this._position=20),this._position>80&&(this._position=80),this._mirror=!1}processPath(e){if(this._curveHelper.isEmpty(e,!1))return null;const s=e[0],i=e[e.length-1];this._curveHelper.normalize([i[0]-s[0],i[1]-s[1]]);const o=[s[0]+(i[0]-s[0])*this._position/100,s[1]+(i[1]-s[1])*this._position/100],r=Math.cos((90-this._angle)/180*Math.PI);let l=Math.sin((90-this._angle)/180*Math.PI);return this._mirror&&(l=-l),this._mirror=!this._mirror,{paths:[[s,[o[0]-this._length/2*r,o[1]-this._length/2*l],[o[0]+this._length/2*r,o[1]+this._length/2*l],i]]}}}let It=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(s,i,h,o,r){return new Gt(s,i,h)}}return f.instance=null,f})();class Gt{constructor(e,s,i){this._inputGeometries=e,this._offsetX=void 0!==s.offsetX?s.offsetX*i:0,this._offsetY=void 0!==s.offsetY?-s.offsetY*i:0}next(){let e=this._inputGeometries.next();for(;e;){if((0,it.YX)(e))return{xmin:e.xmin+this._offsetX,xmax:e.xmax+this._offsetX,ymin:e.ymin+this._offsetY,ymax:e.ymax+this._offsetY};if((0,it.oU)(e)){const s=(0,Ot.d9)(e);return this._moveMultipath(s.rings,this._offsetX,this._offsetY),s}if((0,it.l9)(e)){const s=(0,Ot.d9)(e);return this._moveMultipath(s.paths,this._offsetX,this._offsetY),s}if((0,it.aW)(e)){const s=(0,Ot.d9)(e);return this._movePath(s.points,this._offsetX,this._offsetY),s}if((0,it.wp)(e))return{x:e.x+this._offsetX,y:e.y+this._offsetY};e=this._inputGeometries.next()}return null}_moveMultipath(e,s,i){if(e)for(const h of e)this._movePath(h,s,i)}_movePath(e,s,i){if(e)for(const h of e)h[0]+=s,h[1]+=i}}let Xt=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(s,i,h,o,r){return new ot(s,i,h,o,r)}}return f.instance=null,f})();class ot{constructor(e,s,i,h,o){this._inputGeometries=e,this._tileKey=h,this._geometryEngine=o,this._curveHelper=new st,this._offset=(s.offset??1)*i,this._method=s.method,this._option=s.option,this._offsetFlattenError=ut*i}next(){let e;for(;e=this._inputGeometries.next();){if(0===this._offset)return e;if((0,it.YX)(e)){if(this._method===L.id.Rounded&&this._offset>0){const o=this._curveHelper.offset([[e.xmin,e.ymin],[e.xmin,e.ymax],[e.xmax,e.ymax],[e.xmax,e.ymin],[e.xmin,e.ymin]],-this._offset,this._method,4,this._offsetFlattenError);return o?{rings:[o]}:null}if(Math.min(e.xmax-e.xmin,e.ymax-e.ymin)+2*this._offset>0)return{xmin:e.xmin-this._offset,xmax:e.xmax+this._offset,ymin:e.ymin-this._offset,ymax:e.ymax+this._offset}}const s=this._geometryEngine;if((0,ct.Wi)(s))return null;let i=e;if((0,it.oU)(e)){if(this._tileKey&&(i=(0,E.ib)(e,Math.abs(this._offset)+1),!i||!i.rings||0===i.rings.length))continue}else if((0,it.l9)(e)&&this._tileKey&&(i=(0,E.yn)(e,Math.abs(this._offset)+1),!i||!i.paths||0===i.paths.length))continue;return s.offset(St.Z.WebMercator,i,-this._offset,1,this._method,4,this._offsetFlattenError)}return null}}let a=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(s,i,h,o,r){return new _(s,i,h)}}return f.instance=null,f})();class _{constructor(e,s,i){this._inputGeometries=e,this._reverse=void 0===s.reverse||s.reverse}next(){let e=this._inputGeometries.next();for(;e;){if(!this._reverse)return e;if((0,it.l9)(e)){const s=(0,Ot.d9)(e);return(0,_t.ov)(s.paths),s}e=this._inputGeometries.next()}return null}}var k=W(65401),b=W(32442);let I=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(s,i,h,o,r){return new F(s,i,h)}}return f.instance=null,f})();class F{constructor(e,s,i){this._inputGeometries=e,this._rotateAngle=void 0!==s.angle?s.angle*Math.PI/180:0}next(){let e=this._inputGeometries.next();for(;e;){if(0===this._rotateAngle)return e;const s=(0,k.Ue)();(0,b.$P)(s,e);const i=(s[2]+s[0])/2,h=(s[3]+s[1])/2;if((0,it.YX)(e)){const o={rings:[[[e.xmin,e.ymin],[e.xmin,e.ymax],[e.xmax,e.ymax],[e.xmax,e.ymin],[e.xmin,e.ymin]]]};return this._rotateMultipath(o.rings,i,h),o}if((0,it.oU)(e)){const o=(0,Ot.d9)(e);return this._rotateMultipath(o.rings,i,h),o}if((0,it.l9)(e)){const o=(0,Ot.d9)(e);return this._rotateMultipath(o.paths,i,h),o}if((0,it.aW)(e)){const o=(0,Ot.d9)(e);return this._rotatePath(o.points,i,h),o}if((0,it.wp)(e))return e;e=this._inputGeometries.next()}return null}_rotateMultipath(e,s,i){if(e)for(const h of e)this._rotatePath(h,s,i)}_rotatePath(e,s,i){if(e){const h=Math.cos(this._rotateAngle),o=Math.sin(this._rotateAngle);for(const r of e){const l=r[0]-s,c=r[1]-i;r[0]=s+l*h-c*o,r[1]=i+l*o+c*h}}}}let x=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(s,i,h,o,r){return new q(s,i,h)}}return f.instance=null,f})();class q{constructor(e,s,i){this._inputGeometries=e,this._xFactor=void 0!==s.xScaleFactor?s.xScaleFactor:1.15,this._yFactor=void 0!==s.yScaleFactor?s.yScaleFactor:1.15}next(){let e=this._inputGeometries.next();for(;e;){if(1===this._xFactor&&1===this._yFactor)return e;const s=(0,k.Ue)();(0,b.$P)(s,e);const i=(s[2]+s[0])/2,h=(s[3]+s[1])/2;if((0,it.YX)(e)){const o={rings:[[[e.xmin,e.ymin],[e.xmin,e.ymax],[e.xmax,e.ymax],[e.xmax,e.ymin],[e.xmin,e.ymin]]]};return this._scaleMultipath(o.rings,i,h),o}if((0,it.oU)(e)){const o=(0,Ot.d9)(e);return this._scaleMultipath(o.rings,i,h),o}if((0,it.l9)(e)){const o=(0,Ot.d9)(e);return this._scaleMultipath(o.paths,i,h),o}if((0,it.aW)(e)){const o=(0,Ot.d9)(e);return this._scalePath(o.points,i,h),o}if((0,it.wp)(e))return e;e=this._inputGeometries.next()}return null}_scaleMultipath(e,s,i){if(e)for(const h of e)this._scalePath(h,s,i)}_scalePath(e,s,i){if(e)for(const h of e){const r=(h[1]-i)*this._yFactor;h[0]=s+(h[0]-s)*this._xFactor,h[1]=i+r}}}let gt=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(s,i,h,o,r){return new O(s,i,h)}}return f.instance=null,f})();class O{constructor(e,s,i){this._inputGeometries=e,this._height=(void 0!==s.amplitude?s.amplitude:2)*i,this._period=(void 0!==s.period?s.period:3)*i,this._style=s.waveform,this._height<=0&&(this._height=Math.abs(this._height)),this._period<=0&&(this._period=Math.abs(this._period)),this._pattern=new Nt,this._pattern.addValue(this._period),this._pattern.addValue(this._period),this._walker=new H,this._walker.updateTolerance(i)}next(){let e=this._inputGeometries.next();for(;e;){if(0===this._height||0===this._period)return e;if((0,it.l9)(e)){const s=this._processGeom(e.paths);if(s.length)return{paths:s}}if((0,it.oU)(e)){const s=this._processGeom(e.rings);if(s.length)return{rings:s}}e=this._inputGeometries.next()}return null}_processGeom(e){const s=[];for(const i of e)if(this._walker.init(i,this._pattern))switch(this._style){case L.zQ.Sinus:default:s.push(this._constructCurve(i,!1));break;case L.zQ.Square:s.push(this._constructSquare(i));break;case L.zQ.Triangle:s.push(this._constructTriangle(i));break;case L.zQ.Random:s.push(this._constructCurve(i,!0))}else s.push(i);return s}_constructCurve(e,s){const i=new $,h=this._walker.calculatePathLength(e);let o=Math.round(h/this._period);0===o&&(o=1);const c=this._period/16,p=1/(16*o+1),d=2*Math.PI*h/(h/o),y=2*Math.PI*Math.random(),z=2*Math.PI*Math.random(),T=2*Math.PI*Math.random(),X=.75-Math.random()/2,J=.75-Math.random()/2,lt=new dt;this._walker.curPointAndAngle(lt),i.startPath(lt.pt);let bt=0;for(;;){if(!this._walker.nextPointAndAngle(c,lt)){i.lineTo(e[e.length-1]);break}{const Ut=bt;let Dt;if(bt+=p,s){const Mt=this._height/2*(1+.3*Math.sin(X*d*Ut+y));Dt=Mt*Math.sin(d*Ut+z),Dt+=Mt*Math.sin(J*d*Ut+T),Dt/=2}else Dt=.5*this._height*Math.sin(.5*d*Ut);i.lineTo([lt.pt[0]-Dt*lt.sa,lt.pt[1]+Dt*lt.ca])}}return i.path()}_constructSquare(e){const s=new $,i=this._walker.calculatePathLength(e);Math.round(i/this._period);let h=!0;for(;;){let o=!1;if(this._walker.curPositionIsValid()){const r=new dt;this._walker.curPointAndAngle(r);const l=new dt;if(this._walker.nextPointAndAngle(this._period,l)){const c=new dt;this._walker.nextPointAndAngle(this._period,c)&&(h?(s.startPath(r.pt),h=!1):s.lineTo(r.pt),s.lineTo([r.pt[0]-this._height/2*r.sa,r.pt[1]+this._height/2*r.ca]),s.lineTo([l.pt[0]-this._height/2*l.sa,l.pt[1]+this._height/2*l.ca]),s.lineTo([l.pt[0]+this._height/2*l.sa,l.pt[1]-this._height/2*l.ca]),s.lineTo([c.pt[0]+this._height/2*c.sa,c.pt[1]-this._height/2*c.ca]),o=!0)}}if(!o){s.lineTo(this._walker.getPathEnd());break}}return s.path()}_constructTriangle(e){const s=new $,i=this._walker.calculatePathLength(e);Math.round(i/this._period);let h=!0;for(;;){let o=!1;if(this._walker.curPositionIsValid()){const r=new dt;this._walker.curPointAndAngle(r);const l=new dt;if(this._walker.nextPointAndAngle(this._period/2,l)){const c=new dt;this._walker.nextPointAndAngle(this._period,c)&&(this._walker.nextPosition(this._period/2)&&(h?(s.startPath(r.pt),h=!1):s.lineTo(r.pt),s.lineTo([l.pt[0]-this._height/2*l.sa,l.pt[1]+this._height/2*l.ca]),s.lineTo([c.pt[0]+this._height/2*c.sa,c.pt[1]-this._height/2*c.ca])),o=!0)}}if(!o){s.lineTo(this._walker.getPathEnd());break}}return s.path()}}let u=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(s,i,h,o,r){return new g(s,i,h)}}return f.instance=null,f})();class g extends _t.v1{constructor(e,s,i){super(e,!0,!0),this._geometryWalker=new H,this._geometryWalker.updateTolerance(i),this._angleToLine=s.angleToLine??!0,this._offset=(s.offset?s.offset:0)*i,this._originalEndings=s.endings,this._offsetAtEnd=(s.customEndingOffset?s.customEndingOffset:0)*i,this._position=-(s.offsetAlongLine?s.offsetAlongLine:0)*i,this._pattern=new Nt,this._pattern.init(s.placementTemplate,!1),this._pattern.scale(i),this._endings=this._originalEndings}processPath(e){if(this._pattern.isEmpty())return null;let s;if(this.iteratePath)s=this._pattern.nextValue();else{this._endings=this._originalEndings===L.JS.WithFullGap&&this.isClosed?L.JS.WithMarkers:this._originalEndings,this._pattern.extPtGap=0;let h,o=!0;switch(this._endings){case L.JS.NoConstraint:h=-this._position,h=this._adjustPosition(h),o=!1;break;case L.JS.WithHalfGap:default:h=-this._pattern.lastValue()/2;break;case L.JS.WithFullGap:h=-this._pattern.lastValue(),this._pattern.extPtGap=this._pattern.lastValue();break;case L.JS.WithMarkers:h=0;break;case L.JS.Custom:h=-this._position,h=this._adjustPosition(h),this._pattern.extPtGap=.5*this._offsetAtEnd}if(!this._geometryWalker.init(e,this._pattern,o))return null;this._pattern.reset();let r=0;for(;h>r;)h-=r,r=this._pattern.nextValue();r-=h,s=r,this.iteratePath=!0}const i=new dt;return this._geometryWalker.nextPointAndAngle(s,i)?this._endings===L.JS.WithFullGap&&this._geometryWalker.isPathEnd()?(this.iteratePath=!1,null):this._endings===L.JS.WithMarkers&&this._geometryWalker.isPathEnd()&&(this.iteratePath=!1,this.isClosed)?null:(this.internalPlacement.setTranslate(i.pt[0]-this._offset*i.sa,i.pt[1]+this._offset*i.ca),this._angleToLine&&this.internalPlacement.setRotateCS(i.ca,i.sa),this.internalPlacement):(this.iteratePath=!1,null)}_adjustPosition(e){let s=e/this._pattern.length();return s-=Math.floor(s),s*this._pattern.length()}}let S=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(s,i,h,o,r){return new w(s,i,h)}}return f.instance=null,f})();class w extends _t.v1{constructor(e,s,i){super(e,!1,!0),this._curveHelper=new st,this._angleToLine=void 0===s.angleToLine||s.angleToLine,this._offset=void 0!==s.offset?s.offset*i:0,this._type=s.extremityPlacement,this._position=void 0!==s.offsetAlongLine?s.offsetAlongLine*i:0,this._beginProcessed=!1}processPath(e){let s;switch(this._type){case L.Tx.Both:default:this._beginProcessed?(s=this._atExtremities(e,this._position,!1),this._beginProcessed=!1,this.iteratePath=!1):(s=this._atExtremities(e,this._position,!0),this._beginProcessed=!0,this.iteratePath=!0);break;case L.Tx.JustBegin:s=this._atExtremities(e,this._position,!0);break;case L.Tx.JustEnd:s=this._atExtremities(e,this._position,!1);case L.Tx.None:}return s}_atExtremities(e,s,i){const h=e.length;if(h<2)return null;const r=i?h:-1,l=i?1:-1;let c,p=0,d=i?e[0]:e[h-1];for(let y=i?1:h-2;y!==r;y+=l){c=d,d=e[y];const z=this._curveHelper.calculateLength(c,d);if(p+z>s){const T=(s-p)/z,[X,J]=this._curveHelper.getAngleCS(c,d,T),lt=(0,_t.XV)(c,d,T);return this.internalPlacement.setTranslate(lt[0]-this._offset*J,lt[1]+this._offset*X),this._angleToLine&&this.internalPlacement.setRotateCS(-X,-J),this.internalPlacement}p+=z}return null}}let C=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(s,i,h,o,r){return new n(s,i,h)}}return f.instance=null,f})();class n extends _t.v1{constructor(e,s,i){super(e,!0,!0),this._walker=new H,this._walker.updateTolerance(i),this._angleToLine=void 0===s.angleToLine||s.angleToLine,this._offset=void 0!==s.offset?s.offset*i:0,this._beginGap=void 0!==s.beginPosition?s.beginPosition*i:0,this._endGap=void 0!==s.endPosition?s.endPosition*i:0,this._flipFirst=void 0===s.flipFirst||s.flipFirst,this._pattern=new Nt,this._pattern.init(s.positionArray,!1,!1),this._subPathLen=0,this._posCount=this._pattern.size(),this._isFirst=!0,this._prevPos=0}processPath(e){if(this._pattern.isEmpty())return null;let s;if(this.iteratePath){const l=this._pattern.nextValue()*this._subPathLen,c=this._beginGap+l;s=c-this._prevPos,this._prevPos=c}else{if(this._posCount=this._pattern.size(),this._isFirst=!0,this._prevPos=0,this._subPathLen=this._walker.calculatePathLength(e)-this._beginGap-this._endGap,this._subPathLen<0)return this.iteratePath=!1,null;if(!this._walker.init(e,this._pattern,!1))return null;this._pattern.reset();const l=this._pattern.nextValue()*this._subPathLen,c=this._beginGap+l;s=c-this._prevPos,this._prevPos=c,this.iteratePath=!0}const i=new dt;if(!this._walker.nextPointAndAngle(s,i,At.END))return this.iteratePath=!1,null;let o,r;return this.internalPlacement.setTranslate(i.pt[0]-this._offset*i.sa,i.pt[1]+this._offset*i.ca),this._angleToLine?(o=i.ca,r=i.sa):(o=1,r=0),this._isFirst&&this._flipFirst&&(o=-o,r=-r),this.internalPlacement.setRotateCS(o,r),this._isFirst=!1,this._posCount--,0===this._posCount&&(this.iteratePath=!1),this.internalPlacement}}var P=W(4619),m=W(97373);const v=512,G=24;let Y=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(s,i,h,o,r){return new j(s,i,h,o,r)}}return f.instance=null,f})();class j{constructor(e,s,i,h,o){if(this._xMin=0,this._xMax=0,this._yMin=0,this._yMax=0,this._currentX=0,this._currentY=0,this._accelerationMap=null,this._testInsidePolygon=!1,this._verticalSubdivision=!0,this._stepX=Math.abs(s.stepX??16)*i,this._stepY=Math.abs(s.stepY??16)*i,0!==this._stepX&&0!==this._stepY&&e&&function A(f){return void 0!==f.rings}(e)&&e.rings){if(this._gridType=s.gridType??L.bj.Fixed,this._gridType===L.bj.Random)this._randomLCG=new P.Z(1*(s.seed??13)),this._randomness=(s.randomness??100)/100,this._gridAngle=0,this._shiftOddRows=!1,this._cosAngle=1,this._sinAngle=0,this._offsetX=0,this._offsetY=0,this._buildRandomValues();else{if(this._randomness=0,this._gridAngle=s.gridAngle??0,this._shiftOddRows=s.shiftOddRows??!1,this._offsetX=(s.offsetX??0)*i,this._offsetY=(s.offsetY??0)*i,this._cosAngle=Math.cos(this._gridAngle/180*Math.PI),this._sinAngle=-Math.sin(this._gridAngle/180*Math.PI),this._stepX)if(this._offsetX<0)for(;this._offsetX<-.5*this._stepX;)this._offsetX+=this._stepX;else for(;this._offsetX>=.5*this._stepX;)this._offsetX-=this._stepX;if(this._stepY)if(this._offsetY<0)for(;this._offsetY<-.5*this._stepY;)this._offsetY+=this._stepY;else for(;this._offsetY>=.5*this._stepY;)this._offsetY-=this._stepY}if(this._graphicOriginX=0,this._graphicOriginY=0,null!=h){const[r,l,c]=h.split("/"),p=parseFloat(l),d=parseFloat(c);this._graphicOriginX=-d*v,this._graphicOriginY=p*v,this._testInsidePolygon=!0}this._internalPlacement=new m.u,this._calculateMinMax(e),this._geometry=e}}next(){return this._geometry?this._nextInside():null}_buildRandomValues(){if(!j._randValues){j._randValues=[];for(let e=0;e<G;e++)for(let s=0;s<G;s++)j._randValues.push(this._randomLCG.getFloat()),j._randValues.push(this._randomLCG.getFloat())}}_calculateMinMax(e){let s,i,h,o,r,l,c,p,d,y,z,T,X,J;this._xMin=0,this._xMax=0,this._yMin=0,this._yMax=0,c=p=X=z=Number.MAX_VALUE,d=y=J=T=-Number.MAX_VALUE;const lt=1!==this._cosAngle;let bt=0;for(const Mt of e.rings){const qt=Mt?Mt.length:0;for(let Vt=0;Vt<qt;Vt++)l=Mt[Vt][0],r=Mt[Vt][1],s=l-this._graphicOriginX-this._offsetX,i=r-this._graphicOriginY-this._offsetY,lt?(h=this._cosAngle*s-this._sinAngle*i,o=this._sinAngle*s+this._cosAngle*i):(h=s,o=i),c=Math.min(c,h),d=Math.max(d,h),p=Math.min(p,o),y=Math.max(y,o),z=Math.min(z,r),T=Math.max(T,r),X=Math.min(X,l),J=Math.max(J,l),bt++}z=z!==Number.MAX_VALUE?z:-v-this._stepY,T=T!==-Number.MAX_VALUE?T:this._stepY,X=X!==Number.MAX_VALUE?X:-this._stepX,J=J!==-Number.MAX_VALUE?J:v+this._stepX;const Ut=T-z,Dt=J-X;if(this._verticalSubdivision=Ut>=Dt,this._polygonMin=this._verticalSubdivision?z:X,this._testInsidePolygon){let Mt=0-this._graphicOriginX-this._offsetX-this._stepX,qt=v-this._graphicOriginX-this._offsetX+this._stepX,Vt=-v-this._graphicOriginY-this._offsetY-this._stepY,oe=0-this._graphicOriginY-this._offsetY+this._stepY;if(lt){const xe=[[Mt,Vt],[Mt,oe],[qt,Vt],[qt,oe]];Mt=Vt=Number.MAX_VALUE,qt=oe=-Number.MAX_VALUE;for(const de of xe){const Kt=this._cosAngle*de[0]-this._sinAngle*de[1],le=this._sinAngle*de[0]+this._cosAngle*de[1];Mt=Math.min(Mt,Kt),qt=Math.max(qt,Kt),Vt=Math.min(Vt,le),oe=Math.max(oe,le)}}c=c!==Number.MAX_VALUE?Math.max(c,Mt):Mt,p=p!==Number.MAX_VALUE?Math.max(p,Vt):Vt,d=d!==-Number.MAX_VALUE?Math.min(d,qt):qt,y=y!==-Number.MAX_VALUE?Math.min(y,oe):oe}this._xMin=Math.round(c/this._stepX),this._xMax=Math.round(d/this._stepX),this._yMin=Math.round(p/this._stepY),this._yMax=Math.round(y/this._stepY),this._currentX=this._xMax+1,this._currentY=this._yMin-1,this._testInsidePolygon&&bt>12&&(Ut>25||Dt>25)&&this._buildAccelerationMap(e,X,J,z,T)}_buildAccelerationMap(e,s,i,h,o){const{rings:r}=e,l=new Map,c=this._verticalSubdivision,p=c?o-h:i-s;let d=Math.ceil(p/10);if(d<=1)return;const y=Math.floor(p/d);let z,T,X,J,lt,bt,Ut,Dt,Mt,qt;d++,this._delta=y,c?(Dt=-v-this._stepY,Mt=this._stepY,qt=h):(Dt=-this._stepX,Mt=v+this._stepX,qt=s);for(let Vt=0;Vt<r.length;Vt++)if(z=r[Vt],!(z.length<2))for(let oe=1;oe<z.length;oe++){if(T=z[oe-1],X=z[oe],c){if(T[1]===X[1]||T[1]<Dt&&X[1]<Dt||T[1]>Mt&&X[1]>Mt)continue;J=Math.min(T[1],X[1]),lt=Math.max(T[1],X[1])}else{if(T[0]===X[0]||T[0]<Dt&&X[0]<Dt||T[0]>Mt&&X[0]>Mt)continue;J=Math.min(T[0],X[0]),lt=Math.max(T[0],X[0])}for(;J<lt;)bt=Math.floor((J-qt)/y),tt(bt,Vt,oe,l),J+=y;Ut=Math.floor((lt-qt)/y),Ut>bt&&tt(Ut,Vt,oe,l)}this._accelerationMap=l}_nextInside(){for(;;){if(this._currentX>this._xMax){if(this._currentY++,this._currentY>this._yMax)return null;this._currentX=this._xMin,this._shiftOddRows&&this._currentY%2&&this._currentX--}let e=this._currentX*this._stepX+this._offsetX;this._shiftOddRows&&this._currentY%2&&(e+=.5*this._stepX);const s=this._currentY*this._stepY+this._offsetY;let i,h;if(this._currentX++,this._gridType===L.bj.Random){const o=(this._currentX%G+G)%G,r=(this._currentY%G+G)%G;i=this._graphicOriginX+e+this._stepX*this._randomness*(.5-j._randValues[r*G+o])*2/3,h=this._graphicOriginY+s+this._stepY*this._randomness*(.5-j._randValues[r*G+o+1])*2/3}else i=this._graphicOriginX+this._cosAngle*e+this._sinAngle*s,h=this._graphicOriginY-this._sinAngle*e+this._cosAngle*s;if(!this._testInsidePolygon||this._isInsidePolygon(i,h,this._geometry))return this._internalPlacement.setTranslate(i,h),this._internalPlacement}}_isInsidePolygon(e,s,i){const{rings:h}=i;if((0,ct.Wi)(this._accelerationMap))return function rt(f,e,s){const{rings:i}=s;let h,o,r,l=0;for(const c of i){h=c.length;for(let p=1;p<h;++p)o=c[p-1],r=c[p],o[1]>e!=r[1]>e&&((r[0]-o[0])*(e-o[1])-(r[1]-o[1])*(f-o[0])>0?l++:l--)}return 0!==l}(e,s,i);const o=this._verticalSubdivision,l=Math.floor(((o?s:e)-this._polygonMin)/this._delta),c=this._accelerationMap.get(l);if(!c)return!1;let p,d,y,z,T,X=0;for(const J of c){T=J[0];const lt=h[T];if(z=J[1],p=lt[z-1],d=lt[z],o){if(p[1]>s==d[1]>s)continue;y=(d[0]-p[0])*(s-p[1])-(d[1]-p[1])*(e-p[0])}else{if(p[0]>e==d[0]>e)continue;y=(d[1]-p[1])*(e-p[0])-(d[0]-p[0])*(s-p[1])}y>0?X++:X--}return 0!==X}}function tt(f,e,s,i){let h=i.get(f);h||(h=[],i.set(f,h)),h.push([e,s])}let Lt=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(s,i,h,o,r){return new Et(s,i,h)}}return f.instance=null,f})();class Et extends _t.v1{constructor(e,s,i){super(e,!0,!0),this._curveHelper=new st,this._angleToLine=void 0===s.angleToLine||s.angleToLine,this._offset=void 0!==s.offset?s.offset*i:0,this._relativeTo=s.relativeTo,this._position=void 0!==s.startPointOffset?s.startPointOffset*i:0,this._epsilon=.001*i}processPath(e){const s=this._position;if(this._relativeTo===L.CS.SegmentMidpoint){for(this.iteratePath||(this._segmentCount=e.length,this._curSegment=1,this.iteratePath=!0);this._curSegment<this._segmentCount;){const h=this._curSegment;this._curSegment++;const o=e[h-1],r=e[h],l=this._curveHelper.calculateLength(o,r);if(l<this._epsilon)continue;const c=.5+this._position/l,[p,d]=this._curveHelper.getAngleCS(o,r,c),y=(0,_t.XV)(o,r,c);return this.internalPlacement.setTranslate(y[0]-this._offset*d,y[1]+this._offset*p),this._angleToLine&&this.internalPlacement.setRotateCS(p,d),this.internalPlacement}return this.iteratePath=!1,null}this._relativeTo===L.CS.LineEnd&&(0,_t.hh)(e);const i=this.onLine(e,s);return this._relativeTo===L.CS.LineEnd&&(0,_t.hh)(e),i}onLine(e,s){let i,h=!1;switch(this._relativeTo){case L.CS.LineMiddle:default:i=this._curveHelper.calculatePathLength(e)/2+s;break;case L.CS.LineBeginning:i=s;break;case L.CS.LineEnd:i=s,h=!0}const o=e.length;let r,l=0,c=e[0];for(let p=1;p<o;++p){r=c,c=e[p];const d=this._curveHelper.calculateLength(r,c);if(l+d>i){const y=(i-l)/d,[z,T]=this._curveHelper.getAngleCS(r,c,y),X=(0,_t.XV)(r,c,y),J=h?-this._offset:this._offset;return this.internalPlacement.setTranslate(X[0]-J*T,X[1]+J*z),this._angleToLine&&(h?this.internalPlacement.setRotateCS(-z,-T):this.internalPlacement.setRotateCS(z,T)),this.internalPlacement}l+=d}return null}}let vt=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(s,i,h,o,r){return new Ht(s,i,h)}}return f.instance=null,f})();class Ht extends _t.v1{constructor(e,s,i){super(e,!0,!0),this._curveHelper=new st,this._angleToLine=void 0===s.angleToLine||s.angleToLine,this._offset=void 0!==s.offset?s.offset*i:0,this._endPoints=void 0===s.placeOnEndPoints||s.placeOnEndPoints,this._controlPoints=void 0===s.placeOnControlPoints||s.placeOnControlPoints,this._regularVertices=void 0===s.placeOnRegularVertices||s.placeOnRegularVertices,this._tags=[],this._tagIterator=0}processPath(e){if(this.iteratePath||(this._preparePath(e),this.iteratePath=!0),this._tagIterator>=this._tags.length)return this._tags.length=0,this._tagIterator=0,this.iteratePath=!1,null;const s=this._tags[this._tagIterator];this._angleToLine&&this.internalPlacement.setRotate(s[2]);let i=s[0],h=s[1];if(0!==this._offset){const o=Math.cos(s[2]),r=Math.sin(s[2]);i-=this._offset*r,h+=this._offset*o}return this.internalPlacement.setTranslate(i,h),this._tagIterator++,this.internalPlacement}_preparePath(e){this._tags.length=0,this._tagIterator=0;const s=(0,_t.QK)(e),i=e.length-1;let h,o,r=0,l=0,c=0,p=0,d=0;for(;r<i;){r++,h=e[r-1],o=e[r];const y=(0,_t.zv)(h),z=(0,_t.zv)(o);(this._angleToLine||0!==this._offset)&&(p=this._curveHelper.getAngle(h,o,0)),1===r?s?(l=p,c=y):(this._endPoints||this._controlPoints&&1===y)&&this._tags.push([h[0],h[1],p]):1===y?this._controlPoints&&this._tags.push([h[0],h[1],jt(d,p)]):this._regularVertices&&this._tags.push([h[0],h[1],jt(d,p)]),(this._angleToLine||0!==this._offset)&&(d=this._curveHelper.getAngle(h,o,1)),r===i&&(s?1===z||1===c?this._controlPoints&&this._tags.push([o[0],o[1],jt(d,l)]):this._regularVertices&&this._tags.push([o[0],o[1],jt(d,l)]):(this._endPoints||this._controlPoints&&1===z)&&this._tags.push([o[0],o[1],d]))}this._tagIterator=0}}function jt(f,e){const s=Math.PI;for(;Math.abs(e-f)>s+2e-15;)e-f>s?e-=2*s:e+=2*s;return(f+e)/2}var Zt=W(8314),Wt=W(27105);class ne{constructor(e=Jt){this._data=[],this._compare=e}get size(){return this._data.length}enqueue(e){if(null==e)return;const{_data:s,_compare:i}=this;s.push(e);let h=s.length-1>>>0;const o=s[h];for(;h>0;){const r=h-1>>1,l=s[r];if(!(i(l,o)<=0))break;s[r]=o,s[h]=l,h=r}}dequeue(){const{_data:e,_compare:s}=this,i=e[0],h=e.pop();if(0===e.length)return i;e[0]=h;let o=0;const r=e.length,l=e[0];let c,p,d=null;for(;;){const y=2*o+1,z=2*o+2;if(d=null,y<r&&(c=e[y],s(c,l)>0&&(d=y)),z<r&&(p=e[z],(null===d&&s(p,l)<=0||null!==d&&s(p,c)<=0)&&(d=z)),null===d)break;e[o]=e[d],e[d]=l,o=d}return i}}const Jt=(f,e)=>f<e?-1:f>e?1:0;var Qt=W(25748),$t=W(11519);function he(f,e){const{rings:s}=e;let i=0;for(const h of s){const o=h.length;for(let r=1;r<o;++r){const l=h[r-1],c=h[r];l[1]>f[1]!=c[1]>f[1]&&((c[0]-l[0])*(f[1]-l[1])-(c[1]-l[1])*(f[0]-l[0])>0?i++:i--)}}return 0!==i}function ae(f,e,s){if(s&&he(f,e))return{coord:f,distance:0};let i=1/0,h=0,o=0;const r=[0,0],{rings:l}=e;for(const c of l)if(!(c.length<2))for(let p=0;p<c.length-1;p++){(0,Qt.Tx)(r,f,c,p);const d=pe(f,r);d<i&&(i=d,h=r[0],o=r[1])}return{coord:[h,o],distance:Math.sqrt(i)}}function me(f,e,s,i){const h=[e,0];let o=1/0,r=1/0,l=!1,c=!1;const p=[[e,i[1]-1],[e,i[3]+1]],d=[0,0],y=[0,0],z=[0,0],T=[[0,0],[0,0]],X=(0,k.Ue)(),{rings:J}=f;for(const lt of J)if(!(lt.length<2))for(let bt=1;bt<lt.length;bt++){if(T[0][0]=lt[bt-1][0],T[0][1]=lt[bt-1][1],T[1][0]=lt[bt][0],T[1][1]=lt[bt][1],null===Pe(X,T)||(y[0]=p[0][0],y[1]=p[0][1],z[0]=p[1][0],z[1]=p[1][1],0===se(X,y,z))||!(0,$t.UT)(p[0],p[1],T[0],T[1],d))continue;const Ut=d[1];o>r?Ut<o&&(o=Ut,l=!0):Ut<r&&(r=Ut,c=!0)}return l&&c?h[1]=(o+r)/2:h[0]=h[1]=NaN,h}function Pe(f,e){if(e.length<2)return null;f||(f=(0,k.Ue)());const[s,i]=e[0],[h,o]=e[1];return f[0]=Math.min(s,h),f[1]=Math.min(i,o),f[2]=Math.max(s,h),f[3]=Math.max(i,o),f}function se(f,e,s){let i=te(e,f),h=te(s,f);const o=f[0],r=f[1],l=f[2],c=f[3];if(i&h)return 0;if(!(i|h))return 4;const p=(i?1:0)|(h?2:0);do{const d=s[0]-e[0],y=s[1]-e[1];if(d>y)3&i?(1&i?(e[1]+=y*(o-e[0])/d,e[0]=o):(e[1]+=y*(l-e[0])/d,e[0]=l),i=te(e,f)):3&h?(1&h?(s[1]+=y*(o-s[0])/d,s[0]=o):(s[1]+=y*(l-s[0])/d,s[0]=l),h=te(s,f)):i?(4&i?(e[0]+=d*(r-e[1])/y,e[1]=r):(e[0]+=d*(c-e[1])/y,e[1]=c),i=te(e,f)):(4&h?(s[0]+=d*(r-s[1])/y,s[1]=r):(s[0]+=d*(c-s[1])/y,s[1]=c),h=te(s,f));else if(12&i?(4&i?(e[0]+=d*(r-e[1])/y,e[1]=r):(e[0]+=d*(c-e[1])/y,e[1]=c),i=te(e,f)):12&h?(4&h?(s[0]+=d*(r-s[1])/y,s[1]=r):(s[0]+=d*(c-s[1])/y,s[1]=c),h=te(s,f)):i?(1&i?(e[1]+=y*(o-e[0])/d,e[0]=o):(e[1]+=y*(l-e[0])/d,e[0]=l),i=te(e,f)):(1&h?(s[1]+=y*(o-s[0])/d,s[0]=o):(s[1]+=y*(l-s[0])/d,s[0]=l),h=te(s,f)),i&h)return 0}while(i|h);return p}function te(f,e){return(f[0]<e[0]?1:0)|(f[0]>e[2]?1:0)<<1|(f[1]<e[1]?1:0)<<2|(f[1]>e[3]?1:0)<<3}function ie(f,e,s){return f+(e-f)*s}function pe(f,e){return(f[0]-e[0])*(f[0]-e[0])+(f[1]-e[1])*(f[1]-e[1])}function ye(f,e){if(f<e)return-1;if(f>e)return 1;if(f===e)return 0;const s=isNaN(f),i=isNaN(e);return s<i?-1:s>i?1:0}class fe{constructor(e,s,i,h){this.x=e,this.y=s,this.cellSize=i,this.distancefromCellCenter=(0,Qt.ko)(e,s,h),this.maxDistanceToPolygon=this.distancefromCellCenter+this.cellSize*Math.SQRT2}}let ke=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(s,i,h,o,r){return new Ie(s,i,h)}}return f.instance=null,f})();class Ie{constructor(e,s,i){this._geometry=e,this._offsetX=void 0!==s.offsetX?s.offsetX*i:0,this._offsetY=void 0!==s.offsetY?s.offsetY*i:0,this._method=void 0!==s.method?s.method:L.Lh.OnPolygon,this._internalPlacement=new m.u}next(){const e=this._geometry;return this._geometry=null,e&&function we(f){return void 0!==f.rings}(e)?this._polygonCenter(e):null}_polygonCenter(e){let s=!1;switch(this._method){case L.Lh.CenterOfMass:{const i=(0,Wt.NA)(e);i&&(this._internalPlacement.setTranslate(i[0]+this._offsetX,i[1]+this._offsetY),s=!0)}break;case L.Lh.BoundingBoxCenter:{const i=(0,k.Ue)();(0,b.$P)(i,e),i&&(this._internalPlacement.setTranslate((i[2]+i[0])/2+this._offsetX,(i[3]+i[1])/2+this._offsetY),s=!0)}break;default:{let i;i=(0,Zt.Z)("polylabel-placement-enabled")?function ve(f){if(!f||!f.rings||0===f.rings.length)return null;const e=(0,b.lC)((0,k.Ue)(),f.rings[0]);if(!e)return null;const s=e[2]-e[0],i=e[3]-e[1];if(0===s||0===i)return[e[0]+s/2,e[1]+i/2];const h=Math.max(Math.min(s,i)/100,1),o=new ne((T,X)=>X.maxDistanceToPolygon-T.maxDistanceToPolygon),r=Math.min(s,i);let l=r/2,c=0,p=0;for(c=e[0];c<e[2];c+=r)for(p=e[1];p<e[3];p+=r)o.enqueue(new fe(c+l,p+l,l,f));const d=(0,Wt.a)(f.rings,!1);if(null===d)return null;let y,z=new fe(d[0],d[1],0,f);for(;o.size>0;)y=(0,ct.Wg)(o.dequeue()),y.distancefromCellCenter>z.distancefromCellCenter&&(z=y),y.maxDistanceToPolygon-z.distancefromCellCenter<=h||(l=y.cellSize/2,o.enqueue(new fe(y.x-l,y.y-l,l,f)),o.enqueue(new fe(y.x+l,y.y-l,l,f)),o.enqueue(new fe(y.x-l,y.y+l,l,f)),o.enqueue(new fe(y.x+l,y.y+l,l,f)));return[z.x,z.y]}(e):function ee(f){const{rings:e}=f;if(!e||0===e.length)return null;const s=(0,b.$P)((0,k.Ue)(),f);if(!s)return null;const i=4*(Math.abs(s[0])+Math.abs(s[2])+Math.abs(s[1])+Math.abs(s[3])+1)*222045e-19;let h=0,o=0;for(let Kt=0;Kt<e.length;Kt++){const le=(0,Qt.Sm)(e[Kt]);le>o&&(o=le,h=Kt)}if(Math.abs(o)<=2*i*i){const Kt=(0,b.lC)((0,k.Ue)(),e[h]);return[(Kt[0]+Kt[2])/2,(Kt[1]+Kt[3])/2]}const r=(0,Wt.DS)(e[h],!1,(0,k.Ue)());if(null===r)return null;if(1===e.length&&e[0].length<4)return r;const l=[[NaN,NaN],[NaN,NaN],[NaN,NaN],[NaN,NaN]],c=[NaN,NaN,NaN,NaN],p=[NaN,NaN,NaN,NaN];let d=!1,y=ae(r,f,!0);0===y.distance&&(d=!0,l[0][0]=r[0],l[0][1]=r[1],y=ae(r,f,!1)),c[0]=y.distance,p[0]=0;const z=[NaN,NaN];let T=!1,X=.25,J=-1;const lt=(0,b.lC)((0,k.Ue)(),e[h]);let bt=NaN;do{if(bt=NaN,l[1]=me(f,ie(lt[0],lt[2],X),0,s),isNaN(l[1][0])||isNaN(l[1][1])||(y=ae(l[1],f,!1),bt=y.distance),!isNaN(bt)&&bt>i&&he(l[1],f))T=!0,c[1]=bt,p[1]=pe(l[1],r);else if(!isNaN(bt)&&bt>J&&(J=bt,z[0]=l[1][0],z[1]=l[1][1]),X-=.01,X<.1){if(!(J>=0))break;T=!0,c[1]=J,l[1][0]=z[0],l[1][1]=z[1],p[1]=pe(l[1],r)}}while(!T);T=!1,X=.5,J=-1;let Ut=.01,Dt=1;do{if(bt=NaN,l[2]=me(f,ie(lt[0],lt[2],X),0,s),isNaN(l[2][0])||isNaN(l[2][1])||(y=ae(l[2],f,!1),bt=y.distance),!isNaN(bt)&&bt>i&&he(l[2],f))T=!0,c[2]=bt,p[2]=pe(l[2],r);else if(!isNaN(bt)&&bt>J)J=bt,z[0]=l[2][0],z[1]=l[2][1];else if(bt>J&&(J=bt,z[0]=l[2][0],z[1]=l[2][1]),X=.5+Ut*Dt,Ut+=.01,Dt*=-1,X<.3||X>.7){if(!(J>=0))break;T=!0,c[2]=J,l[2][0]=z[0],l[2][1]=z[1],p[2]=pe(l[2],r)}}while(!T);T=!1,X=.75,J=-1;do{if(bt=NaN,l[3]=me(f,ie(lt[0],lt[2],X),0,s),isNaN(l[3][0])||isNaN(l[3][1])||(y=ae(l[3],f,!1),bt=y.distance),!isNaN(bt)&&bt>i&&he(l[3],f))T=!0,c[3]=bt,p[3]=pe(l[3],r);else if(bt>J&&(J=bt,z[0]=l[3][0],z[1]=l[3][1]),X+=.01,X>.9){if(!(J>=0))break;T=!0,c[3]=J,l[3][0]=z[0],l[3][1]=z[1],p[3]=pe(l[3],r)}}while(!T);const Mt=[0,1,2,3],qt=d?0:1;let Vt;for(let Kt=qt;Kt<4;Kt++)for(let le=qt;le<3;le++){const be=p[le],Se=p[le+1];ye(be,Se)>0&&(Vt=Mt[le],Mt[le]=Mt[le+1],Mt[le+1]=Vt,p[le]=Se,p[le+1]=be)}let oe=qt,xe=0,de=0;for(let Kt=qt;Kt<4;Kt++){switch(Kt){case 0:de=2*c[Mt[Kt]];break;case 1:de=1.66666666*c[Mt[Kt]];break;case 2:de=1.33333333*c[Mt[Kt]];break;case 3:de=c[Mt[Kt]]}de>xe&&(xe=de,oe=Mt[Kt])}return l[oe]}(e),null!==i&&(this._internalPlacement.setTranslate(i[0]+this._offsetX,i[1]+this._offsetY),s=!0)}}return s?this._internalPlacement:null}}function Ee(f){if(!f)return null;switch(f.type){case"CIMGeometricEffectAddControlPoints":return ft.local();case"CIMGeometricEffectArrow":return wt.local();case"CIMGeometricEffectBuffer":return Ct.local();case"CIMGeometricEffectControlMeasureLine":return kt.local();case"CIMGeometricEffectCut":return R.local();case"CIMGeometricEffectDashes":return Q.local();case"CIMGeometricEffectDonut":return K.local();case"CIMGeometricEffectJog":return pt.local();case"CIMGeometricEffectMove":return It.local();case"CIMGeometricEffectOffset":return Xt.local();case"CIMGeometricEffectReverse":return a.local();case"CIMGeometricEffectRotate":return I.local();case"CIMGeometricEffectScale":return x.local();case"CIMGeometricEffectWave":return gt.local()}return null}function Le(f){if(!f)return null;switch(f.type){case"CIMMarkerPlacementAlongLineSameSize":return u.local();case"CIMMarkerPlacementAtExtremities":return S.local();case"CIMMarkerPlacementAtRatioPositions":return C.local();case"CIMMarkerPlacementInsidePolygon":return Y.local();case"CIMMarkerPlacementOnLine":return Lt.local();case"CIMMarkerPlacementOnVertices":return vt.local();case"CIMMarkerPlacementPolygonCenter":return ke.local()}return null}},97373:(ue,Yt,W)=>{W.d(Yt,{u:()=>Ot});class Ot{constructor(){this.setIdentity()}getAngle(){return(null==this.rz||0===this.rz&&1!==this.rzCos&&0!==this.rzSin)&&(this.rz=Math.atan2(this.rzSin,this.rzCos)),this.rz}setIdentity(){this.tx=0,this.ty=0,this.tz=0,this.s=1,this.rx=0,this.ry=0,this.rz=0,this.rzCos=1,this.rzSin=0}setTranslate(ft,Ft){this.tx=ft,this.ty=Ft}setTranslateZ(ft){this.tz=ft}setRotateCS(ft,Ft){this.rz=void 0,this.rzCos=ft,this.rzSin=Ft}setRotate(ft){this.rz=ft,this.rzCos=void 0,this.rzSin=void 0}setRotateY(ft){this.ry=ft}setScale(ft){this.s=ft}setMeasure(ft){this.m=ft}}},26933:(ue,Yt,W)=>{W.d(Yt,{cD:()=>Q,uQ:()=>mt,Tu:()=>H,zA:()=>dt,x1:()=>nt,et:()=>Tt,g:()=>pt});var Ot=W(986),it=W(17002),_t=W(58817),ft=W(63290),Ft=W(62208),L=W(27899),ut=W(23841),$=W(65401),st=W(32442),ht=W(27105),Z=W(91179),Pt=W(29214);class wt{applyColorSubstituition(a,_){if(!_)return a;this._rasterizationCanvas||(this._rasterizationCanvas=document.createElement("canvas"));const{width:k,height:b}=a,I=this._rasterizationCanvas,F=I.getContext("2d");a!==I&&(I.width=k,I.height=b,F.drawImage(a,0,0,k,b));const x=F.getImageData(0,0,k,b).data;if(_)for(const gt of _)if(gt&&gt.oldColor&&4===gt.oldColor.length&&gt.newColor&&4===gt.newColor.length){const[O,u,g,S]=gt.oldColor,[w,C,n,P]=gt.newColor;if(O===w&&u===C&&g===n&&S===P)continue;for(let m=0;m<x.length;m+=4)O===x[m]&&u===x[m+1]&&g===x[m+2]&&S===x[m+3]&&(x[m]=w,x[m+1]=C,x[m+2]=n,x[m+3]=P)}const q=new ImageData(x,k,b);return F.putImageData(q,0,0),I}tintImageData(a,_){if(!_||_.length<4)return a;this._rasterizationCanvas||(this._rasterizationCanvas=document.createElement("canvas"));const{width:k,height:b}=a,I=this._rasterizationCanvas,F=I.getContext("2d");a!==I&&(I.width=k,I.height=b,F.drawImage(a,0,0,k,b));const x=F.getImageData(0,0,k,b),q=new Uint8Array(x.data),gt=[_[0]/255,_[1]/255,_[2]/255,_[3]/255];for(let u=0;u<q.length;u+=4)q[u+0]*=gt[0],q[u+1]*=gt[1],q[u+2]*=gt[2],q[u+3]*=gt[3];const O=new ImageData(new Uint8ClampedArray(q.buffer),k,b);return F.putImageData(O,0,0),I}}var N=W(95727),D=W(97373),ct=W(7547);function E(ot){const a=ot.getFrame(0);if(a instanceof HTMLImageElement||a instanceof HTMLCanvasElement)return a;const _=document.createElement("canvas");_.width=ot.width,_.height=ot.height;const k=_.getContext("2d");return a instanceof ImageData?k.putImageData(a,0,0):k.drawImage(a,0,0),_}var St=W(31375),Ct=W(68937),xt=W(80991),kt=W(40028),zt=W(39351),R=W(25797);const et=Math.PI/180,Nt=ft.Z.getLogger("esri.symbols.cim.CIMSymbolDrawHelper");class dt{constructor(a){this._t=a}static createIdentity(){return new dt([1,0,0,0,1,0])}clone(){return new dt(this._t.slice())}transform(a){const _=this._t;return[_[0]*a[0]+_[1]*a[1]+_[2],_[3]*a[0]+_[4]*a[1]+_[5]]}static createScale(a,_){return new dt([a,0,0,0,_,0])}scale(a,_){const k=this._t;return k[0]*=a,k[1]*=a,k[2]*=a,k[3]*=_,k[4]*=_,k[5]*=_,this}scaleRatio(){return Math.sqrt(this._t[0]*this._t[0]+this._t[1]*this._t[1])}static createTranslate(a,_){return new dt([0,0,a,0,0,_])}translate(a,_){const k=this._t;return k[2]+=a,k[5]+=_,this}static createRotate(a){const _=Math.cos(a),k=Math.sin(a);return new dt([_,-k,0,k,_,0])}rotate(a){return dt.multiply(this,dt.createRotate(a),this)}angle(){const a=this._t[0],_=this._t[3],k=Math.sqrt(a*a+_*_);return[a/k,_/k]}static multiply(a,_,k){const b=a._t,I=_._t,x=b[1]*I[0]+b[4]*I[1],q=b[2]*I[0]+b[5]*I[1]+I[2],gt=b[0]*I[3]+b[3]*I[4],O=b[1]*I[3]+b[4]*I[4],u=b[2]*I[3]+b[5]*I[4]+I[5],g=k._t;return g[0]=b[0]*I[0]+b[3]*I[1],g[1]=x,g[2]=q,g[3]=gt,g[4]=O,g[5]=u,k}invert(){const a=this._t;let _=a[0]*a[4]-a[1]*a[3];return 0===_?new dt([0,0,0,0,0,0]):(_=1/_,new dt([a[4]*_,-a[1]*_,(a[1]*a[5]-a[2]*a[4])*_,-a[3]*_,a[0]*_,(a[2]*a[3]-a[0]*a[5])*_]))}}class At{constructor(a,_){this._resourceManager=a,this._transfos=[],this._sizeTransfos=[],this._geomUnitsPerPoint=1,this._placementPool=new L.Z(D.u,void 0,void 0,100),this._earlyReturn=!1,this._mapRotation=0,this._transfos.push(_||dt.createIdentity()),this._sizeTransfos.push(_?_.scaleRatio():1)}setTransform(a,_){this._transfos=[a||dt.createIdentity()],this._sizeTransfos=[_||(a?a.scaleRatio():1)]}setGeomUnitsPerPoint(a){this._geomUnitsPerPoint=a}transformPt(a){return this._transfos[this._transfos.length-1].transform(a)}transformSize(a){return a*this._sizeTransfos[this._sizeTransfos.length-1]}reverseTransformPt(a){return this._transfos[this._transfos.length-1].invert().transform(a)}reverseTransformSize(a){return a/this._sizeTransfos[this._sizeTransfos.length-1]}getTransformAngle(){return this._transfos[this._transfos.length-1].angle()}geomUnitsPerPoint(){return this.isEmbedded()?1:this._geomUnitsPerPoint}isEmbedded(){return this._transfos.length>1}back(){return this._transfos[this._transfos.length-1]}push(a,_){const k=_?a.scaleRatio():1;dt.multiply(a,this.back(),a),this._transfos.push(a),this._sizeTransfos.push(this._sizeTransfos[this._sizeTransfos.length-1]*k)}pop(){this._transfos.splice(-1,1),this._sizeTransfos.splice(-1,1)}drawSymbol(a,_,k){if(a)switch(a.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":this.drawMultiLayerSymbol(a,_);break;case"CIMTextSymbol":this.drawTextSymbol(a,_,k)}}drawMultiLayerSymbol(a,_){if(!a||!_)return;const k=a.symbolLayers;if(!k)return;const b=a.effects;if(b&&b.length>0){const I=this.executeEffects(b,_);if(I){let F=I.next();for(;F;)this.drawSymbolLayers(k,F),F=I.next()}}else this.drawSymbolLayers(k,_)}executeEffects(a,_){const k=this._resourceManager.geometryEngine;let b=new Pt.MU(_);for(const I of a){const F=(0,N.h)(I);F&&(b=F.execute(b,I,this.geomUnitsPerPoint(),null,k))}return b}drawSymbolLayers(a,_){let k=a.length;for(;k--;){const b=a[k];if(!b||!1===b.enable)continue;const I=b.effects;if(I&&I.length>0){const F=this.executeEffects(I,_);if(F){let x=null;for(;(x=F.next())&&(this.drawSymbolLayer(b,x),!this._earlyReturn););}}else this.drawSymbolLayer(b,_);if(this._earlyReturn)return}}drawSymbolLayer(a,_){switch(a.type){case"CIMSolidFill":this.drawSolidFill(_,a.color);break;case"CIMHatchFill":this.drawHatchFill(_,a);break;case"CIMPictureFill":this.drawPictureFill(_,a);break;case"CIMGradientFill":this.drawGradientFill(_,a);break;case"CIMSolidStroke":this.drawSolidStroke(_,a.color,a.width,a.capStyle,a.joinStyle,a.miterLimit);break;case"CIMPictureStroke":this.drawPictureStroke(_,a);break;case"CIMGradientStroke":this.drawGradientStroke(_,a);break;case"CIMCharacterMarker":case"CIMPictureMarker":case"CIMVectorMarker":this.drawMarkerLayer(a,_)}}drawHatchFill(a,_){const k=this._buildHatchPolyline(_,a,this.geomUnitsPerPoint());k&&(this.pushClipPath(a),this.drawMultiLayerSymbol(_.lineSymbol,k),this.popClipPath())}drawPictureFill(a,_){}drawGradientFill(a,_){}drawPictureStroke(a,_){}drawGradientStroke(a,_){}drawMarkerLayer(a,_){const k=a.markerPlacement;if(k){const b=(0,N.W)(k);if(b){const I="CIMMarkerPlacementInsidePolygon"===k.type||"CIMMarkerPlacementPolygonCenter"===k.type&&k.clipAtBoundary;I&&this.pushClipPath(_);const F=b.execute(_,k,this.geomUnitsPerPoint(),null,this._resourceManager.geometryEngine);if(F){let x=null;for(;(x=F.next())&&(this.drawMarker(a,x),!this._earlyReturn););}I&&this.popClipPath()}}else{const b=this._placementPool.acquire();if((0,Z.wp)(_))b.tx=_.x,b.ty=_.y,this.drawMarker(a,b);else if((0,Z.oU)(_)){const I=(0,ht.tO)(_);I&&([b.tx,b.ty]=I,this.drawMarker(a,b))}else for(const I of _.points)if(b.tx=I[0],b.ty=I[1],this.drawMarker(a,b),this._earlyReturn)break;this._placementPool.release(b)}}drawMarker(a,_){switch(a.type){case"CIMCharacterMarker":case"CIMPictureMarker":this.drawPictureMarker(a,_);break;case"CIMVectorMarker":this.drawVectorMarker(a,_)}}drawPictureMarker(a,_){if(!a)return;const k=this._resourceManager.getResource(a.url),b=a.size??10;if((0,Ft.Wi)(k)||b<=0)return;const I=k.width,F=k.height;if(!I||!F)return;const x=I/F,q=a.scaleX??1,gt=dt.createIdentity(),O=a.anchorPoint;if(O){let n=O.x,P=O.y;"Absolute"!==a.anchorPointUnits&&(n*=b*x*q,P*=b),gt.translate(-n,-P)}let u=a.rotation??0;a.rotateClockwise&&(u=-u),this._mapRotation&&(u+=this._mapRotation),u&&gt.rotate(u*et);let g=a.offsetX??0,S=a.offsetY??0;if(g||S){if(this._mapRotation){const n=et*this._mapRotation,P=Math.cos(n),m=Math.sin(n),v=g*m+S*P;g=g*P-S*m,S=v}gt.translate(g,S)}const w=this.geomUnitsPerPoint();1!==w&&gt.scale(w,w);const C=_.getAngle();C&&gt.rotate(C),gt.translate(_.tx,_.ty),this.push(gt,!1),this.drawImage(a,b),this.pop()}drawVectorMarker(a,_){if(!a)return;const k=a.markerGraphics;if(!k)return;const b=a.size??10,I=a.frame,F=I?I.ymax-I.ymin:0,x=b&&F?b/F:1,q=dt.createIdentity();I&&q.translate(.5*-(I.xmax+I.xmin),.5*-(I.ymax+I.ymin));const gt=a.anchorPoint;if(gt){let C=gt.x,n=gt.y;"Absolute"!==a.anchorPointUnits?I&&(C*=I.xmax-I.xmin,n*=I.ymax-I.ymin):(C/=x,n/=x),q.translate(-C,-n)}1!==x&&q.scale(x,x);let O=a.rotation??0;a.rotateClockwise&&(O=-O),this._mapRotation&&(O+=this._mapRotation),O&&q.rotate(O*et);let u=a.offsetX??0,g=a.offsetY??0;if(u||g){if(this._mapRotation){const C=et*this._mapRotation,n=Math.cos(C),P=Math.sin(C),m=u*P+g*n;u=u*n-g*P,g=m}q.translate(u,g)}const S=this.geomUnitsPerPoint();1!==S&&q.scale(S,S);const w=_.getAngle();w&&q.rotate(w),q.translate(_.tx,_.ty),this.push(q,a.scaleSymbolsProportionally);for(const C of k)if(C&&C.symbol&&C.geometry||Nt.error("Invalid marker graphic",C),this.drawSymbol(C.symbol,C.geometry,C.textString),this._earlyReturn)break;this.pop()}drawTextSymbol(a,_,k){if(!a||!(0,Z.wp)(_)||(a.height??10)<=0)return;const b=dt.createIdentity();let I=a.angle??0;I=-I,I&&b.rotate(I*et);const F=a.offsetX??0,x=a.offsetY??0;(F||x)&&b.translate(F,x);const q=this.geomUnitsPerPoint();1!==q&&b.scale(q,q),b.translate(_.x,_.y),this.push(b,!1),this.drawText(a,k),this.pop()}_buildHatchPolyline(a,_,k){let b=(void 0!==a.separation?a.separation:4)*k,I=void 0!==a.rotation?a.rotation:0;if(0===b)return null;b<0&&(b=-b);let F=0;const x=.5*b;for(;F>x;)F-=b;for(;F<-x;)F+=b;const q=(0,$.Ue)();(0,st.$P)(q,_),q[0]-=x,q[1]-=x,q[2]+=x,q[3]+=x;const gt=[[q[0],q[1]],[q[0],q[3]],[q[2],q[3]],[q[2],q[1]]];for(;I>180;)I-=180;for(;I<0;)I+=180;const O=Math.cos(I*et),u=Math.sin(I*et),g=-b*u,S=b*O;let w,C,n,P;F=(void 0!==a.offsetX?a.offsetX*k:0)*u-(void 0!==a.offsetY?a.offsetY*k:0)*O,w=n=Number.MAX_VALUE,C=P=-Number.MAX_VALUE;for(const A of gt){const Y=A[0],j=A[1],rt=O*Y+u*j,tt=-u*Y+O*j;w=Math.min(w,rt),n=Math.min(n,tt),C=Math.max(C,rt),P=Math.max(P,tt)}n=Math.floor(n/b)*b;let m=O*w-u*n-g*F/b,v=u*w+O*n-S*F/b,M=O*C-u*n-g*F/b,U=u*C+O*n-S*F/b;const V=1+Math.round((P-n)/b),G=[];for(let A=0;A<V;A++)m+=g,v+=S,M+=g,U+=S,G.push([[m,v],[M,U]]);return{paths:G}}}class mt extends At{constructor(a,_){super(a,_),this.reset()}reset(){this._xmin=this._ymin=1/0,this._xmax=this._ymax=-1/0,this._clipCount=0}envelope(){return new St.Z(this._xmin,this._ymin,this._xmax-this._xmin,this._ymax-this._ymin)}bounds(){return(0,$.al)(this._xmin,this._ymin,this._xmax,this._ymax)}drawSolidFill(a){if(a&&!(this._clipCount>0))if((0,Z.oU)(a))this._processPath(a.rings,0);else if((0,Z.l9)(a))this._processPath(a.paths,0);else if((0,Z.YX)(a)){const _=K(a);_&&this._processPath(_.rings,0)}else console.error("drawSolidFill Unexpected geometry type!")}drawSolidStroke(a,_,k){if(!a||this._clipCount>0)return;const b=.5*this.transformSize(k??0);if((0,Z.oU)(a))this._processPath(a.rings,b);else if((0,Z.l9)(a))this._processPath(a.paths,b);else if((0,Z.YX)(a)){const I=K(a);I&&this._processPath(I.rings,b)}else console.error("drawSolidStroke unexpected geometry type!")}drawMarkerLayer(a,_){(0,Z.oU)(_)&&a.markerPlacement&&("CIMMarkerPlacementInsidePolygon"===a.markerPlacement.type||"CIMMarkerPlacementPolygonCenter"===a.markerPlacement.type&&a.markerPlacement.clipAtBoundary)?this._processPath(_.rings,0):super.drawMarkerLayer(a,_)}drawHatchFill(a,_){this.drawSolidFill(a)}drawPictureFill(a,_){this.drawSolidFill(a)}drawGradientFill(a,_){this.drawSolidFill(a)}drawPictureStroke(a,_){this.drawSolidStroke(a,null,_.width)}drawGradientStroke(a,_){this.drawSolidStroke(a,null,_.width)}pushClipPath(a){this.drawSolidFill(a),this._clipCount++}popClipPath(){this._clipCount--}drawImage(a,_){const{url:k}=a,b=a.scaleX??1;let I=b*_,F=_;const x=this._resourceManager.getResource(k);!_&&(0,Ft.pC)(x)&&(I=b*x.width,F=x.height),this._merge(this.transformPt([-I/2,-F/2]),0),this._merge(this.transformPt([-I/2,F/2]),0),this._merge(this.transformPt([I/2,-F/2]),0),this._merge(this.transformPt([I/2,F/2]),0)}drawText(a,_){if(!_||0===_.length)return;this._textRasterizer||(this._textRasterizer=new Ct.Z);const k=It(a),[b,I]=this._textRasterizer.computeTextSize(_,k);let F=0;switch(a.horizontalAlignment){case"Left":F=b/2;break;case"Right":F=-b/2}let x=0;switch(a.verticalAlignment){case"Bottom":x=I/2;break;case"Top":x=-I/2;break;case"Baseline":x=I/6}this._merge(this.transformPt([-b/2+F,-I/2+x]),0),this._merge(this.transformPt([-b/2+F,I/2+x]),0),this._merge(this.transformPt([b/2+F,-I/2+x]),0),this._merge(this.transformPt([b/2+F,I/2+x]),0)}_processPath(a,_){if(a)for(const k of a){const b=k?k.length:0;if(b>1){this._merge(this.transformPt(k[0]),_);for(let I=1;I<b;I++)this._merge(this.transformPt(k[I]),_)}}}_merge(a,_){a[0]-_<this._xmin&&(this._xmin=a[0]-_),a[0]+_>this._xmax&&(this._xmax=a[0]+_),a[1]-_<this._ymin&&(this._ymin=a[1]-_),a[1]+_>this._ymax&&(this._ymax=a[1]+_)}}class H extends At{constructor(){super(...arguments),this._searchPoint=[0,0],this._searchDistPoint=0,this._textInfo=null}hitTest(a,_,k,b,I,F){const x=F*(0,ut.F2)(1);return this.setTransform(),this.setGeomUnitsPerPoint(x),this._searchPoint=[(a[0]+a[2])/2,(a[1]+a[3])/2],this._searchDistPoint=(a[2]-a[0])/2/x,this._textInfo=b,this._mapRotation=_&&("CIMPointSymbol"===_.type&&"Map"!==_.angleAlignment||"CIMTextSymbol"===_.type)?I:0,this._earlyReturn=!1,this.drawSymbol(_,k),this._earlyReturn}drawSolidFill(a,_){this._hitTestFill(a)}drawHatchFill(a,_){this._hitTestFill(a)}drawPictureFill(a,_){this._hitTestFill(a)}drawGradientFill(a,_){this._hitTestFill(a)}drawSolidStroke(a,_,k,b,I,F){this._hitTestStroke(a,k)}drawPictureStroke(a,_){this._hitTestStroke(a,_.width)}drawGradientStroke(a,_){this._hitTestStroke(a,_.width)}drawMarkerLayer(a,_){a.markerPlacement&&("CIMMarkerPlacementInsidePolygon"===a.markerPlacement.type||"CIMMarkerPlacementPolygonCenter"===a.markerPlacement.type&&a.markerPlacement.clipAtBoundary)?this._hitTestFill(_):super.drawMarkerLayer(a,_)}pushClipPath(a){}popClipPath(){}drawImage(a,_){const{url:k}=a,b=a.scaleX??1,I=this._resourceManager.getResource(k);if((0,Ft.Wi)(I)||0===I.height||0===_)return;const F=_*this.geomUnitsPerPoint(),x=F*b*(I.width/I.height),q=this.reverseTransformPt(this._searchPoint),gt=this._searchDistPoint;Math.abs(q[0])<x/2+gt&&Math.abs(q[1])<F/2+gt&&(this._earlyReturn=!0)}drawText(a,_){const k=this._textInfo;if(!k)return;const b=k.get(a);if(!b)return;const{text:I,mosaicItem:F}=b;if(!F?.glyphMosaicItems?.length)return;const x=a.height??10,{lineGapType:q,lineGap:gt}=a,O=q?Tt(q,gt??0,x):0,u=(0,Ot.E)(I)[1],S="CIMBackgroundCallout"===a.callout?.type,w=(0,R.Nr)(F.glyphMosaicItems,u,{scale:x/zt.Ex,angle:0,xOffset:0,yOffset:0,hAlign:nt(a.horizontalAlignment),vAlign:pt(a.verticalAlignment),maxLineWidth:512,lineHeight:zt.xm*Math.max(.25,Math.min(O||1,4)),decoration:a.font.decoration||"none",isCIM:!0,hasBackground:S}),C=this.reverseTransformPt(this._searchPoint),n=C[0],P=C[1];for(const m of w.glyphs)if(n>m.xTopLeft&&n<m.xBottomRight&&P>-m.yBottomRight&&P<-m.yTopLeft){this._earlyReturn=!0;break}}_hitTestFill(a){let _=null;if((0,Z.YX)(a))_=[[[a.xmin,a.ymin],[a.xmin,a.ymax],[a.xmax,a.ymax],[a.xmax,a.ymin],[a.xmin,a.ymin]]];else if((0,Z.oU)(a))_=a.rings;else{if(!(0,Z.l9)(a))return;_=a.paths}const k=this.reverseTransformPt(this._searchPoint);if(this._pointInPolygon(k,_)&&(this._earlyReturn=!0),!this._earlyReturn){const b=this.reverseTransformSize(this._searchDistPoint)*this.geomUnitsPerPoint();this._nearLine(k,_,b)&&(this._earlyReturn=!0)}}_hitTestStroke(a,_){let k=null;if((0,Z.YX)(a))k=[[[a.xmin,a.ymin],[a.xmin,a.ymax],[a.xmax,a.ymax],[a.xmax,a.ymin],[a.xmin,a.ymin]]];else if((0,Z.oU)(a))k=a.rings;else{if(!(0,Z.l9)(a))return;k=a.paths}const b=this.reverseTransformPt(this._searchPoint),I=(_??0)*this.geomUnitsPerPoint(),F=this.reverseTransformSize(this._searchDistPoint)*this.geomUnitsPerPoint();this._nearLine(b,k,I/2+F)&&(this._earlyReturn=!0)}_pointInPolygon(a,_){let k=0;for(const b of _){const I=b.length;for(let F=1;F<I;F++){const x=b[F-1],q=b[F];x[1]>a[1]!=q[1]>a[1]&&((q[0]-x[0])*(a[1]-x[1])-(q[1]-x[1])*(a[0]-x[0])>0?k++:k--)}}return 0!==k}_nearLine(a,_,k){for(const b of _){const I=b.length;for(let F=1;F<I;F++){const x=b[F-1],q=b[F];let gt=(q[0]-x[0])*(q[0]-x[0])+(q[1]-x[1])*(q[1]-x[1]);if(0!==gt&&(gt=Math.sqrt(gt),Math.abs(((q[0]-x[0])*(a[1]-x[1])-(q[1]-x[1])*(a[0]-x[0]))/gt)<k)){const u=((q[0]-x[0])*(a[0]-x[0])+(q[1]-x[1])*(a[1]-x[1]))/gt;if(u>-k&&u<gt+k)return!0}}}return!1}}class Q extends At{constructor(a,_,k,b){super(_,k),this._applyAdditionalRenderProps=b,this._colorSubstitutionHelper=new wt,this._ctx=a}drawSolidFill(a,_){if(!a)return;if((0,Z.oU)(a))this._buildPath(a.rings,!0);else if((0,Z.l9)(a))this._buildPath(a.paths,!0);else if((0,Z.YX)(a))this._buildPath(K(a).rings,!0);else{if(!(0,Z.aW)(a))return;console.log("CanvasDrawHelper.drawSolidFill - No implementation!")}const k=this._ctx;k.fillStyle="string"==typeof _?_:"rgba("+Math.round(_[0])+","+Math.round(_[1])+","+Math.round(_[2])+","+(_[3]??255)/255+")",k.fill("evenodd")}drawSolidStroke(a,_,k,b,I,F){if(!a||!_||0===k)return;if((0,Z.oU)(a))this._buildPath(a.rings,!0);else if((0,Z.l9)(a))this._buildPath(a.paths,!1);else{if(!(0,Z.YX)(a))return void console.log("CanvasDrawHelper.drawSolidStroke isn't implemented!");this._buildPath(K(a).rings,!0)}const x=this._ctx;x.strokeStyle="string"==typeof _?_:"rgba("+Math.round(_[0])+","+Math.round(_[1])+","+Math.round(_[2])+","+(_[3]??255)/255+")",x.lineWidth=Math.max(this.transformSize(k),.5),this._setCapStyle(b),this._setJoinStyle(I),x.miterLimit=F,x.stroke()}pushClipPath(a){if(this._ctx.save(),(0,Z.oU)(a))this._buildPath(a.rings,!0);else if((0,Z.l9)(a))this._buildPath(a.paths,!0);else{if(!(0,Z.YX)(a))return;this._buildPath(K(a).rings,!0)}this._ctx.clip("evenodd")}popClipPath(){this._ctx.restore()}drawImage(a,_){const{colorSubstitutions:k,url:b,tintColor:I}=a,F=a.scaleX??1,x=this._resourceManager.getResource(b);if((0,Ft.Wi)(x))return;let q=_*(x.width/x.height),gt=_;_||(q=x.width,gt=x.height);const O=(0,xt.TB)(b)||"src"in x&&(0,xt.TB)(x.src);let u="getFrame"in x?E(x):x;k&&(u=this._colorSubstitutionHelper.applyColorSubstituition(u,k)),this._applyAdditionalRenderProps&&!O&&I&&(u=this._colorSubstitutionHelper.tintImageData(u,I));const g=this.transformPt([0,0]),[S,w]=this.getTransformAngle(),C=this.transformSize(1),n=this._ctx;n.save(),n.setTransform({m11:F*C*S,m12:F*C*w,m21:-C*w,m22:C*S,m41:g[0],m42:g[1]}),n.drawImage(u,-q/2,-gt/2,q,gt),n.restore()}drawText(a,_){if(!_||0===_.length)return;this._textRasterizer||(this._textRasterizer=new Ct.Z);const k=It(a);k.size*=this.transformSize((0,ut.Wz)(1));const b=this._textRasterizer.rasterizeText(_,k);if(!b)return;const{size:I,anchorX:F,anchorY:x,canvas:q}=b,gt=I[0]*(F+.5),O=I[1]*(x-.5),u=this._ctx,g=this.transformPt([0,0]),[S,w]=this.getTransformAngle();u.save(),u.setTransform({m11:1*S,m12:1*w,m21:-1*w,m22:1*S,m41:g[0]-1*gt,m42:g[1]+1*O}),u.drawImage(q,0,0),u.restore()}drawPictureFill(a,_){if(!a)return;let{colorSubstitutions:k,height:b,offsetX:I,offsetY:F,rotation:x,scaleX:q,tintColor:gt,url:O}=_;const u=this._resourceManager.getResource(O);if((0,Ft.Wi)(u))return;if((0,Z.oU)(a))this._buildPath(a.rings,!0);else if((0,Z.l9)(a))this._buildPath(a.paths,!0);else if((0,Z.YX)(a))this._buildPath(K(a).rings,!0);else{if(!(0,Z.aW)(a))return;console.log("CanvasDrawHelper.drawPictureFill - No implementation!")}const g=this._ctx,S=(0,xt.TB)(O)||"src"in u&&(0,xt.TB)(u.src);let w,C="getFrame"in u?E(u):u;if(k&&(C=this._colorSubstitutionHelper.applyColorSubstituition(C,k)),this._applyAdditionalRenderProps){S||gt&&(C=this._colorSubstitutionHelper.tintImageData(C,gt)),w=g.createPattern(C,"repeat");const n=this.transformSize(1);x||(x=0),I?I*=n:I=0,F?F*=n:F=0,b&&(b*=n);const P=b?b/u.height:1,m=q&&b?q*b/u.width:1;if(0!==x||1!==P||1!==m||0!==I||0!==F){const v=new DOMMatrix;v.rotateSelf(0,0,-x).translateSelf(I,F).scaleSelf(m,P,1),w.setTransform(v)}}else w=g.createPattern(C,"repeat");g.save(),g.fillStyle=w,g.fill("evenodd"),g.restore()}drawPictureStroke(a,_){if(!a)return;let{colorSubstitutions:k,capStyle:b,joinStyle:I,miterLimit:F,tintColor:x,url:q,width:gt}=_;const O=this._resourceManager.getResource(q);if((0,Ft.Wi)(O))return;let u;if((0,Z.oU)(a))u=a.rings;else if((0,Z.l9)(a))u=a.paths;else{if(!(0,Z.YX)(a))return(0,Z.aW)(a)?void console.log("CanvasDrawHelper.drawPictureStroke - No implementation!"):void 0;u=K(a).rings}gt||(gt=O.width);const g=(0,xt.TB)(q)||"src"in O&&(0,xt.TB)(O.src);let S="getFrame"in O?E(O):O;k&&(S=this._colorSubstitutionHelper.applyColorSubstituition(S,k)),this._applyAdditionalRenderProps&&(g||x&&(S=this._colorSubstitutionHelper.tintImageData(S,x)));const w=Math.max(this.transformSize((0,ut.F2)(gt)),.5),C=w/S.width,n=this._ctx,P=n.createPattern(S,"repeat-y");let m,v;n.save(),this._setCapStyle(b),this._setJoinStyle(I),void 0!==F&&(n.miterLimit=F),n.lineWidth=w;for(let M of u)if(M=(0,_t.d9)(M),Xt(M),M&&!(M.length<=1)){m=this.transformPt(M[0]);for(let U=1;U<M.length;U++){v=this.transformPt(M[U]);const V=B(m,v),G=new DOMMatrix;G.translateSelf(0,m[1]-w/2).scaleSelf(C,C,1).rotateSelf(0,0,90-V),P.setTransform(G),n.strokeStyle=P,n.beginPath(),n.moveTo(m[0],m[1]),n.lineTo(v[0],v[1]),n.stroke(),m=v}}n.restore()}_buildPath(a,_){const k=this._ctx;if(k.beginPath(),a)for(const b of a){const I=b?b.length:0;if(I>1){let F=this.transformPt(b[0]);k.moveTo(F[0],F[1]);for(let x=1;x<I;x++)F=this.transformPt(b[x]),k.lineTo(F[0],F[1]);_&&k.closePath()}}}_setCapStyle(a){switch(a){case ct.kP.Butt:this._ctx.lineCap="butt";break;case ct.kP.Round:this._ctx.lineCap="round";break;case ct.kP.Square:this._ctx.lineCap="square"}}_setJoinStyle(a){switch(a){case ct.r4.Bevel:this._ctx.lineJoin="bevel";break;case ct.r4.Round:this._ctx.lineJoin="round";break;case ct.r4.Miter:this._ctx.lineJoin="miter"}}}function B(ot,a){return 180/Math.PI*Math.atan2(a[1]-ot[1],a[0]-ot[0])}const K=ot=>ot?{spatialReference:ot.spatialReference,rings:[[[ot.xmin,ot.ymin],[ot.xmin,ot.ymax],[ot.xmax,ot.ymax],[ot.xmax,ot.ymin],[ot.xmin,ot.ymin]]]}:null,nt=ot=>{switch(ot){case"Left":return kt.M7.Left;case"Right":return kt.M7.Right;case"Center":return kt.M7.Center;case"Justify":return Nt.warnOnce("Horizontal alignment 'justify' is not implemented. Falling back to 'center'."),kt.M7.Center}},pt=ot=>{switch(ot){case"Top":return kt.TR.Top;case"Center":return kt.TR.Center;case"Bottom":return kt.TR.Bottom;case"Baseline":return kt.TR.Baseline}},Tt=(ot,a,_)=>{switch(ot){case"ExtraLeading":return 1+a/_;case"Multiple":return a;case"Exact":return a/_}};function It(ot,a=1){const _=(0,xt.BX)(ot),k=(0,xt.wi)(ot.fontStyleName),b=(0,it.BN)(ot.fontFamilyName),{weight:I,style:F}=k,x=a*(ot.height||5),q=(0,xt.X_)(ot.horizontalAlignment),gt=(0,xt.FG)(ot.verticalAlignment),O=(0,xt.W7)(ot),u=(0,xt.$Z)(ot.haloSymbol),g=u?a*(0|ot.haloSize):0;return{color:O,size:x,horizontalAlignment:q,verticalAlignment:gt,font:{family:b,style:(0,xt.pJ)(F),weight:(0,xt.On)(I),decoration:_},halo:{size:g||0,color:u,style:F},pixelRatio:1,premultiplyColors:!0}}function Xt(ot){let a,_,k,b,I,F=ot[0],x=1;for(;x<ot.length;)a=ot[x][0]-F[0],_=ot[x][1]-F[1],b=0!==a?_/a:Math.PI/2,void 0!==k&&b-k<=1e-4?(ot.splice(x-1,1),F=I):(I=F,F=ot[x],x++),k=b}},35909:(ue,Yt,W)=>{W.d(Yt,{B$:()=>nt,E0:()=>pt,U1:()=>b,bP:()=>K,rW:()=>At});var Ot=W(15861),it=W(91558),_t=W(986),ft=W(58817),Ft=W(63290),L=W(62208),ut=W(4619),$=W(23841),st=W(65401),ht=W(32442),Z=W(46679),Pt=W(97373),wt=W(26933),N=W(7547),D=W(80991),ct=W(39236),E=W(86575),St=W(39351),Ct=W(25797);const xt=Math.PI,kt=xt/2,yt=96/72,Nt=Math.PI/180,dt=Ft.Z.getLogger("esri.symbols.cim.CIMSymbolHelper");function At(O){if(!O||!O.type)return null;let u;switch(O.type){case"cim":return O.data;case"web-style":return O;case"simple-marker":{const g=nt.fromSimpleMarker(O);if(!g)return null;u=g;break}case"picture-marker":u=nt.fromPictureMarker(O);break;case"simple-line":u=nt.fromSimpleLineSymbol(O);break;case"simple-fill":u=nt.fromSimpleFillSymbol(O);break;case"picture-fill":u=nt.fromPictureFillSymbol(O);break;case"text":u=nt.fromTextSymbol(O)}return{type:"CIMSymbolReference",symbol:u}}function mt(O,u,g){switch(u.type){case"CIMSymbolReference":return mt(O,u.symbol,g);case"CIMPointSymbol":null==g&&(g={x:0,y:0}),O.drawSymbol(u,g);break;case"CIMLineSymbol":null==g&&(g={paths:[[[0,0],[10,0]]]}),O.drawSymbol(u,g);break;case"CIMPolygonSymbol":null==g&&(g={rings:[[[0,0],[0,10],[10,10],[10,0],[0,0]]]}),O.drawSymbol(u,g);break;case"CIMTextSymbol":O.drawSymbol(u,{x:0,y:0});break;case"CIMVectorMarker":{const S=new Pt.u;O.drawMarker(u,S);break}}return O.envelope()}function H(O){if(!O)return 0;switch(O.type){case"CIMMarkerPlacementAlongLineSameSize":case"CIMMarkerPlacementAlongLineRandomSize":case"CIMMarkerPlacementAtExtremities":case"CIMMarkerPlacementAtMeasuredUnits":case"CIMMarkerPlacementAtRatioPositions":case"CIMMarkerPlacementOnLine":case"CIMMarkerPlacementOnVertices":return Math.abs(O.offset);default:return 0}}function Q(O){if(!O)return 0;switch(O.type){case"CIMGeometricEffectArrow":return Math.abs(.5*O.width);case"CIMGeometricEffectBuffer":return Math.abs(O.size);case"CIMGeometricEffectExtension":case"CIMGeometricEffectRadial":return Math.abs(O.length);case"CIMGeometricEffectJog":return Math.abs(.5*O.length);case"CIMGeometricEffectMove":return Math.max(Math.abs((0,D.NA)(O.offsetX)),Math.abs((0,D.NA)(O.offsetY)));case"CIMGeometricEffectOffset":case"CIMGeometricEffectOffsetTangent":return Math.abs(O.offset);case"CIMGeometricEffectRegularPolygon":return Math.abs(O.radius);case"CIMGeometricEffectRotate":case"CIMGeometricEffectScale":default:return 0;case"CIMGeometricEffectTaperedPolygon":return.5*Math.max(Math.abs(O.fromWidth),Math.abs(O.toWidth));case"CIMGeometricEffectWave":return Math.abs(O.amplitude)}}function B(O){if(!O)return 0;let u=0;for(const g of O)u+=Q(g);return u}class K{getSymbolInflateSize(u,g,S,w,C){return u||(u=[0,0,0,0]),g?this._getInflateSize(u,g,S,w,C):u}static safeSize(u){const g=Math.max(Math.abs(u[0]),Math.abs(u[2])),S=Math.max(Math.abs(u[1]),Math.abs(u[3]));return Math.sqrt(g*g+S*S)}_vectorMarkerBounds(u,g,S,w){let C=!0;const n=(0,st.Ue)();if(g&&g.markerGraphics)for(const P of g.markerGraphics){const m=[0,0,0,0];P.geometry&&((0,ht.$P)(n,P.geometry),m[0]=0,m[1]=0,m[2]=0,m[3]=0,this.getSymbolInflateSize(m,P.symbol,S,0,w),n[0]+=m[0],n[1]+=m[1],n[2]+=m[2],n[3]+=m[3],C?(u[0]=n[0],u[1]=n[1],u[2]=n[2],u[3]=n[3],C=!1):(u[0]=Math.min(u[0],n[0]),u[1]=Math.min(u[1],n[1]),u[2]=Math.max(u[2],n[2]),u[3]=Math.max(u[3],n[3])))}return u}_getInflateSize(u,g,S,w,C){if(function I(O){return void 0!==O.symbolLayers}(g)){const n=this._getLayersInflateSize(u,g.symbolLayers,S,w,C),P=B(g.effects);return P>0&&(n[0]-=P,n[1]-=P,n[2]+=P,n[3]+=P),n}return this._getTextInflatedSize(u,g,C)}_getLayersInflateSize(u,g,S,w,C){let n=!0;if(!g)return u;for(const P of g){if(!P)continue;let m=[0,0,0,0];switch(P.type){case"CIMSolidFill":case"CIMPictureFill":case"CIMHatchFill":case"CIMGradientFill":break;case"CIMSolidStroke":case"CIMPictureStroke":case"CIMGradientStroke":{let U=P.width;null!=U&&(U/=P.capStyle===N.kP.Square||P.joinStyle===N.r4.Miter?1.4142135623730951:2,m[0]=-U,m[1]=-U,m[2]=U,m[3]=U);break}case"CIMCharacterMarker":case"CIMVectorMarker":case"CIMPictureMarker":{const M=P;if("CIMVectorMarker"===P.type){const Y=P;if(m=this._vectorMarkerBounds(m,Y,S,C),Y.frame){const j=(Y.frame.xmin+Y.frame.xmax)/2,rt=(Y.frame.ymin+Y.frame.ymax)/2;if(m[0]-=j,m[1]-=rt,m[2]-=j,m[3]-=rt,null!=Y.size){const tt=Y.size/(Y.frame.ymax-Y.frame.ymin);m[0]*=tt,m[1]*=tt,m[2]*=tt,m[3]*=tt}}}else if("CIMPictureMarker"===P.type){const Y=P,j=S.getResource(Y.url);let rt=1;if((0,L.pC)(j)&&j.height&&(rt=j.width/j.height),null!=M.size){const tt=M.size/2,at=M.size*rt*Y.scaleX/2;m=[-at,-tt,at,tt]}}else if(null!=M.size){const Y=M.size/2;m=[-Y,-Y,Y,Y]}if(M.anchorPoint){let Y,j;"Absolute"===M.anchorPointUnits?(Y=M.anchorPoint.x,j=M.anchorPoint.y):(Y=M.anchorPoint.x*(m[2]-m[0]),j=M.anchorPoint.y*(m[3]-m[1])),m[0]-=Y,m[1]-=j,m[2]-=Y,m[3]-=j}let U=(0,D.NA)(M.rotation);if(M.rotateClockwise&&(U=-U),w&&(U-=w),U){const Y=Nt*U,j=Math.cos(Y),rt=Math.sin(Y),tt=(0,st.Ue)([E.B1,E.B1,-E.B1,-E.B1]);(0,st.Ho)(tt,[m[0]*j-m[1]*rt,m[0]*rt+m[1]*j]),(0,st.Ho)(tt,[m[0]*j-m[3]*rt,m[0]*rt+m[3]*j]),(0,st.Ho)(tt,[m[2]*j-m[1]*rt,m[2]*rt+m[1]*j]),(0,st.Ho)(tt,[m[2]*j-m[3]*rt,m[2]*rt+m[3]*j]),m=tt}let V=(0,D.NA)(M.offsetX),G=(0,D.NA)(M.offsetY);if(w){const Y=Nt*w,j=Math.cos(Y),rt=Math.sin(Y),tt=V*rt+G*j;V=V*j-G*rt,G=tt}m[0]+=V,m[1]+=G,m[2]+=V,m[3]+=G;const A=H(M.markerPlacement);A>0&&(m[0]-=A,m[1]-=A,m[2]+=A,m[3]+=A);break}}const v=B(P.effects);v>0&&(m[0]-=v,m[1]-=v,m[2]+=v,m[3]+=v),n?(u[0]=m[0],u[1]=m[1],u[2]=m[2],u[3]=m[3],n=!1):(u[0]=Math.min(u[0],m[0]),u[1]=Math.min(u[1],m[1]),u[2]=Math.max(u[2],m[2]),u[3]=Math.max(u[3],m[3]))}return u}_getTextInflatedSize(u,g,S){const w=g.height??10;if(u[0]=-w/2,u[1]=-w/2,u[2]=w/2,u[3]=w/2,!S)return u;const C=S.get(g);if(!C)return u;const{text:n,mosaicItem:P}=C;if(!P?.glyphMosaicItems?.length)return u;const{lineGapType:m,lineGap:v}=g,M=m?(0,wt.et)(m,v??0,w):0,U=(0,_t.E)(n)[1],G="CIMBackgroundCallout"===g.callout?.type,A=(0,Ct.Nr)(P.glyphMosaicItems,U,{scale:w/St.Ex,angle:(0,D.NA)(g.angle),xOffset:(0,D.NA)(g.offsetX),yOffset:(0,D.NA)(g.offsetY),hAlign:(0,wt.x1)(g.horizontalAlignment),vAlign:(0,wt.g)(g.verticalAlignment),maxLineWidth:512,lineHeight:St.xm*Math.max(.25,Math.min(M||1,4)),decoration:g.font.decoration||"none",isCIM:!0,hasBackground:G}).boundsT;return u[0]=A.x-A.halfWidth,u[1]=-A.y-A.halfHeight,u[2]=A.x+A.halfWidth,u[3]=-A.y+A.halfHeight,u}}class nt{static getEnvelope(u,g,S){if(!u)return null;const w=new wt.uQ(S);if(Array.isArray(u)){let C;for(const n of u)C?C.union(mt(w,n,g)):C=mt(w,n,g);return C}return mt(w,u,g)}static getTextureAnchor(u,g){const S=this.getEnvelope(u,null,g);if(!S)return[0,0,0];const P=S.height*yt+2;return[-(S.x+.5*S.width)*yt/(S.width*yt+2),-(S.y+.5*S.height)*yt/P,P]}static rasterize(u,g,S,w,C=!0){const n=S||this.getEnvelope(g,null,w);if(!n)return[null,0,0,0,0];const P=(n.x+.5*n.width)*yt,m=(n.y+.5*n.height)*yt;u.width=n.width*yt,u.height=n.height*yt,S||(u.width+=2,u.height+=2);const v=u.getContext("2d"),M=wt.zA.createScale(yt,-yt);M.translate(.5*u.width-P,.5*u.height+m);const U=new wt.cD(v,w,M);switch(g.type){case"CIMPointSymbol":U.drawSymbol(g,{type:"point",x:0,y:0});break;case"CIMVectorMarker":{const A=new Pt.u;U.drawMarker(g,A);break}}const V=v.getImageData(0,0,u.width,u.height),G=new Uint8Array(V.data);if(C){let A;for(let Y=0;Y<G.length;Y+=4)A=G[Y+3]/255,G[Y]=G[Y]*A,G[Y+1]=G[Y+1]*A,G[Y+2]=G[Y+2]*A}return[G,u.width,u.height,-P/u.width,-m/u.height]}static fromTextSymbol(u){const{angle:g,color:S,font:w,haloColor:C,haloSize:n,horizontalAlignment:P,kerning:m,text:v,verticalAlignment:M,xoffset:U,yoffset:V,backgroundColor:G,borderLineColor:A,borderLineSize:Y}=u;let j,rt,tt,at,Lt,Et;w&&(j=w.family,rt=w.style,tt=w.weight,at=w.size,Lt=w.decoration);let vt=!1;return v&&(vt=(0,_t.E)(v)[1]),(G||Y)&&(Et={type:"CIMBackgroundCallout",margin:null,backgroundSymbol:{type:"CIMPolygonSymbol",symbolLayers:[{type:"CIMSolidFill",color:ot(G)},{type:"CIMSolidStroke",color:ot(A),width:Y}]},accentBarSymbol:null,gap:null,leaderLineSymbol:null,lineStyle:null}),{type:"CIMPointSymbol",symbolLayers:[{type:"CIMVectorMarker",enable:!0,anchorPointUnits:"Relative",dominantSizeAxis3D:"Y",size:10,billboardMode3D:"FaceNearPlane",frame:{xmin:-5,ymin:-5,xmax:5,ymax:5},markerGraphics:[{type:"CIMMarkerGraphic",geometry:{x:0,y:0},symbol:{type:"CIMTextSymbol",angle:g,blockProgression:N.zV.BTT,depth3D:1,extrapolateBaselines:!0,fontEffects:N.eZ.Normal,fontEncoding:N.DD.Unicode,fontFamilyName:j||"Arial",fontStyleName:a(rt,tt),fontType:N.Ky.Unspecified,haloSize:n,height:at,hinting:N.Dd.Default,horizontalAlignment:Gt(P??"center"),kerning:m,letterWidth:100,ligatures:!0,lineGapType:"Multiple",offsetX:(0,D.NA)(U),offsetY:(0,D.NA)(V),strikethrough:"line-through"===Lt,underline:"underline"===Lt,symbol:{type:"CIMPolygonSymbol",symbolLayers:[{type:"CIMSolidFill",enable:!0,color:ot(S)}]},haloSymbol:{type:"CIMPolygonSymbol",symbolLayers:[{type:"CIMSolidFill",enable:!0,color:ot(C)}]},shadowColor:[0,0,0,255],shadowOffsetX:1,shadowOffsetY:1,textCase:"Normal",textDirection:vt?N.UX.RTL:N.UX.LTR,verticalAlignment:Xt(M??"baseline"),verticalGlyphOrientation:N.RS.Right,wordSpacing:100,billboardMode3D:N.UR.FaceNearPlane,callout:Et},textString:v}],scaleSymbolsProportionally:!0,respectFrame:!0}],scaleX:1,angleAlignment:"Display"}}static fromPictureFillSymbol(u){const{height:g,outline:S,width:w,xoffset:C,xscale:n,yoffset:P,yscale:m}=u,v=[],M={type:"CIMPolygonSymbol",symbolLayers:v};if(S){const{cap:Y,join:j,miterLimit:rt,width:tt}=S;v.push({type:"CIMSolidStroke",color:ot(S.color),capStyle:Tt(Y),joinStyle:It(j),miterLimit:rt,width:tt})}let U=u.url;"esriPFS"===u.type&&u.imageData&&(U=u.imageData);const V="angle"in u?u.angle??0:0;return v.push({type:"CIMPictureFill",invertBackfaceTexture:!1,scaleX:1,textureFilter:N.Qb.Picture,tintColor:null,url:U,height:(g??0)*(m||1),width:(w??0)*(n||1),offsetX:(0,D.NA)(C),offsetY:(0,D.NA)(P),rotation:(0,D.NA)(-V),colorSubstitutions:null}),M}static fromSimpleFillSymbol(u){const{color:g,style:S,outline:w}=u,C=[],n={type:"CIMPolygonSymbol",symbolLayers:C};let P=null;if(w){const{cap:m,join:v,style:M}=w;"solid"!==M&&"none"!==M&&"esriSLSSolid"!==M&&"esriSLSNull"!==M&&(P=[{type:"CIMGeometricEffectDashes",dashTemplate:b(M,m),lineDashEnding:"NoConstraint",scaleDash:!0,offsetAlongLine:null}]),C.push({type:"CIMSolidStroke",color:ot(w.color),capStyle:Tt(m),joinStyle:It(v),miterLimit:w.miterLimit,width:w.width,effects:P})}if(S&&"solid"!==S&&"none"!==S&&"esriSFSSolid"!==S&&"esriSFSNull"!==S){const m={type:"CIMLineSymbol",symbolLayers:[{type:"CIMSolidStroke",color:ot(g),capStyle:N.kP.Butt,joinStyle:N.r4.Miter,width:.75}]};let v=0;const M=(0,$.Wz)(x(S)?8:10);switch(S){case"vertical":case"esriSFSVertical":v=90;break;case"forward-diagonal":case"esriSFSForwardDiagonal":case"diagonal-cross":case"esriSFSDiagonalCross":v=-45;break;case"backward-diagonal":case"esriSFSBackwardDiagonal":v=45;break;case"cross":case"esriSFSCross":v=0}C.push({type:"CIMHatchFill",lineSymbol:m,offsetX:0,offsetY:0,rotation:v,separation:M}),"cross"===S||"esriSFSCross"===S?C.push({type:"CIMHatchFill",lineSymbol:(0,ft.d9)(m),offsetX:0,offsetY:0,rotation:90,separation:M}):"diagonal-cross"!==S&&"esriSFSDiagonalCross"!==S||C.push({type:"CIMHatchFill",lineSymbol:(0,ft.d9)(m),offsetX:0,offsetY:0,rotation:45,separation:M})}else!S||"solid"!==S&&"esriSFSSolid"!==S||C.push({type:"CIMSolidFill",enable:!0,color:ot(g)});return n}static fromSimpleLineSymbol(u){const{cap:g,color:S,join:w,marker:C,miterLimit:n,style:P,width:m}=u;let v=null;"solid"!==P&&"none"!==P&&"esriSLSSolid"!==P&&"esriSLSNull"!==P&&(v=[{type:"CIMGeometricEffectDashes",dashTemplate:b(P,g),lineDashEnding:"NoConstraint",scaleDash:!0,offsetAlongLine:null}]);const M=[];if(C){let U;switch(C.placement){case"begin-end":U=N.Tx.Both;break;case"begin":U=N.Tx.JustBegin;break;case"end":U=N.Tx.JustEnd;break;default:U=N.Tx.None}const V=nt.fromSimpleMarker(C,m,S).symbolLayers[0];V.markerPlacement={type:"CIMMarkerPlacementAtExtremities",angleToLine:!0,offset:0,extremityPlacement:U,offsetAlongLine:0},M.push(V)}return"none"!==P&&"esriSLSNull"!==P&&M.push({type:"CIMSolidStroke",color:ot(S),capStyle:Tt(g),joinStyle:It(w),miterLimit:n,width:m,effects:v}),{type:"CIMLineSymbol",symbolLayers:M}}static fromPictureMarker(u){const{angle:g,height:S,width:w,xoffset:C,yoffset:n}=u;let P=u.url;return"esriPMS"===u.type&&u.imageData&&(P=u.imageData),{type:"CIMPointSymbol",symbolLayers:[{type:"CIMPictureMarker",invertBackfaceTexture:!1,scaleX:1,textureFilter:N.Qb.Picture,tintColor:null,url:P,size:S,width:w,offsetX:(0,D.NA)(C),offsetY:(0,D.NA)(n),rotation:(0,D.NA)(-g)}]}}static fromSimpleMarker(u,g,S){const{style:w}=u,C=u.color??S;if("path"===w){const v=[];if("outline"in u&&u.outline){const V=u.outline;v.push({type:"CIMSolidStroke",enable:!0,width:(0,$.F2)(Math.round((0,$.Wz)(V.width))),color:ot(V.color)})}v.push({type:"CIMSolidFill",enable:!0,color:ot(C),path:u.path});const[M,U]=F("square");return{type:"CIMPointSymbol",symbolLayers:[{type:"CIMVectorMarker",enable:!0,rotation:(0,D.NA)(-u.angle),size:(0,D.NA)(u.size||6),offsetX:(0,D.NA)(u.xoffset),offsetY:(0,D.NA)(u.yoffset),frame:M,markerGraphics:[{type:"CIMMarkerGraphic",geometry:U,symbol:{type:"CIMPolygonSymbol",symbolLayers:v}}]}]}}const[n,P]=F(w);let m;if(P&&n){const v=[];if("outline"in u&&u.outline){const U=u.outline;v.push({type:"CIMSolidStroke",enable:!0,width:null!=U.width&&U.width>.667?(0,$.F2)(Math.round((0,$.Wz)(U.width))):U.width,color:ot(U.color)})}else!g||"line-marker"!==u.type||"cross"!==u.style&&"x"!==u.style||v.push({type:"CIMSolidStroke",enable:!0,width:g,color:ot(C)});v.push({type:"CIMSolidFill",enable:!0,color:ot(C)});const M={type:"CIMPolygonSymbol",symbolLayers:v};m={type:"CIMPointSymbol",symbolLayers:[{type:"CIMVectorMarker",enable:!0,rotation:(0,D.NA)(-u.angle),size:(0,D.NA)(u.size||6*g),offsetX:(0,D.NA)(u.xoffset),offsetY:(0,D.NA)(u.yoffset),frame:n,markerGraphics:[{type:"CIMMarkerGraphic",geometry:P,symbol:M}]}]}}return m}static fromCIMHatchFill(u,g){const S=g*(u.separation??4),w=S/2,C=(0,ft.d9)(u.lineSymbol);C.symbolLayers?.forEach(m=>{switch(m.type){case"CIMSolidStroke":null!=m.width&&(m.width*=g),m.effects?.forEach(v=>{"CIMGeometricEffectDashes"===v.type&&(v.dashTemplate=v.dashTemplate.map(M=>M*g))});break;case"CIMVectorMarker":{null!=m.size&&(m.size*=g);const v=m.markerPlacement;null!=v&&"placementTemplate"in v&&(v.placementTemplate=v.placementTemplate.map(M=>M*g));break}}});let n=this._getLineSymbolPeriod(C)||4;for(;n<4;)n*=2;const P=n/2;return{type:"CIMVectorMarker",frame:{xmin:-P,xmax:P,ymin:-w,ymax:w},markerGraphics:[{type:"CIMMarkerGraphic",geometry:{paths:[[[-P,0],[P,0]]]},symbol:C}],size:S}}static fetchResources(u,g,S){if(u&&g)switch(u.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":{const w=u.symbolLayers;if(!w)return;for(const C of w)switch(gt(C,g,S),C.type){case"CIMPictureFill":case"CIMHatchFill":case"CIMGradientFill":case"CIMPictureStroke":case"CIMGradientStroke":case"CIMCharacterMarker":case"CIMPictureMarker":"url"in C&&C.url&&S.push(g.fetchResource(C.url,null));break;case"CIMVectorMarker":{const n=C.markerGraphics;if(!n)continue;for(const P of n)if(P){const m=P.symbol;m&&nt.fetchResources(m,g,S)}}}}}}static _getLineSymbolPeriod(u){if(u){const g=this._getEffectsRepeat(u.effects);if(g)return g;if(u.symbolLayers)for(const S of u.symbolLayers)if(S){const w=this._getEffectsRepeat(S.effects);if(w)return w;switch(S.type){case"CIMCharacterMarker":case"CIMPictureMarker":case"CIMVectorMarker":case"CIMObjectMarker3D":case"CIMglTFMarker3D":{const C=this._getPlacementRepeat(S.markerPlacement);if(C)return C}}}}return 0}static _getEffectsRepeat(u){if(u)for(const g of u)if(g)switch(g.type){case"CIMGeometricEffectDashes":{const S=g.dashTemplate;if(S&&S.length){let w=0;for(const C of S)w+=C;return 1&S.length&&(w*=2),w}break}case"CIMGeometricEffectWave":return g.period;default:dt.error(`unsupported geometric effect type ${g.type}`)}return 0}static _getPlacementRepeat(u){if(u)switch(u.type){case"CIMMarkerPlacementAlongLineSameSize":case"CIMMarkerPlacementAlongLineRandomSize":case"CIMMarkerPlacementAlongLineVariableSize":{const g=u.placementTemplate;if(g&&g.length){let S=0;for(const w of g)S+=+w;return 1&g.length&&(S*=2),S}break}}return 0}static fromCIMInsidePolygon(u){const g=u.markerPlacement,S={...u};S.markerPlacement=null,S.anchorPoint=null;const w=Math.abs(g.stepX),C=Math.abs(g.stepY),n=(g.randomness??100)/100;let P,m,v,M;if("Random"===g.gridType){const U=(0,$.Wz)(St.C1),V=Math.max(Math.floor(U/w),1),G=Math.max(Math.floor(U/C),1);P=V*w/2,m=G*C/2,v=2*m;const A=new ut.Z(g.seed),Y=n*w/1.5,j=n*C/1.5;M=[];for(let rt=0;rt<V;rt++)for(let tt=0;tt<G;tt++){const at=rt*w-P+Y*(.5-A.getFloat()),Lt=tt*C-m+j*(.5-A.getFloat());M.push({x:at,y:Lt}),0===rt&&M.push({x:at+2*P,y:Lt}),0===tt&&M.push({x:at,y:Lt+2*m})}}else!0===g.shiftOddRows?(P=w/2,m=C,v=2*C,M=[{x:-P,y:0},{x:P,y:0},{x:0,y:m},{x:0,y:-m}]):(P=w/2,m=C/2,v=C,M=[{x:-w,y:0},{x:0,y:-C},{x:-w,y:-C},{x:0,y:0},{x:w,y:0},{x:0,y:C},{x:w,y:C},{x:-w,y:C},{x:w,y:-C}]);return{type:"CIMVectorMarker",frame:{xmin:-P,xmax:P,ymin:-m,ymax:m},markerGraphics:M.map(U=>({type:"CIMMarkerGraphic",geometry:U,symbol:{type:"CIMPointSymbol",symbolLayers:[S]}})),size:v}}static getSize(u){if(u)switch(u.type){case"CIMTextSymbol":return u.height;case"CIMPointSymbol":{let g=0;if(u.symbolLayers)for(const S of u.symbolLayers)if(S)switch(S.type){case"CIMCharacterMarker":case"CIMPictureMarker":case"CIMVectorMarker":case"CIMObjectMarker3D":case"CIMglTFMarker3D":{const w=S.size;null!=w&&w>g&&(g=w);break}}return g}case"CIMLineSymbol":case"CIMPolygonSymbol":{let g=0;if(u.symbolLayers)for(const S of u.symbolLayers)if(S)switch(S.type){case"CIMSolidStroke":case"CIMPictureStroke":case"CIMGradientStroke":{const w=S.width;null!=w&&w>g&&(g=w);break}case"CIMCharacterMarker":case"CIMPictureMarker":case"CIMVectorMarker":case"CIMObjectMarker3D":case"CIMglTFMarker3D":if(S.markerPlacement&&(0,D.gJ)(S.markerPlacement)){const w=S.size;null!=w&&w>g&&(g=w)}}return g}}}static getMarkerScaleRatio(u){return u&&"CIMVectorMarker"===u.type&&!1!==u.scaleSymbolsProportionally&&u.frame&&null!=u.size?u.size/(u.frame.ymax-u.frame.ymin):1}}class pt{static findApplicableOverrides(u,g,S){if(u&&g){if(u.primitiveName){let w=!1;for(const C of S)if(C.primitiveName===u.primitiveName){w=!0;break}if(!w)for(const C of g)C.primitiveName===u.primitiveName&&S.push(C)}switch(u.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":if(u.effects)for(const w of u.effects)pt.findApplicableOverrides(w,g,S);if(u.symbolLayers)for(const w of u.symbolLayers)pt.findApplicableOverrides(w,g,S);break;case"CIMTextSymbol":break;case"CIMSolidStroke":case"CIMPictureStroke":case"CIMGradientStroke":case"CIMSolidFill":case"CIMPictureFill":case"CIMHatchFill":case"CIMGradientFill":case"CIMVectorMarker":case"CIMCharacterMarker":case"CIMPictureMarker":if(u.effects)for(const w of u.effects)pt.findApplicableOverrides(w,g,S);if(u.markerPlacement&&pt.findApplicableOverrides(u.markerPlacement,g,S),"CIMVectorMarker"===u.type){if(u.markerGraphics)for(const w of u.markerGraphics)pt.findApplicableOverrides(w,g,S),pt.findApplicableOverrides(w.symbol,g,S)}else"CIMCharacterMarker"===u.type?pt.findApplicableOverrides(u.symbol,g,S):"CIMHatchFill"===u.type?pt.findApplicableOverrides(u.lineSymbol,g,S):"CIMPictureMarker"===u.type&&pt.findApplicableOverrides(u.animatedSymbolProperties,g,S)}}}static findEffectOverrides(u,g,S){if(!g||!u)return;const w=u.length;for(let C=0;C<w;C++){const n=u[C]?.primitiveName;if(n){let P=!1;for(const m of S)if(m.primitiveName===n){P=!0;break}if(!P)for(const m of g)m.primitiveName===n&&S.push(m)}}}static resolveSymbolOverrides(u,g,S,w,C,n,P){return(0,Ot.Z)(function*(){if(!u||!u.symbol)return null;let{symbol:m,primitiveOverrides:v}=u;const M=!!v;if(!M&&!w)return m;m=(0,ft.d9)(m);let U=!0;if(g||(g={attributes:{}},U=!1),M){if(U||(v=v.filter(V=>!V.valueExpressionInfo?.expression.includes("$feature"))),P||(v=v.filter(V=>!V.valueExpressionInfo?.expression.includes("$view"))),v.length>0){const V=(0,D.Qf)(g.attributes);yield pt.evaluateOverrides(v,g,{spatialReference:S,fields:V,geometryType:C},n,P)}pt.applyOverrides(m,v)}return w&&pt.applyDictionaryTextOverrides(m,g,w),m})()}static evaluateOverrides(u,g,S,w,C){return(0,Ot.Z)(function*(){if(!g)return;let n;for(const P of u){const m=P.valueExpressionInfo;if(m&&S&&S.geometryType){n||(n=[]),P.value=void 0;const v=(0,Z.Yi)(m.expression,S.spatialReference,S.fields).then(M=>{P.value=(0,ct.Z)(M,g,{$view:C},S.geometryType,w)});n.push(v)}}void 0!==n&&n.length>0&&(yield Promise.all(n))})()}static applyDictionaryTextOverrides(u,g,S,w="Normal"){if(u&&u.type)switch(u.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":case"CIMTextSymbol":{const C=u.symbolLayers;if(!C)return;for(const n of C)n&&"CIMVectorMarker"===n.type&&pt.applyDictionaryTextOverrides(n,g,S,"CIMTextSymbol"===u.type?u.textCase:w)}break;case"CIMVectorMarker":{const C=u.markerGraphics;if(!C)return;for(const n of C)n&&pt.applyDictionaryTextOverrides(n,g,S)}break;case"CIMMarkerGraphic":{const C=u.textString;if(C&&C.includes("[")){const n=(0,D.H1)(C,S);u.textString=(0,D.E_)(g,n,w)}}}}static applyOverrides(u,g,S,w){if(u.primitiveName)for(const C of g)if(C.primitiveName===u.primitiveName){const n=q(C.propertyName);if(w&&w.push({cim:u,nocapPropertyName:n,value:u[n]}),C.expression&&(C.value=pt.toValue(C.propertyName,C.expression)),S){let P=!1;for(const m of S)m.primitiveName===u.primitiveName&&(P=!0);P||S.push(C)}(0,L.pC)(C.value)&&(u[n]=C.value)}switch(u.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":if(u.effects)for(const C of u.effects)pt.applyOverrides(C,g,S,w);if(u.symbolLayers)for(const C of u.symbolLayers)pt.applyOverrides(C,g,S,w);break;case"CIMTextSymbol":break;case"CIMSolidStroke":case"CIMSolidFill":case"CIMVectorMarker":if(u.effects)for(const C of u.effects)pt.applyOverrides(C,g,S,w);if("CIMVectorMarker"===u.type&&u.markerGraphics)for(const C of u.markerGraphics)pt.applyOverrides(C,g,S,w),pt.applyOverrides(C.symbol,g,S,w)}}static restoreOverrides(u){for(const g of u)g.cim[g.nocapPropertyName]=g.value}static buildOverrideKey(u){let g="";for(const S of u)void 0!==S.value&&(g+=`${S.primitiveName}${S.propertyName}${JSON.stringify(S.value)}`);return g}static toValue(u,g){if("DashTemplate"===u)return g.split(" ").map(S=>Number(S));if("Color"===u){const S=new it.Z(g).toRgba();return S[3]*=255,S}return g}}const Tt=O=>{if(!O)return N.kP.Butt;switch(O){case"butt":return N.kP.Butt;case"square":return N.kP.Square;case"round":return N.kP.Round}},It=O=>{if(!O)return N.r4.Miter;switch(O){case"miter":return N.r4.Miter;case"round":return N.r4.Round;case"bevel":return N.r4.Bevel}},Gt=O=>{if((0,L.Wi)(O))return"Center";switch(O){case"left":return"Left";case"right":return"Right";case"center":return"Center"}},Xt=O=>{if((0,L.Wi)(O))return"Center";switch(O){case"baseline":return"Baseline";case"top":return"Top";case"middle":return"Center";case"bottom":return"Bottom"}},ot=O=>{if(!O)return[0,0,0,0];const{r:u,g,b:S,a:w}=O;return[u,g,S,255*w]},a=(O,u)=>{const g=_(u),S=k(O);return g&&S?`${g}-${S}`:`${g}${S}`},_=O=>{if(!O)return"";switch(O.toLowerCase()){case"bold":case"bolder":return"bold"}return""},k=O=>{if(!O)return"";switch(O.toLowerCase()){case"italic":case"oblique":return"italic"}return""},b=(O,u)=>{const g="butt"===u;switch(O){case"dash":case"esriSLSDash":return g?[4,3]:[3,4];case"dash-dot":case"esriSLSDashDot":return g?[4,3,1,3]:[3,4,0,4];case"dot":case"esriSLSDot":return g?[1,3]:[0,4];case"long-dash":case"esriSLSLongDash":return g?[8,3]:[7,4];case"long-dash-dot":case"esriSLSLongDashDot":return g?[8,3,1,3]:[7,4,0,4];case"long-dash-dot-dot":case"esriSLSDashDotDot":return g?[8,3,1,3,1,3]:[7,4,0,4,0,4];case"short-dash":case"esriSLSShortDash":return g?[4,1]:[3,2];case"short-dash-dot":case"esriSLSShortDashDot":return g?[4,1,1,1]:[3,2,0,2];case"short-dash-dot-dot":case"esriSLSShortDashDotDot":return g?[4,1,1,1,1,1]:[3,2,0,2,0,2];case"short-dot":case"esriSLSShortDot":return g?[1,1]:[0,2];case"solid":case"esriSLSSolid":case"none":return dt.error("Unexpected: style does not require rasterization"),[0,0];default:return dt.error(`Tried to rasterize SLS, but found an unexpected style: ${O}!`),[0,0]}},F=O=>{let S,w;const C=O;if("circle"===C||"esriSMSCircle"===C){let P=Math.acos(.995),m=Math.ceil(xt/P/4);0===m&&(m=1),P=kt/m,m*=4;const v=[];v.push([50,0]);for(let M=1;M<m;M++)v.push([50*Math.cos(M*P),-50*Math.sin(M*P)]);v.push([50,0]),S={rings:[v]},w={xmin:-50,ymin:-50,xmax:50,ymax:50}}else if("cross"===C||"esriSMSCross"===C)S={rings:[[[0,50],[0,0],[50,0],[50,-0],[0,-0],[0,-50],[-0,-50],[-0,-0],[-50,-0],[-50,0],[-0,0],[-0,50],[0,50]]]},w={xmin:-50,ymin:-50,xmax:50,ymax:50};else if("diamond"===C||"esriSMSDiamond"===C)S={rings:[[[-50,0],[0,50],[50,0],[0,-50],[-50,0]]]},w={xmin:-50,ymin:-50,xmax:50,ymax:50};else if("square"===C||"esriSMSSquare"===C)S={rings:[[[-50,-50],[-50,50],[50,50],[50,-50],[-50,-50]]]},w={xmin:-50,ymin:-50,xmax:50,ymax:50};else if("x"===C||"esriSMSX"===C)S={rings:[[[0,0],[50,50],[50,50],[0,0],[50,-50],[50,-50],[0,-0],[-50,-50],[-50,-50],[-0,0],[-50,50],[-50,50],[0,0]]]},w={xmin:-50,ymin:-50,xmax:50,ymax:50};else if("triangle"===C||"esriSMSTriangle"===C){const n=57.735026918962575,P=-n,m=2/3*100,v=m-100;S={rings:[[[P,v],[0,m],[n,v],[P,v]]]},w={xmin:P,ymin:v,xmax:n,ymax:m}}else"arrow"===C&&(S={rings:[[[-50,50],[50,0],[-50,-50],[-33,-20],[-33,20],[-50,50]]]},w={xmin:-50,ymin:-50,xmax:50,ymax:50});return[w,S]},x=O=>"vertical"===O||"horizontal"===O||"cross"===O||"esriSFSCross"===O||"esriSFSVertical"===O||"esriSFSHorizontal"===O,q=O=>O&&O.charAt(0).toLowerCase()+O.substr(1);function gt(O,u,g){if(O.effects&&!(0,L.pC)(u.geometryEngine)){if(u.geometryEnginePromise)return void g.push(u.geometryEnginePromise);(0,D.Cc)(O.effects)&&(u.geometryEnginePromise=(0,D.RI)(),g.push(u.geometryEnginePromise),u.geometryEnginePromise.then(S=>u.geometryEngine=S))}}},31375:(ue,Yt,W)=>{W.d(Yt,{Z:()=>Ot});class Ot{constructor(_t=0,ft=0,Ft=0,L=0){this.x=_t,this.y=ft,this.width=Ft,this.height=L}get isEmpty(){return this.width<=0||this.height<=0}union(_t){this.x=Math.min(this.x,_t.x),this.y=Math.min(this.y,_t.y),this.width=Math.max(this.width,_t.width),this.height=Math.max(this.height,_t.height)}}},47139:(ue,Yt,W)=>{W.d(Yt,{Fp:()=>ft,RL:()=>ht,UV:()=>st,bk:()=>$});var Ot=W(36161),it=W(91179),_t=W(31375);function ft(N){if(!N)return null;switch(N.type){case"CIMPointSymbol":{const D=N.symbolLayers;return D&&1===D.length?ft(D[0]):null}case"CIMVectorMarker":{const D=N.markerGraphics;if(!D||1!==D.length)return null;const ct=D[0];if(!ct)return null;const E=ct.geometry;if(!E)return null;const St=ct.symbol;return!St||"CIMPolygonSymbol"!==St.type&&"CIMLineSymbol"!==St.type||St.symbolLayers?.some(Ct=>!!Ct.effects)?null:{geom:E,asFill:"CIMPolygonSymbol"===St.type}}case"sdf":return{geom:N.geom,asFill:N.asFill}}return null}function ut(N){let D=1/0,ct=-1/0,E=1/0,St=-1/0;for(const Ct of N)for(const xt of Ct)xt[0]<D&&(D=xt[0]),xt[0]>ct&&(ct=xt[0]),xt[1]<E&&(E=xt[1]),xt[1]>St&&(St=xt[1]);return[D,E,ct,St]}function $(N){return N?N.rings?ut(N.rings):N.paths?ut(N.paths):(0,it.YX)(N)?[N.xmin,N.ymin,N.xmax,N.ymax]:null:null}function st(N,D,ct,E,St){const[Ct,xt,kt,zt]=N;if(kt<Ct||zt<xt)return[0,0,0];const R=kt-Ct,et=zt-xt,dt=Math.floor(31.5),At=(128-2*(dt+1))/Math.max(R,et),mt=Math.round(R*At)+2*dt,H=Math.round(et*At)+2*dt;let Q=1;D&&(Q=H/At/(D.ymax-D.ymin));let B=0,K=0,nt=1;E&&(St?D&&ct&&D.ymax-D.ymin>0&&(nt=(D.xmax-D.xmin)/(D.ymax-D.ymin),B=E.x/(ct*nt),K=E.y/ct):(B=E.x,K=E.y)),D&&(B=.5*(D.xmax+D.xmin)+B*(D.xmax-D.xmin),K=.5*(D.ymax+D.ymin)+K*(D.ymax-D.ymin)),B-=Ct,K-=xt,B*=At,K*=At,B+=dt,K+=dt;let pt=B/mt-.5,Tt=K/H-.5;return St&&ct&&(pt*=ct*nt,Tt*=ct),[Q,pt,Tt]}function ht(N){const D=function Ft(N){return N?N.rings?N.rings:N.paths?N.paths:void 0!==N.xmin&&void 0!==N.ymin&&void 0!==N.xmax&&void 0!==N.ymax?[[[N.xmin,N.ymin],[N.xmin,N.ymax],[N.xmax,N.ymax],[N.xmax,N.ymin],[N.xmin,N.ymin]]]:null:null}(N.geom),ct=function L(N){let D=1/0,ct=-1/0,E=1/0,St=-1/0;for(const Ct of N)for(const xt of Ct)xt[0]<D&&(D=xt[0]),xt[0]>ct&&(ct=xt[0]),xt[1]<E&&(E=xt[1]),xt[1]>St&&(St=xt[1]);return new _t.Z(D,E,ct-D,St-E)}(D),Ct=Math.floor(31.5),xt=(128-2*(Ct+1))/Math.max(ct.width,ct.height),kt=Math.round(ct.width*xt)+2*Ct,zt=Math.round(ct.height*xt)+2*Ct,R=[];for(const yt of D)if(yt&&yt.length>1){const Nt=[];for(const dt of yt){let[At,mt]=dt;At-=ct.x,mt-=ct.y,At*=xt,mt*=xt,At+=Ct-.5,mt+=Ct-.5,Nt.push(N.asFill?[At,mt]:[Math.round(At),Math.round(mt)])}if(N.asFill){const dt=Nt.length-1;Nt[0][0]===Nt[dt][0]&&Nt[0][1]===Nt[dt][1]||Nt.push(Nt[0])}R.push(Nt)}const et=function Z(N,D,ct,E){const St=D*ct,Ct=new Array(St),xt=E*E+1;for(let kt=0;kt<St;++kt)Ct[kt]=xt;for(const kt of N){const zt=kt.length;for(let R=1;R<zt;++R){const et=kt[R-1],yt=kt[R];let Nt,dt,At,mt;et[0]<yt[0]?(Nt=et[0],dt=yt[0]):(Nt=yt[0],dt=et[0]),et[1]<yt[1]?(At=et[1],mt=yt[1]):(At=yt[1],mt=et[1]);let H=Math.floor(Nt)-E,Q=Math.floor(dt)+E,B=Math.floor(At)-E,K=Math.floor(mt)+E;H<0&&(H=0),Q>D&&(Q=D),B<0&&(B=0),K>ct&&(K=ct);const nt=yt[0]-et[0],pt=yt[1]-et[1],Tt=nt*nt+pt*pt;for(let It=H;It<Q;It++)for(let Gt=B;Gt<K;Gt++){let Xt,ot,a=(It-et[0])*nt+(Gt-et[1])*pt;a<0?(Xt=et[0],ot=et[1]):a>Tt?(Xt=yt[0],ot=yt[1]):(a/=Tt,Xt=et[0]+a*nt,ot=et[1]+a*pt);const _=(It-Xt)*(It-Xt)+(Gt-ot)*(Gt-ot),k=(ct-Gt-1)*D+It;_<Ct[k]&&(Ct[k]=_)}}}for(let kt=0;kt<St;++kt)Ct[kt]=Math.sqrt(Ct[kt]);return Ct}(R,kt,zt,Ct);return N.asFill&&function Pt(N,D,ct,E,St){for(const Ct of N){const xt=Ct.length;for(let kt=1;kt<xt;++kt){const zt=Ct[kt-1],R=Ct[kt];let et,yt,Nt,dt;zt[0]<R[0]?(et=zt[0],yt=R[0]):(et=R[0],yt=zt[0]),zt[1]<R[1]?(Nt=zt[1],dt=R[1]):(Nt=R[1],dt=zt[1]);let At=Math.floor(et),mt=Math.floor(yt)+1,H=Math.floor(Nt),Q=Math.floor(dt)+1;At<E&&(At=E),mt>D-E&&(mt=D-E),H<E&&(H=E),Q>ct-E&&(Q=ct-E);for(let B=H;B<Q;++B){if(zt[1]>B==R[1]>B)continue;const K=(ct-B-1)*D;for(let nt=At;nt<mt;++nt)nt<(R[0]-zt[0])*(B-zt[1])/(R[1]-zt[1])+zt[0]&&(St[K+nt]=-St[K+nt]);for(let nt=E;nt<At;++nt)St[K+nt]=-St[K+nt]}}}}(R,kt,zt,Ct,et),[wt(et,Ct),kt,zt]}function wt(N,D){const ct=2*D,E=N.length,St=new Uint8Array(4*E);for(let Ct=0;Ct<E;++Ct)(0,Ot.I)(.5-N[Ct]/ct,St,4*Ct);return St}},68937:(ue,Yt,W)=>{W.d(Yt,{Z:()=>ft});var Ot=W(23841);class ft{constructor(ut){ut&&(this._textRasterizationCanvas=ut)}rasterizeText(ut,$){this._textRasterizationCanvas||(this._textRasterizationCanvas=document.createElement("canvas"));const st=this._textRasterizationCanvas,ht=st.getContext("2d");this._setFontProperties(ht,$),this._parameters=$,this._textLines=ut.split(/\r?\n/),this._lineHeight=this._computeLineHeight();const Z=this._computeTextWidth(ht,$),{decoration:Pt,weight:wt}=$.font;this._lineThroughWidthOffset=Pt&&"line-through"===Pt?.1*this._lineHeight:0;const N=this._lineHeight*this._textLines.length;st.width=Z+2*this._lineThroughWidthOffset,st.height=N,this._renderedLineHeight=Math.round(this._lineHeight*$.pixelRatio),this._renderedHaloSize=$.halo.size*$.pixelRatio,this._renderedWidth=Z*$.pixelRatio,this._renderedHeight=N*$.pixelRatio,this._lineThroughWidthOffset*=$.pixelRatio;const ct=$.halo&&$.halo.color?$.halo.color:[0,0,0,0];this._fillStyle=function _t(L){return`rgba(${L.slice(0,3).toString()},${L[3]})`}($.color??[0,0,0,0]),this._haloStyle=function it(L){return`rgb(${L.slice(0,3).toString()})`}(ct);const E=this._renderedLineHeight,St=this._renderedHaloSize;ht.save(),ht.clearRect(0,0,st.width,st.height),this._setFontProperties(ht,$);const Ct=function Ft(L,ut){return"center"===L?.5*ut:"right"===L?ut:0}(ht.textAlign,this._renderedWidth)+St,xt=St,kt=St>0;let zt=this._lineThroughWidthOffset,R=0;kt&&this._renderHalo(ht,Ct,xt,zt,R,$),R+=xt,zt+=Ct;for(const H of this._textLines)kt?(ht.globalCompositeOperation="destination-out",ht.fillStyle="rgb(0, 0, 0)",ht.fillText(H,zt,R),ht.globalCompositeOperation="source-over",ht.fillStyle=this._fillStyle,ht.fillText(H,zt,R)):(ht.fillStyle=this._fillStyle,ht.fillText(H,zt,R)),Pt&&"none"!==Pt&&this._renderDecoration(ht,zt,R,Pt,wt),R+=E;ht.restore();const et=this._renderedWidth+2*this._lineThroughWidthOffset,yt=this._renderedHeight,Nt=ht.getImageData(0,0,et,yt),dt=new Uint8Array(Nt.data);if($.premultiplyColors){let H;for(let Q=0;Q<dt.length;Q+=4)H=dt[Q+3]/255,dt[Q]=dt[Q]*H,dt[Q+1]=dt[Q+1]*H,dt[Q+2]=dt[Q+2]*H}let At,mt;switch($.horizontalAlignment){case"left":At=-.5;break;case"right":At=.5;break;default:At=0}switch($.verticalAlignment){case"bottom":mt=-.5;break;case"top":mt=.5;break;default:mt=0}return{size:[et,yt],image:new Uint32Array(dt.buffer),sdf:!1,simplePattern:!1,anchorX:At,anchorY:mt,canvas:st}}_renderHalo(ut,$,st,ht,Z,Pt){const wt=this._renderedWidth,N=this._renderedHeight;this._haloRasterizationCanvas||(this._haloRasterizationCanvas=document.createElement("canvas")),this._haloRasterizationCanvas.width=wt,this._haloRasterizationCanvas.height=N;const D=this._haloRasterizationCanvas,ct=D.getContext("2d");ct.clearRect(0,0,wt,N),this._setFontProperties(ct,Pt);const{decoration:E,weight:St}=Pt.font;ct.fillStyle=this._haloStyle,ct.strokeStyle=this._haloStyle,ct.lineJoin="round",this._renderHaloNative(ct,$,st,E,St),ut.globalAlpha=this._parameters.halo.color[3],ut.drawImage(D,0,0,wt,N,ht,Z,wt,N),ut.globalAlpha=1}_renderHaloNative(ut,$,st,ht,Z){const Pt=this._renderedLineHeight,wt=this._renderedHaloSize;for(const N of this._textLines){const D=2*wt,ct=5,E=.1;for(let St=0;St<ct;St++){const Ct=(1-(ct-1)*E+St*E)*D;ut.lineWidth=Ct,ut.strokeText(N,$,st),ht&&"none"!==ht&&this._renderDecoration(ut,$,st,ht,Z,Ct)}st+=Pt}}_setFontProperties(ut,$){const st=Math.max($.size,.5),ht=$.font,Z=`${ht.style} ${ht.weight} ${(0,Ot.F2)(st*$.pixelRatio).toFixed(1)}px ${ht.family}, sans-serif`;let Pt;switch(ut.font=Z,ut.textBaseline="top",$.horizontalAlignment){case"left":default:Pt="left";break;case"right":Pt="right";break;case"center":Pt="center"}ut.textAlign=Pt}computeTextSize(ut,$){this._textRasterizationCanvas||(this._textRasterizationCanvas=document.createElement("canvas"));const st=this._textRasterizationCanvas,ht=st.getContext("2d");this._setFontProperties(ht,$),this._parameters=$,this._textLines=ut.split(/\r?\n/),this._lineHeight=this._computeLineHeight();const Z=this._computeTextWidth(ht,$),Pt=this._lineHeight*this._textLines.length;return st.width=Z,st.height=Pt,[Z*$.pixelRatio,Pt*$.pixelRatio]}_computeTextWidth(ut,$){let st=0;for(const Z of this._textLines)st=Math.max(st,ut.measureText(Z).width);const ht=$.font;return("italic"===ht.style||"oblique"===ht.style||"string"==typeof ht.weight&&("bold"===ht.weight||"bolder"===ht.weight)||"number"==typeof ht.weight&&ht.weight>600)&&(st+=.3*ut.measureText("w").width),st+=2*this._parameters.halo.size,Math.round(st)}_computeLineHeight(){let ut=1.275*this._parameters.size;const $=this._parameters.font.decoration;return $&&"underline"===$&&(ut*=1.3),Math.round(ut+2*this._parameters.halo.size)}_renderDecoration(ut,$,st,ht,Z,Pt){const wt=.9*this._lineHeight,N="bold"===Z?.06:"bolder"===Z?.09:.04;switch(ut.textAlign){case"center":$-=this._renderedWidth/2;break;case"right":$-=this._renderedWidth}const D=ut.textBaseline;if("underline"===ht)switch(D){case"top":st+=wt;break;case"middle":st+=wt/2}else if("line-through"===ht)switch(D){case"top":st+=wt/1.5;break;case"middle":st+=wt/3}const ct=Pt?1.5*Pt:Math.ceil(wt*N);ut.save(),ut.beginPath(),ut.strokeStyle=ut.fillStyle,ut.lineWidth=ct,ut.moveTo($-this._lineThroughWidthOffset,st),ut.lineTo($+this._renderedWidth+2*this._lineThroughWidthOffset,st),ut.stroke(),ut.restore()}}},13871:(ue,Yt,W)=>{W.d(Yt,{S:()=>S,c:()=>dt});var Ot=W(15861),it=W(91558),_t=W(17002),ft=W(58817),Ft=W(63290),L=W(62208),ut=W(23841),$=W(77275),st=W(46679),ht=W(35909),Z=W(7547);const N=new Set(["StartTimeOffset","Duration","RepeatDelay"]);function D(n,P){return N.has(P)?function wt(n){return.05*Math.max(Math.round(n/.05),1)}(n):n}var ct=W(47139),E=W(80991),St=W(73608),Ct=W(39236),xt=W(39351),kt=W(3959);const zt=Ft.Z.getLogger("esri.symbols.cim.cimAnalyzer");function R(n){switch(n){case"Butt":return Z.RL.BUTT;case"Square":return Z.RL.SQUARE;default:return Z.RL.ROUND}}function et(n){switch(n){case"Bevel":return Z.AH.BEVEL;case"Miter":return Z.AH.MITER;default:return Z.AH.ROUND}}function yt(n,P,m,v){let M;n[P]?M=n[P]:(M={},n[P]=M),M[m]=v}function Nt(n){const P=n.markerPlacement;return P&&P.angleToLine?Z.v2.MAP:Z.v2.SCREEN}function dt(n,P,m,v,M){return At.apply(this,arguments)}function At(){return(At=(0,Ot.Z)(function*(n,P,m,v,M){const U=v??[];if(!n)return U;let V,G;const A={};if("CIMSymbolReference"!==n.type)return zt.error("Expect cim type to be 'CIMSymbolReference'"),U;if(V=n.symbol,G=n.primitiveOverrides,G){const j=[];for(const rt of G){const tt=rt.valueExpressionInfo;if(tt&&P){const Lt=(0,st.Yi)(tt.expression,P.spatialReference,P.fields).then(Et=>{(0,L.Wi)(Et)||yt(A,rt.primitiveName,rt.propertyName,Et)});j.push(Lt)}else null!=rt.value&&yt(A,rt.primitiveName,rt.propertyName,rt.value)}j.length>0&&(yield Promise.all(j))}const Y=[];switch(ht.B$.fetchResources(V,m,Y),Y.length>0&&(yield Promise.all(Y)),V?.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":mt(V,G,A,P,U,m,!!M)}return U})).apply(this,arguments)}function mt(n,P,m,v,M,U,V){if(!n)return;const G=n.symbolLayers;if(!G)return;const A=n.effects;let Y=Z.v2.SCREEN;const j=ht.B$.getSize(n)??0;"CIMPointSymbol"===n.type&&"Map"===n.angleAlignment&&(Y=Z.v2.MAP);let rt=G.length;for(;rt--;){const tt=G[rt];if(!tt||!1===tt.enable)continue;let at;A&&A.length&&(at=[...A]);const Lt=tt.effects;Lt&&Lt.length&&(A?at.push(...Lt):at=[...Lt]);const Et=[];let vt;ht.E0.findEffectOverrides(at,P,Et),vt=Et.length>0?gt(at,Et,m,v):at;const Rt=[];switch(ht.E0.findApplicableOverrides(tt,P,Rt),tt.type){case"CIMSolidFill":H(tt,vt,m,Rt,v,M);break;case"CIMPictureFill":Q(tt,vt,m,Rt,v,U,M);break;case"CIMHatchFill":B(tt,vt,m,Rt,v,M);break;case"CIMGradientFill":K(tt,vt,m,Rt,v,M);break;case"CIMSolidStroke":nt(tt,vt,m,Rt,v,M,"CIMPolygonSymbol"===n.type,j);break;case"CIMPictureStroke":pt(tt,vt,m,Rt,v,M,"CIMPolygonSymbol"===n.type,j);break;case"CIMGradientStroke":Tt(tt,vt,m,Rt,v,M,"CIMPolygonSymbol"===n.type,j);break;case"CIMCharacterMarker":if(It(tt,vt,m,Rt,v,M))break;break;case"CIMPictureMarker":if(It(tt,vt,m,Rt,v,M))break;"CIMLineSymbol"===n.type&&(Y=Nt(tt)),Gt(tt,vt,m,Rt,v,U,M,Y,j);break;case"CIMVectorMarker":if(It(tt,vt,m,Rt,v,M))break;"CIMLineSymbol"===n.type&&(Y=Nt(tt)),Xt(tt,vt,m,Rt,v,M,U,Y,j,V);break;default:zt.error("Cannot analyze CIM layer",tt.type)}}}function H(n,P,m,v,M,U){const V=n.primitiveName,G=(0,E.NO)(n.color),[A,Y]=w(v,V,P,null,null),j=(0,$.hP)(JSON.stringify(n)+Y).toString();U.push({type:"fill",templateHash:j,materialHash:A?()=>j:j,cim:n,materialOverrides:null,colorLocked:!!n.colorLocked,color:x(V,m,"Color",M,G,F),height:0,angle:0,offsetX:0,offsetY:0,scaleX:1,effects:P,applyRandomOffset:!1,sampleAlphaOnly:!0})}function Q(n,P,m,v,M,U,V){const G=n.primitiveName,A=(0,E.cO)(n),[Y,j]=w(v,G,P,null,null),rt=(0,$.hP)(JSON.stringify(n)+j).toString(),tt=(0,$.hP)(`${n.url}${JSON.stringify(n.colorSubstitutions)}`).toString();let at=(0,E.NA)(n.scaleX);if("width"in n&&"number"==typeof n.width){const Lt=n.width;let Et=1;const vt=U.getResource(n.url);(0,L.pC)(vt)&&(Et=vt.width/vt.height),at/=Et*(n.height/Lt)}V.push({type:"fill",templateHash:rt,materialHash:Y?()=>tt:tt,cim:n,materialOverrides:null,colorLocked:!!n.colorLocked,effects:P,color:x(G,m,"TintColor",M,A,F),height:x(G,m,"Height",M,n.height),scaleX:x(G,m,"ScaleX",M,at),angle:x(G,m,"Rotation",M,(0,E.NA)(n.rotation)),offsetX:x(G,m,"OffsetX",M,(0,E.NA)(n.offsetX)),offsetY:x(G,m,"OffsetY",M,(0,E.NA)(n.offsetY)),url:n.url,applyRandomOffset:!1,sampleAlphaOnly:!1})}function B(n,P,m,v,M,U){const V=["Rotation","OffsetX","OffsetY"],G=v.filter(vt=>vt.primitiveName!==n.primitiveName||!V.includes(vt.propertyName)),A=n.primitiveName;let[Y,j]=w(v,A,P,null,null);const rt=(0,$.hP)(JSON.stringify(n)+j).toString(),tt=(0,$.hP)(`${n.separation}${JSON.stringify(n.lineSymbol)}`).toString();let at={r:255,g:255,b:255,a:1},Lt=!1;const Et=n.lineSymbol?.symbolLayers?.find(vt=>"CIMSolidStroke"===vt.type&&null!=m[vt.primitiveName]?.Color);if(Et){at=(0,E.NO)(Et.color),at=x(Et.primitiveName,m,"Color",M,at,F);const vt="function"==typeof at;Y=Y||vt,Lt=null!=Et.color||vt}U.push({type:"fill",templateHash:rt,materialHash:Y?g(tt,m,G,M):tt,cim:n,materialOverrides:G,colorLocked:!!n.colorLocked,effects:P,color:at,height:x(A,m,"Separation",M,n.separation),scaleX:1,angle:x(A,m,"Rotation",M,(0,E.NA)(n.rotation)),offsetX:x(A,m,"OffsetX",M,(0,E.NA)(n.offsetX)),offsetY:x(A,m,"OffsetY",M,(0,E.NA)(n.offsetY)),applyRandomOffset:!1,sampleAlphaOnly:!0,hasUnresolvedReplacementColor:!Lt})}function K(n,P,m,v,M,U){const V=n.primitiveName,[G,A]=w(v,V,P,null,null),Y=(0,$.hP)(JSON.stringify(n)+A).toString();U.push({type:"fill",templateHash:Y,materialHash:G?g(Y,m,v,M):Y,cim:n,materialOverrides:null,colorLocked:!!n.colorLocked,effects:P,color:{r:128,g:128,b:128,a:1},height:0,angle:0,offsetX:0,offsetY:0,scaleX:1,applyRandomOffset:!1,sampleAlphaOnly:!1})}function nt(n,P,m,v,M,U,V,G){const A=n.primitiveName,Y=(0,E.NO)(n.color),j=null!=n.width?n.width:4,rt=R(n.capStyle),tt=et(n.joinStyle),at=n.miterLimit,[Lt,Et]=w(v,A,P,null,null),vt=(0,$.hP)(JSON.stringify(n)+Et).toString();let Rt,Ht;if(P&&P instanceof Array&&P.length>0){const jt=P[P.length-1];if("CIMGeometricEffectDashes"===jt.type&&"NoConstraint"===jt.lineDashEnding&&null===jt.offsetAlongLine){const Zt=(P=[...P]).pop();Rt=Zt.dashTemplate,Ht=Zt.scaleDash}}U.push({type:"line",templateHash:vt,materialHash:Lt?()=>vt:vt,cim:n,materialOverrides:null,isOutline:V,colorLocked:!!n.colorLocked,effects:P,color:x(A,m,"Color",M,Y,F),width:x(A,m,"Width",M,j),cap:x(A,m,"CapStyle",M,rt),join:x(A,m,"JoinStyle",M,tt),miterLimit:at&&x(A,m,"MiterLimit",M,at),referenceWidth:G,zOrder:I(n.name),dashTemplate:Rt,scaleDash:Ht,sampleAlphaOnly:!0})}function pt(n,P,m,v,M,U,V,G){const A=(0,$.hP)(`${n.url}${JSON.stringify(n.colorSubstitutions)}`).toString(),Y=n.primitiveName,j=(0,E.cO)(n),rt=null!=n.width?n.width:4,tt=R(n.capStyle),at=et(n.joinStyle),Lt=n.miterLimit,[Et,vt]=w(v,Y,P,null,null),Rt=(0,$.hP)(JSON.stringify(n)+vt).toString();U.push({type:"line",templateHash:Rt,materialHash:Et?()=>A:A,cim:n,materialOverrides:null,isOutline:V,colorLocked:!!n.colorLocked,effects:P,color:x(Y,m,"TintColor",M,j,F),width:x(Y,m,"Width",M,rt),cap:x(Y,m,"CapStyle",M,tt),join:x(Y,m,"JoinStyle",M,at),miterLimit:Lt&&x(Y,m,"MiterLimit",M,Lt),referenceWidth:G,zOrder:I(n.name),dashTemplate:null,scaleDash:!1,url:n.url,sampleAlphaOnly:!1})}function Tt(n,P,m,v,M,U,V,G){const A=n.primitiveName,Y=null!=n.width?n.width:4,j=R(n.capStyle),rt=et(n.joinStyle),tt=n.miterLimit,[at,Lt]=w(v,A,P,null,null),Et=(0,$.hP)(JSON.stringify(n)+Lt).toString();U.push({type:"line",templateHash:Et,materialHash:at?g(Et,m,v,M):Et,cim:n,materialOverrides:null,isOutline:V,colorLocked:!!n.colorLocked,effects:P,color:{r:128,g:128,b:128,a:1},width:x(A,m,"Width",M,Y),cap:x(A,m,"CapStyle",M,j),join:x(A,m,"JoinStyle",M,rt),miterLimit:tt&&x(A,m,"MiterLimit",M,tt),referenceWidth:G,zOrder:I(n.name),dashTemplate:null,scaleDash:!1,sampleAlphaOnly:!1})}function It(n,P,m,v,M,U){const{markerPlacement:V,type:G}=n;if(!V||"CIMMarkerPlacementInsidePolygon"!==V.type)return!1;if("CIMVectorMarker"===G||"CIMPictureMarker"===G){const Wt=n.primitiveName;if(Wt){const[Jt,Qt]=w(v,Wt,P,null,null);if(Jt)return!1}const ne=V.primitiveName;if(ne){const[Jt,Qt]=w(v,ne,P,null,null);if(Jt)return!1}if("CIMVectorMarker"===G){const{markerGraphics:Jt}=n;if(Jt)for(const Qt of Jt){const{symbol:$t}=Qt;if("CIMPolygonSymbol"===$t?.type&&$t.symbolLayers){const{symbolLayers:Bt}=$t;for(const ee of Bt)if("CIMSolidStroke"===ee.type)return!1}}}else{const{animatedSymbolProperties:Jt}=n;if(Jt)return!1}}const A=V,Y=Math.abs(A.stepX),j=Math.abs(A.stepY);if(0===Y||0===j)return!0;const rt=["Rotation","OffsetX","OffsetY"],tt=v.filter(Wt=>Wt.primitiveName!==n.primitiveName||!rt.includes(Wt.propertyName)),at="url"in n&&"string"==typeof n.url?n.url:void 0,[Lt,Et]=w(v,A.primitiveName,P,null,null),vt=(0,$.hP)(JSON.stringify(n)+Et).toString();let Rt,Ht,jt=null;if("Random"===V.gridType){const Wt=(0,ut.Wz)(xt.C1),ne=Math.max(Math.floor(Wt/Y),1),Jt=Math.max(Math.floor(Wt/j),1);Rt=j*Jt,jt=Qt=>Qt?Qt*Jt:0,Ht=ne*Y/Rt}else V.shiftOddRows?(Rt=2*j,jt=Wt=>Wt?2*Wt:0,Ht=Y/j*.5):(Rt=j,jt=null,Ht=Y/j);const Zt=(0,E.cO)(n);return U.push({type:"fill",templateHash:vt,materialHash:Lt?g(vt,m,tt,M):vt,cim:n,materialOverrides:tt,colorLocked:!!n.colorLocked,effects:P,color:x(A.primitiveName,m,"TintColor",M,Zt,F),height:x(A.primitiveName,m,"StepY",M,Rt,jt),scaleX:Ht,angle:x(A.primitiveName,m,"GridAngle",M,A.gridAngle),offsetX:x(A.primitiveName,m,"OffsetX",M,(0,E.NA)(A.offsetX)),offsetY:x(A.primitiveName,m,"OffsetY",M,(0,E.NA)(A.offsetY)),url:at,applyRandomOffset:"Random"===V.gridType,sampleAlphaOnly:!at,hasUnresolvedReplacementColor:!0}),!0}function Gt(n,P,m,v,M,U,V,G,A){const Y=n.primitiveName,j=(0,E.NA)(n.size);let rt=(0,E.NA)(n.scaleX,1);const tt=(0,E.NA)(n.rotation),at=(0,E.NA)(n.offsetX),Lt=(0,E.NA)(n.offsetY),Et=(0,E.cO)(n),vt=(0,$.hP)(`${n.url}${JSON.stringify(n.colorSubstitutions)}${JSON.stringify(n.animatedSymbolProperties)}`).toString(),Rt=O(n.markerPlacement,v,m,M),Ht=function u(n,P,m,v){const M=[];if(ht.E0.findApplicableOverrides(n,P,M),null==n||0===M.length)return n;for(const U of M)if(U.valueExpressionInfo&&v?.geometryType){const V=m[U.primitiveName]&&m[U.primitiveName][U.propertyName];V instanceof st.mz&&(U.fn=(G,A,Y)=>(0,Ct.Z)(V,G,{$view:Y},v.geometryType,A))}return(U,V,G)=>{for(const j of M)j.fn&&(j.value=j.fn(U,V,G));const A=(0,ft.d9)(n),Y=n.primitiveName;for(const j of M)if(j.primitiveName===Y){const rt=q(j.propertyName);if(null!=j.value){const tt=D(j.value,j.propertyName);tt!==A[rt]&&(A[rt]=tt)}}return A}}(n.animatedSymbolProperties,v,m,M),[jt,Zt]=w(v,Y,P,Rt,Ht),Wt=(0,$.hP)(JSON.stringify(n)+Zt).toString(),ne=n.anchorPoint??{x:0,y:0};if("width"in n&&"number"==typeof n.width){const $t=n.width;let Bt=1;const ee=U.getResource(n.url);(0,L.pC)(ee)&&(Bt=ee.width/ee.height),rt/=Bt*(j/$t)}function Jt($t,Bt){return(0,L.pC)(Ht)?(0,E.hf)(Ht,$t,Bt):null}V.push({type:"marker",templateHash:Wt,materialHash:n.animatedSymbolProperties&&!0===n.animatedSymbolProperties.randomizeStartTime?($t,Bt,ee,he)=>{const ae=(0,kt.$)(he??0),me=Jt($t,Bt);return vt+`-MATERIALGROUP(${ae})-ASP(${JSON.stringify(me)})`}:jt?($t,Bt)=>{const ee=Jt($t,Bt);return vt+`-ASP(${JSON.stringify(ee)})`}:vt,cim:n,materialOverrides:null,colorLocked:!!n.colorLocked,effects:P,scaleSymbolsProportionally:!1,alignment:G,size:x(Y,m,"Size",M,j),scaleX:x(Y,m,"ScaleX",M,rt),rotation:x(Y,m,"Rotation",M,tt),offsetX:x(Y,m,"OffsetX",M,at),offsetY:x(Y,m,"OffsetY",M,Lt),color:x(Y,m,"TintColor",M,Et,F),anchorPoint:{x:ne.x,y:-ne.y},isAbsoluteAnchorPoint:"Relative"!==n.anchorPointUnits,outlineColor:{r:0,g:0,b:0,a:0},outlineWidth:0,frameHeight:0,rotateClockwise:!!n.rotateClockwise,referenceSize:A,sizeRatio:1,markerPlacement:Rt,url:n.url,animatedSymbolProperties:Ht})}function Xt(n,P,m,v,M,U,V,G,A,Y){const j=n.markerGraphics;if(!j)return;let rt=0;if(n.scaleSymbolsProportionally){const at=n.frame;at&&(rt=at.ymax-at.ymin)}const tt=O(n.markerPlacement,v,m,M);for(const at of j)if(at){const Lt=at.symbol;if(!Lt)continue;switch(Lt.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":a(n,P,tt,null,at,v,m,M,U,V,G,A,rt,!!Y);break;case"CIMTextSymbol":ot(n,P,tt,at,m,v,M,U,G,A,rt)}}}function ot(n,P,m,v,M,U,V,G,A,Y,j){ht.E0.findApplicableOverrides(v,U,[]);const tt=v.geometry;if(!("x"in tt)||!("y"in tt))return;const at=v.symbol,Lt=(0,E.BX)(at),Et=(0,E.wi)(at.fontStyleName),vt=(0,_t.BN)(at.fontFamilyName);at.font={family:vt,decoration:Lt,...Et};const Rt=n.frame,Ht=tt.x-.5*(Rt.xmin+Rt.xmax),jt=tt.y-.5*(Rt.ymin+Rt.ymax),Zt=n.size/j,Wt=n.primitiveName,ne=(0,E.NA)(at.height)*Zt,Jt=(0,E.NA)(at.angle),Qt=(0,E.NA)(n.offsetX)+((0,E.NA)(at.offsetX)+Ht)*Zt,$t=(0,E.NA)(n.offsetY)+((0,E.NA)(at.offsetY)+jt)*Zt,Bt=(0,E.NO)((0,E.W7)(at));let ee=(0,E.NO)((0,E.$Z)(at)),he=(0,E.F)(at)??0;he||(ee=(0,E.NO)((0,E.W7)(at.haloSymbol)),at.haloSize&&(he=at.haloSize*Zt));let ae=null,me=null,Pe=0;if(at.callout&&"CIMBackgroundCallout"===at.callout.type){const ye=at.callout;if(ye.backgroundSymbol){const fe=ye.backgroundSymbol.symbolLayers;if(fe)for(const re of fe)"CIMSolidFill"===re.type?ae=(0,E.NO)(re.color):"CIMSolidStroke"===re.type&&(me=(0,E.NO)(re.color),Pe=(0,E.NA)(re.width))}}const[_e,ce]=w(U,Wt,P,m,null),ge=JSON.stringify(n.effects)+Number(n.colorLocked).toString()+JSON.stringify(n.anchorPoint)+n.anchorPointUnits+JSON.stringify(n.markerPlacement)+n.size.toString(),Me=(0,$.hP)(JSON.stringify(v)+ge+ce).toString();let se=x(v.primitiveName,M,"TextString",V,v.textString??"",E.QI,at.textCase);if(null==se)return;const{fontStyleName:te}=at,ie=vt+(te?"-"+te.toLowerCase():"-regular"),pe=ie;"string"==typeof se&&se.includes("[")&&at.fieldMap&&(se=(0,E.Qs)(at.fieldMap,se,at.textCase)),G.push({type:"text",templateHash:Me,materialHash:_e||"function"==typeof se||se.match(/\[(.*?)\]/)?(ye,fe,re)=>pe+"-"+(0,E.hf)(se,ye,fe,re):pe+"-"+(0,$.hP)(se),cim:at,materialOverrides:null,colorLocked:!!n.colorLocked,effects:P,alignment:A,anchorPoint:{x:n.anchorPoint?n.anchorPoint.x:0,y:n.anchorPoint?n.anchorPoint.y:0},isAbsoluteAnchorPoint:"Relative"!==n.anchorPointUnits,fontName:ie,decoration:Lt,weight:x(Wt,M,"Weight",V,Et.weight),style:x(Wt,M,"Size",V,Et.style),size:x(Wt,M,"Size",V,ne),angle:x(Wt,M,"Rotation",V,Jt),offsetX:x(Wt,M,"OffsetX",V,Qt),offsetY:x(Wt,M,"OffsetY",V,$t),horizontalAlignment:(0,E.X_)(at.horizontalAlignment),verticalAlignment:(0,E.FG)(at.verticalAlignment),text:se,color:Bt,outlineColor:ee,outlineSize:he,backgroundColor:ae,borderLineColor:me,borderLineWidth:Pe,referenceSize:Y,sizeRatio:1,markerPlacement:m})}function a(n,P,m,v,M,U,V,G,A,Y,j,rt,tt,at){const Lt=M.symbol,Et=Lt.symbolLayers;if(!Et)return;if(at)return void k(n,P,m,v,M,V,U,G,A,Y,j,rt,tt);let vt=Et.length;if(C(Et))return void function _(n,P,m,v,M,U,V,G,A,Y,j,rt,tt){const at=M.geometry,Lt=U[0],Et=U[1],vt=(0,ct.bk)(at);if(!vt)return;const Rt="Relative"!==n.anchorPointUnits,[Ht,jt,Zt]=(0,ct.UV)(vt,n.frame,n.size,n.anchorPoint,Rt),Wt={type:"sdf",geom:at,asFill:!0},ne=n.primitiveName,Jt=(0,E.NA)(n.size),Qt=(0,E.NA)(n.rotation),$t=(0,E.NA)(n.offsetX),Bt=(0,E.NA)(n.offsetY),ee=Et.path,he=Et.primitiveName,ae=Lt.primitiveName,me=(0,E.NO)((0,E.W7)(Et)),Pe=(0,E.NO)((0,E.$Z)(Lt)),_e=(0,E.F)(Lt)??0;let ce=!1,ge="";for(const ie of V)ie.primitiveName!==he&&ie.primitiveName!==ae&&ie.primitiveName!==ne||(void 0!==ie.value?ge+=`-${ie.primitiveName}-${ie.propertyName}-${JSON.stringify(ie.value)}`:ie.valueExpressionInfo&&(ce=!0));(0,L.pC)(m)&&"function"==typeof m&&(ce=!0);const Me=JSON.stringify({...n,markerGraphics:null}),se=(0,$.hP)(JSON.stringify(Wt)+ee).toString(),te={type:"marker",templateHash:(0,$.hP)(JSON.stringify(M)+JSON.stringify(Et)+JSON.stringify(Lt)+Me+ge).toString(),materialHash:ce?()=>se:se,cim:Wt,materialOverrides:null,colorLocked:!!n.colorLocked,effects:P,scaleSymbolsProportionally:!!n.scaleSymbolsProportionally,alignment:j,anchorPoint:{x:jt,y:Zt},isAbsoluteAnchorPoint:Rt,size:x(n.primitiveName,G,"Size",A,Jt),rotation:x(n.primitiveName,G,"Rotation",A,Qt),offsetX:x(n.primitiveName,G,"OffsetX",A,$t),offsetY:x(n.primitiveName,G,"OffsetY",A,Bt),scaleX:1,frameHeight:tt,rotateClockwise:!!n.rotateClockwise,referenceSize:rt,sizeRatio:Ht,color:x(he,G,"Color",A,me,F),outlineColor:x(ae,G,"Color",A,Pe,F),outlineWidth:x(ae,G,"Width",A,_e),markerPlacement:m,path:ee,animatedSymbolProperties:v};Y.push(te)}(n,P,m,v,M,Et,U,V,G,A,j,rt,tt);const Rt=St.j.applyEffects(Lt.effects,M.geometry,Y.geometryEngine);if(Rt)for(;vt--;){const Ht=Et[vt];if(Ht&&!1!==Ht.enable)switch(Ht.type){case"CIMSolidFill":case"CIMSolidStroke":{const jt=St.j.applyEffects(Ht.effects,Rt,Y.geometryEngine),Zt=(0,ct.bk)(jt);if(!Zt)continue;const Wt="Relative"!==n.anchorPointUnits,[ne,Jt,Qt]=(0,ct.UV)(Zt,n.frame,n.size,n.anchorPoint,Wt),$t="CIMSolidFill"===Ht.type,Bt={type:"sdf",geom:jt,asFill:$t},ee=n.primitiveName,he=(0,E.NA)(n.size)??10,ae=(0,E.NA)(n.rotation),me=(0,E.NA)(n.offsetX),Pe=(0,E.NA)(n.offsetY),_e=Ht.path,ce=Ht.primitiveName,ge=(0,E.NO)($t?(0,E.W7)(Ht):(0,E.$Z)(Ht)),Me=$t?{r:0,g:0,b:0,a:0}:(0,E.NO)((0,E.$Z)(Ht)),se=(0,E.F)(Ht)??0;if(!$t&&!se)break;let te=!1,ie="";for(const re of U)re.primitiveName!==ce&&re.primitiveName!==ee||(void 0!==re.value?ie+=`-${re.primitiveName}-${re.propertyName}-${JSON.stringify(re.value)}`:re.valueExpressionInfo&&(te=!0));((0,L.pC)(P)&&"function"==typeof P||(0,L.pC)(m)&&"function"==typeof m)&&(te=!0);const pe=JSON.stringify({...n,markerGraphics:null}),ye=(0,$.hP)(JSON.stringify(Bt)+_e).toString(),fe={type:"marker",templateHash:(0,$.hP)(JSON.stringify(M)+JSON.stringify(Ht)+pe+ie).toString(),materialHash:te?()=>ye:ye,cim:Bt,materialOverrides:null,colorLocked:!!n.colorLocked,effects:P,scaleSymbolsProportionally:!!n.scaleSymbolsProportionally,alignment:j,anchorPoint:{x:Jt,y:Qt},isAbsoluteAnchorPoint:Wt,size:x(n.primitiveName,V,"Size",G,he),rotation:x(n.primitiveName,V,"Rotation",G,ae),offsetX:x(n.primitiveName,V,"OffsetX",G,me),offsetY:x(n.primitiveName,V,"OffsetY",G,Pe),scaleX:1,frameHeight:tt,rotateClockwise:!!n.rotateClockwise,referenceSize:rt,sizeRatio:ne,color:x(ce,V,"Color",G,ge,F),outlineColor:x(ce,V,"Color",G,Me,F),outlineWidth:x(ce,V,"Width",G,se),markerPlacement:m,animatedSymbolProperties:v,path:_e};A.push(fe);break}default:k(n,P,m,v,M,V,U,G,A,Y,j,rt,tt)}}}function k(n,P,m,v,M,U,V,G,A,Y,j,rt,tt){const at=function b(n,P){return{type:n.type,enable:!0,name:n.name,colorLocked:n.colorLocked,primitiveName:n.primitiveName,anchorPoint:n.anchorPoint,anchorPointUnits:n.anchorPointUnits,offsetX:0,offsetY:0,rotateClockwise:n.rotateClockwise,rotation:0,size:n.size,billboardMode3D:n.billboardMode3D,depth3D:n.depth3D,frame:n.frame,markerGraphics:[P],scaleSymbolsProportionally:n.scaleSymbolsProportionally,respectFrame:n.respectFrame,clippingPath:n.clippingPath}}(n,M),Lt=["Rotation","OffsetX","OffsetY"],Et=V.filter(Bt=>Bt.primitiveName!==n.primitiveName||!Lt.includes(Bt.propertyName));let vt="";for(const Bt of V)void 0!==Bt.value&&(vt+=`-${Bt.primitiveName}-${Bt.propertyName}-${JSON.stringify(Bt.value)}`);const[Rt,Ht,jt]=ht.B$.getTextureAnchor(at,Y),Zt=n.primitiveName,Wt=(0,E.NA)(n.rotation),ne=(0,E.NA)(n.offsetX),Jt=(0,E.NA)(n.offsetY),Qt=(0,$.hP)(JSON.stringify(at)+vt).toString(),$t={type:"marker",templateHash:Qt,materialHash:Et.length>0||(0,L.pC)(P)&&"function"==typeof P?g(Qt,U,Et,G):Qt,cim:at,materialOverrides:Et,colorLocked:!!n.colorLocked,effects:P,scaleSymbolsProportionally:!!n.scaleSymbolsProportionally,alignment:j,anchorPoint:{x:Rt,y:Ht},isAbsoluteAnchorPoint:!1,size:(0,E.NA)(n.size),rotation:x(Zt,U,"Rotation",G,Wt),offsetX:x(Zt,U,"OffsetX",G,ne),offsetY:x(Zt,U,"OffsetY",G,Jt),color:{r:255,g:255,b:255,a:1},outlineColor:{r:0,g:0,b:0,a:0},outlineWidth:0,scaleX:1,frameHeight:tt,rotateClockwise:!!n.rotateClockwise,referenceSize:rt,sizeRatio:jt/(0,ut.F2)(n.size),markerPlacement:m,animatedSymbolProperties:v,avoidSDFRasterization:!0};A.push($t)}function I(n){if(n&&0===n.indexOf("Level_")){const P=parseInt(n.substr(6),10);if(!isNaN(P))return P}return 0}function F(n){if(!n||0===n.length)return null;const P=new it.Z(n).toRgba();return{r:P[0],g:P[1],b:P[2],a:P[3]}}function x(n,P,m,v,M,U,V){if(null==n)return M;const G=P[n];if(G){const A=G[m];if("string"==typeof A||"number"==typeof A||A instanceof Array)return U?U.call(null,A,V):A;if(null!=A&&A instanceof st.mz&&v?.geometryType)return(Y,j,rt)=>{let tt=(0,Ct.Z)(A,Y,{$view:rt},v.geometryType,j);return null!==tt&&U&&(tt=U.call(null,tt,V)),null!==tt?tt:M}}return M}function q(n){return n&&n.charAt(0).toLowerCase()+n.substr(1)}function gt(n,P,m,v){for(const M of P)if(M.valueExpressionInfo&&v?.geometryType){const U=m[M.primitiveName]&&m[M.primitiveName][M.propertyName];U instanceof st.mz&&(M.fn=(V,G,A)=>(0,Ct.Z)(U,V,{$view:A},v.geometryType,G))}return(M,U,V)=>{for(const A of P)A.fn&&(A.value=A.fn(M,U,V));const G=[];for(let A of n){const Y=A?.primitiveName;if(Y){let j=!1;for(const rt of P)if(rt.primitiveName===Y){const tt=q(rt.propertyName);null!=rt.value&&rt.value!==A[tt]&&(j||(A=(0,ft.d9)(A),j=!0),A[tt]=rt.value)}}G.push(A)}return G}}function O(n,P,m,v){const M=[];if(ht.E0.findApplicableOverrides(n,P,M),null==n||0===M.length)return n;for(const U of M)if(U.valueExpressionInfo&&v?.geometryType){const V=m[U.primitiveName]&&m[U.primitiveName][U.propertyName];V instanceof st.mz&&(U.fn=(G,A,Y)=>(0,Ct.Z)(V,G,{$view:Y},v.geometryType,A))}return(U,V,G)=>{for(const j of M)j.fn&&(j.value=j.fn(U,V,G));const A=(0,ft.d9)(n),Y=n.primitiveName;for(const j of M)if(j.primitiveName===Y){const rt=q(j.propertyName);null!=j.value&&j.value!==A[rt]&&(A[rt]=j.value)}return A}}function g(n,P,m,v){for(const M of m)if(M.valueExpressionInfo&&v?.geometryType){const U=P[M.primitiveName]&&P[M.primitiveName][M.propertyName];U instanceof st.mz&&(M.fn=(V,G,A)=>(0,Ct.Z)(U,V,{$view:A},v.geometryType,G))}return(M,U,V)=>{for(const G of m)G.fn&&(G.value=G.fn(M,U,V));return(0,$.hP)(n+ht.E0.buildOverrideKey(m)).toString()}}function S(n,P){if(!P||0===P.length)return n;const m=(0,ft.d9)(n);return ht.E0.applyOverrides(m,P),m}function w(n,P,m,v,M){let U=!1,V="";for(const G of n)G.primitiveName===P&&(void 0!==G.value?V+=`-${G.primitiveName}-${G.propertyName}-${JSON.stringify(G.value)}`:G.valueExpressionInfo&&(U=!0));return(0,L.pC)(m)&&"function"==typeof m&&(U=!0),(0,L.pC)(v)&&"function"==typeof v&&(U=!0),(0,L.pC)(M)&&"function"==typeof M&&(U=!0),[U,V]}const C=n=>n&&2===n.length&&n[0].enable&&n[1].enable&&"CIMSolidStroke"===n[0].type&&"CIMSolidFill"===n[1].type&&!n[0].effects&&!n[1].effects},73608:(ue,Yt,W)=>{W.d(Yt,{j:()=>L});var Ot=W(91179),it=W(72283),_t=W(29214),ft=W(95727);class L{static executeEffects($,st,ht,Z){const Pt=(0,it.GP)(st);let N=new _t.MU(Pt);for(const D of $){const ct=(0,ft.h)(D);ct&&(N=ct.execute(N,D,1.3333333333333333,ht,Z))}return N}static next($){const st=$.next();return(0,it.wp)(st),st}static applyEffects($,st,ht){if(!$)return st;let Z=new _t.MU(st);for(const N of $){const D=(0,ft.h)(N);D&&(Z=D.execute(Z,N,1,null,ht))}let Pt,wt=null;for(;Pt=Z.next();)wt?(0,Ot.l9)(wt)?(0,Ot.l9)(Pt)&&wt.paths.push(...Pt.paths):(0,Ot.oU)(wt)&&(0,Ot.oU)(Pt)&&wt.rings.push(...Pt.rings):wt=Pt;return wt}}},3959:(ue,Yt,W)=>{W.d(Yt,{$:()=>_t,f:()=>it});var Ot=W(77275);function it(L,ut){let $;if("string"==typeof L)$=(0,Ot.hP)(L+`-seed(${ut})`);else{let st=12;$=L^ut;do{$=107*($>>8^$)+st|0}while(0!=--st)}return(1+$/(1<<31))/2}function _t(L){return Math.floor(it(L,ft)*Ft)}const ft=53290320,Ft=10},25797:(ue,Yt,W)=>{W.d(Yt,{Nr:()=>At});var Ot=W(23841),it=W(31478),_t=W(12225),ft=W(67831),Ft=W(9545),L=W(40028),ut=W(5254),$=W(84439);class st{constructor(H,Q,B,K){this.center=(0,Ft.f)(H,Q),this.centerT=(0,Ft.c)(),this.halfWidth=B/2,this.halfHeight=K/2,this.width=B,this.height=K}get x(){return this.center[0]}get y(){return this.center[1]}get blX(){return this.center[0]+this.halfWidth}get blY(){return this.center[1]+this.halfHeight}get trX(){return this.center[0]-this.halfWidth}get trY(){return this.center[1]-this.halfHeight}get xmin(){return this.x-this.halfWidth}get xmax(){return this.x+this.halfWidth}get ymin(){return this.y-this.halfHeight}get ymax(){return this.y+this.halfHeight}set x(H){this.center[0]=H}set y(H){this.center[1]=H}clone(){return new st(this.x,this.y,this.width,this.height)}serialize(H){return H.writeF32(this.center[0]),H.writeF32(this.center[1]),H.push(this.width),H.push(this.height),H}findCollisionDelta(H,Q=4){const B=Math.abs(H.centerT[0]-this.centerT[0]),K=Math.abs(H.centerT[1]-this.centerT[1]),Tt=Math.min((H.halfWidth+this.halfWidth+Q)/B,(H.halfHeight+this.halfHeight+Q)/K);return Math.log2(Tt)}extend(H){const Q=Math.min(this.xmin,H.xmin),B=Math.min(this.ymin,H.ymin),K=Math.max(this.xmax,H.xmax)-Q,nt=Math.max(this.ymax,H.ymax)-B,pt=Q+K/2,Tt=B+nt/2;this.width=K,this.height=nt,this.halfWidth=K/2,this.halfHeight=nt/2,this.x=pt,this.y=Tt}static deserialize(H){const Q=H.readF32(),B=H.readF32(),K=H.readInt32(),nt=H.readInt32();return new st(Q,B,K,nt)}}const ct=Math.PI/180;class Ct{constructor(H,Q,B,K){this._rotationT=(0,_t.c)(),this._xBounds=0,this._yBounds=0,this.minZoom=0,this.maxZoom=255,this._bounds=null;const nt=B.rect,pt=new Float32Array(8);H*=K,Q*=K;const Tt=B.code?nt.width*K:B.metrics.width,It=B.code?nt.height*K:B.metrics.height;this.width=Tt,this.height=It,pt[0]=H,pt[1]=Q,pt[2]=H+Tt,pt[3]=Q,pt[4]=H,pt[5]=Q+It,pt[6]=H+Tt,pt[7]=Q+It,this._data=pt,this._setTextureCoords(nt),this._scale=K,this._mosaic=B,this.x=H,this.y=Q,this.maxOffset=Math.max(H+Tt,Q+It)}get mosaic(){return this._mosaic}set angle(H){this._angle=H,(0,it.b)(this._rotationT,-H),this._setOffsets(this._data)}get angle(){return this._angle}get xTopLeft(){return this._data[0]}get yTopLeft(){return this._data[1]}get xBottomRight(){return this._data[6]}get yBottomRight(){return this._data[7]}get texcoords(){return this._texcoords}get textureBinding(){return this._mosaic.textureBinding}get offsets(){return this._offsets||this._setOffsets(this._data),this._offsets}get char(){return String.fromCharCode(this._mosaic.code)}get code(){return this._mosaic.code}get bounds(){if(!this._bounds){const{height:H,width:Q}=this._mosaic.metrics,B=Q*this._scale,K=Math.abs(H)*this._scale,nt=new Float32Array(8);nt[0]=this.x,nt[1]=this.y,nt[2]=this.x+B,nt[3]=this.y,nt[4]=this.x,nt[5]=this.y+K,nt[6]=this.x+B,nt[7]=this.y+K;const pt=(0,it.m)((0,_t.c)(),this._rotationT,this._transform);(0,_t.t)(nt,nt,pt);let Tt=1/0,It=1/0,Gt=0,Xt=0;for(let b=0;b<4;b++){const I=nt[2*b],F=nt[2*b+1];Tt=Math.min(Tt,I),It=Math.min(It,F),Gt=Math.max(Gt,I),Xt=Math.max(Xt,F)}const ot=Gt-Tt,a=Xt-It;this._bounds=new st(Tt+ot/2,It+a/2,ot,a)}return this._bounds}setTransform(H){this._transform=H,this._offsets=null}_setOffsets(H){this._offsets||(this._offsets={upperLeft:0,upperRight:0,lowerLeft:0,lowerRight:0});const Q=this._offsets,B=new Float32Array(8),K=(0,it.m)((0,_t.c)(),this._rotationT,this._transform);(0,_t.t)(B,H,K),Q.upperLeft=(0,ut.UJ)(8*B[0],8*B[1]),Q.upperRight=(0,ut.UJ)(8*B[2],8*B[3]),Q.lowerLeft=(0,ut.UJ)(8*B[4],8*B[5]),Q.lowerRight=(0,ut.UJ)(8*B[6],8*B[7])}_setTextureCoords({x:H,y:Q,width:B,height:K}){this._texcoords={upperLeft:(0,ut.UJ)(H,Q),upperRight:(0,ut.UJ)(H+B,Q),lowerLeft:(0,ut.UJ)(H,Q+K),lowerRight:(0,ut.UJ)(H+B,Q+K)}}}const xt=(mt,H)=>({code:0,page:0,sdf:!0,rect:new $.Z(0,0,11,8),textureBinding:H,metrics:{advance:0,height:4,width:mt,left:0,top:0}});function kt(mt,H){return mt.forEach(Q=>(0,ft.t)(Q,Q,H)),{upperLeft:(0,ut.UJ)(8*mt[0][0],8*mt[0][1]),upperRight:(0,ut.UJ)(8*mt[1][0],8*mt[1][1]),lowerLeft:(0,ut.UJ)(8*mt[2][0],8*mt[2][1]),lowerRight:(0,ut.UJ)(8*mt[3][0],8*mt[3][1])}}class zt{constructor(H,Q,B){this._rotation=0,this._decorate(H,Q,B),this.glyphs=H,this.bounds=this._createBounds(H),this.isMultiline=Q.length>1,this._hasRotation=0!==B.angle,this._transform=this._createGlyphTransform(this.bounds,B),this._borderLineSize=B.borderLineSize,(B.borderLineSize||B.hasBackground)&&([this.bounds,this.background]=this.shapeBackground(this._transform));for(const K of H)K.setTransform(this._transform)}setRotation(H){if(0===H&&0===this._rotation)return;this._rotation=H;const Q=this._transform,B=(0,it.b)((0,_t.c)(),H);(0,it.m)(Q,B,Q);for(const K of this.glyphs)K.setTransform(this._transform)}_decorate(H,Q,B){if(!B.decoration||"none"===B.decoration||!H.length)return;const K=B.scale,nt="underline"===B.decoration?30:20,pt=H[0].textureBinding;for(const Tt of Q)H.push(new Ct(Tt.startX*K,Tt.startY*K+nt*K,xt((Tt.width+Tt.glyphWidthEnd)*K,pt),1))}shapeBackground(H){const B=(1.5+(0,Ot.F2)(this._borderLineSize||0))/2,K=this._borderLineSize?B:0,{xmin:nt,ymin:pt,xmax:Tt,ymax:It,x:Gt,y:Xt,width:ot,height:a}=this.bounds,_=[nt-8,pt-8],k=[Tt+8,pt-8],b=[nt-8,It+8],I=[Tt+8,It+8],F=kt([[_[0]-B,_[1]-B],[k[0]+B,k[1]-B],[_[0]+K,_[1]+K],[k[0]-K,k[1]+K]],H),x=kt([[b[0]+K,b[1]-K],[I[0]-K,I[1]-K],[b[0]-B,b[1]+B],[I[0]+B,I[1]+B]],H),q=kt([[_[0]-B,_[1]-B],[_[0]+K,_[1]+K],[b[0]-B,b[1]+B],[b[0]+K,b[1]-K]],H),gt=kt([[k[0]-K,k[1]+K],[k[0]+B,k[1]-B],[I[0]-K,I[1]-K],[I[0]+B,I[1]+B]],H),O={main:kt([_,k,b,I],H),top:F,bot:x,left:q,right:gt};return[new st(Gt,Xt,ot+2*B,a+2*B),O]}get boundsT(){const H=this.bounds,Q=(0,ft.s)((0,Ft.c)(),H.x,H.y);if((0,ft.t)(Q,Q,this._transform),this._hasRotation){const B=Math.max(H.width,H.height);return new st(Q[0],Q[1],B,B)}return new st(Q[0],Q[1],H.width,H.height)}_createBounds(H){let Q=1/0,B=1/0,K=0,nt=0;for(const It of H)Q=Math.min(Q,It.xTopLeft),B=Math.min(B,It.yTopLeft),K=Math.max(K,It.xBottomRight),nt=Math.max(nt,It.yBottomRight);const pt=K-Q,Tt=nt-B;return new st(Q+pt/2,B+Tt/2,pt,Tt)}_createGlyphTransform(H,Q){const B=ct*Q.angle,K=(0,_t.c)(),nt=(0,Ft.c)();return(0,it.t)(K,K,(0,ft.s)(nt,Q.xOffset,-Q.yOffset)),Q.isCIM?(0,it.r)(K,K,B):((0,it.t)(K,K,(0,ft.s)(nt,H.x,H.y)),(0,it.r)(K,K,B),(0,it.t)(K,K,(0,ft.s)(nt,-H.x,-H.y))),K}}class R{constructor(H,Q,B,K,nt,pt){this.glyphWidthEnd=0,this.startX=0,this.startY=0,this.start=Math.max(0,Math.min(Q,B)),this.end=Math.max(0,Math.max(Q,B)),this.end<H.length&&(this.glyphWidthEnd=H[this.end].metrics.width),this.width=K,this.yMin=nt,this.yMax=pt}}const et=mt=>10===mt,yt=mt=>32===mt;function At(mt,H,Q){const B=Q.scale,K=new Array,nt=function Nt(mt,H,Q){const B=new Array,nt=Q.maxLineWidth*(1/Q.scale),pt=H?mt.length-1:0,Tt=H?-1:mt.length,It=H?-1:1;let Gt=pt,Xt=0,ot=0,a=Gt,_=a,k=0,b=1/0,I=0;for(;Gt!==Tt;){const{code:x,metrics:q}=mt[Gt],gt=Math.abs(q.top);et(x)||yt(x)||(b=Math.min(b,gt),I=Math.max(I,gt+q.height)),et(x)?(Gt!==pt&&(B.push(new R(mt,a,Gt-It,Xt,b,I)),b=1/0,I=0),Xt=0,a=Gt+It,_=Gt+It,ot=0):yt(x)?(_=Gt+It,ot=0,k=q.advance,Xt+=q.advance):Xt>nt?(_!==a?(Xt-=k,B.push(new R(mt,a,_-2*It,Xt-ot,b,I)),b=1/0,I=0,a=_,Xt=ot):(B.push(new R(mt,a,Gt-It,Xt,b,I)),b=1/0,I=0,a=Gt,_=Gt,Xt=0),Xt+=q.advance,ot+=q.advance):(Xt+=q.advance,ot+=q.advance),Gt+=It}const F=new R(mt,a,Gt-It,Xt,b,I);return F.start>=0&&F.end<mt.length&&B.push(F),B}(mt,H,Q),pt=function dt(mt,H){let Q=0;for(let nt=0;nt<mt.length;nt++){const{width:pt}=mt[nt];Q=Math.max(pt,Q)}const K=mt[0].yMin;return{x:0,y:K,height:mt[mt.length-1].yMax+H.lineHeight*(mt.length-1)+("underline"===H.decoration?4:0)-K,width:Q}}(nt,Q),{vAlign:Tt,hAlign:It}=Q,Gt=Tt===L.TR.Baseline?1:0,ot=(1-Gt)*-pt.y+pt.height/2*(Gt?0:Tt-1)+-26*(Gt?1:0);for(let a=0;a<nt.length;a++){const{start:_,end:k,width:b}=nt[a];let I=-1*(It+1)*(b/2)-3;const F=a*Q.lineHeight+ot-3;nt[a].startX=I,nt[a].startY=F;for(let x=_;x<=k;x++){const q=mt[x];if(et(q.code))continue;const gt=new Ct(I+q.metrics.left,F-q.metrics.top,q,B);I+=q.metrics.advance,K.push(gt)}}return new zt(K,nt,Q)}}}]);