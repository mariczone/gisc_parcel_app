"use strict";(self.webpackChunkparcel_app=self.webpackChunkparcel_app||[]).push([[2585],{89652:(Ve,Ee,a)=>{a.d(Ee,{C:()=>se,b:()=>F});var m=a(52382),_=a(13934),g=a(78925),b=a(24255),q=a(23164),M=a(58173),c=a(54120),V=a(62952),H=a(10109),W=a(67022),x=a(33726),$=a(99198),X=a(69960),O=a(17625),U=a(22355),ce=a(44835),ye=a(16396);function F(te){const k=new U.kG,{vertex:y,fragment:I}=k,B=te.output===_.H.Depth,L=te.hasMultipassTerrain&&(te.output===_.H.Color||te.output===_.H.Alpha);return(0,$.Sv)(y,te),k.include(b.w,te),k.include(M.c,te),k.include(q.R,te),k.attributes.add(ye.T.POSITION,"vec3"),k.varyings.add("vpos","vec3"),L&&k.varyings.add("depth","float"),B&&(k.include(c.F,te),(0,m.Zu)(k),(0,m.Lm)(k)),y.code.add(O.H`
    void main(void) {
      vpos = position;
      forwardNormalizedVertexColor();
      forwardObjectAndLayerIdColor();
      ${L?"depth = (view * vec4(vpos, 1.0)).z;":""}
      gl_Position = ${B?O.H`transformPositionWithDepth(proj, view, vpos, nearFar, linearDepth);`:O.H`transformPosition(proj, view, vpos);`}
    }
  `),k.include(g.f5,te),L&&k.include(H.l,te),I.include(x.Y),I.uniforms.add(new X.N("eColor",Y=>Y.color)),te.output===_.H.Highlight&&k.include(V.bA,te),I.code.add(O.H`
  void main() {
    discardBySlice(vpos);
    ${L?"terrainDepthTest(gl_FragCoord, depth);":""}
    vec4 fColor = ${te.hasVertexColors?"vColor * eColor;":"eColor;"}

    ${te.output===_.H.ObjectAndLayerIdColor?O.H`fColor.a = 1.0;`:""}

    if (fColor.a < ${O.H.float(W.b)}) {
      discard;
    }

    ${te.output===_.H.Alpha?O.H`gl_FragColor = vec4(fColor.a);`:""}

    ${te.output===_.H.Color?O.H`gl_FragColor = highlightSlice(fColor, vpos); ${te.transparencyPassType===ce.A.Color?"gl_FragColor = premultiplyAlpha(gl_FragColor);":""}`:""}
    ${te.output===_.H.Highlight?O.H`outputHighlight();`:""};
    ${te.output===_.H.Depth?O.H`outputDepth(linearDepth);`:""};
    ${te.output===_.H.ObjectAndLayerIdColor?O.H`outputObjectAndLayerIdColor();`:""}
  }
  `),k}const se=Object.freeze(Object.defineProperty({__proto__:null,build:F},Symbol.toStringTag,{value:"Module"}))},6467:(Ve,Ee,a)=>{a.d(Ee,{H:()=>v,b:()=>Q,c:()=>C});var m=a(62208),_=a(67831),g=a(99770),b=a(4794),q=a(8782),M=a(13934),c=a(78925),V=a(23164),H=a(35283),W=a(3090),x=a(27776),$=a(62952),X=a(92836),O=a(67022),U=a(33726),ce=a(19278),ye=a(71850),F=a(95285),se=a(69960),te=a(48565),k=a(65787),y=a(7090),I=a(17625),B=a(22355),L=a(35387),Y=a(44835),P=a(16396),T=a(41857);function Q(E){const K=new B.kG,ue=E.signedDistanceFieldEnabled;if(K.include(H.H),K.include(W.R,E),K.include(c.f5,E),E.occlusionPass)return K.include(x.R,E),K;const{vertex:Me,fragment:Le}=K;K.include(ye.cK),Le.include(ce.n),Le.include(U.Y),K.include(X.k,E),K.include(V.R,E),K.varyings.add("vcolor","vec4"),K.varyings.add("vtc","vec2"),K.varyings.add("vsize","vec2"),E.binaryHighlightOcclusionEnabled&&K.varyings.add("voccluded","float"),Me.uniforms.add([new se.N("viewport",(Ge,tt)=>tt.camera.fullViewport),new F.A("screenOffset",(Ge,tt)=>(0,_.s)(ie,2*Ge.screenOffset[0]*tt.camera.pixelRatio,2*Ge.screenOffset[1]*tt.camera.pixelRatio)),new F.A("anchorPosition",Ge=>C(Ge)),new se.N("materialColor",Ge=>Ge.color),new k.p("pixelRatio",(Ge,tt)=>tt.camera.pixelRatio)]),ue&&(Me.uniforms.add(new se.N("outlineColor",Ge=>Ge.outlineColor)),Le.uniforms.add([new se.N("outlineColor",Ge=>w(Ge)?Ge.outlineColor:b.Z),new k.p("outlineSize",Ge=>w(Ge)?Ge.outlineSize:0)])),E.hasScreenSizePerspective&&((0,ye.ww)(Me),(0,ye.m8)(Me)),(E.debugDrawLabelBorder||E.binaryHighlightOcclusionEnabled)&&K.varyings.add("debugBorderCoords","vec4"),K.attributes.add(P.T.UV0,"vec2"),K.attributes.add(P.T.COLOR,"vec4"),K.attributes.add(P.T.SIZE,"vec2"),K.attributes.add(P.T.AUXPOS2,"vec4"),Me.code.add(I.H`
    void main(void) {
      ProjectHUDAux projectAux;
      vec4 posProj = projectPositionHUD(projectAux);
      forwardObjectAndLayerIdColor();

      if (rejectBySlice(projectAux.posModel)) {
        // Project outside of clip plane
        gl_Position = vec4(1e038, 1e038, 1e038, 1.0);
        return;
      }
      vec2 inputSize;
      ${E.hasScreenSizePerspective?I.H`
      inputSize = screenSizePerspectiveScaleVec2(size, projectAux.absCosAngle, projectAux.distanceToCamera, screenSizePerspective);
      vec2 screenOffsetScaled = screenSizePerspectiveScaleVec2(screenOffset, projectAux.absCosAngle, projectAux.distanceToCamera, screenSizePerspectiveAlignment);
         `:I.H`
      inputSize = size;
      vec2 screenOffsetScaled = screenOffset;`}

      ${E.vvSize?"inputSize *= vvScale(auxpos2).xx;":""}

      vec2 combinedSize = inputSize * pixelRatio;
      vec4 quadOffset = vec4(0.0);

      ${E.occlusionTestEnabled||E.binaryHighlightOcclusionEnabled?"bool visible = testVisibilityHUD(posProj);":""}

      ${E.binaryHighlightOcclusionEnabled?"voccluded = visible ? 0.0 : 1.0;":""}
    `);const Fe=I.H`vec2 uv01 = floor(uv0);
vec2 uv = uv0 - uv01;
quadOffset.xy = ((uv01 - anchorPosition) * 2.0 * combinedSize + screenOffsetScaled) / viewport.zw * posProj.w;`,He=E.pixelSnappingEnabled?ue?I.H`posProj = alignToPixelOrigin(posProj, viewport.zw) + quadOffset;`:I.H`posProj += quadOffset;
if (inputSize.x == size.x) {
posProj = alignToPixelOrigin(posProj, viewport.zw);
}`:I.H`posProj += quadOffset;`;E.vvColor&&Me.uniforms.add([new te.b("vvColorColors",Ge=>Ge.vvColorColors,T.x),new y.O("vvColorValues",Ge=>Ge.vvColorValues,T.x)]),Me.uniforms.add(new F.A("textureCoordinateScaleFactor",Ge=>(0,m.pC)(Ge.texture)&&(0,m.pC)(Ge.texture.descriptor.textureCoordinateScaleFactor)?Ge.texture.descriptor.textureCoordinateScaleFactor:g.O)),Me.code.add(I.H`
    ${E.occlusionTestEnabled?"if (visible) {":""}
    ${Fe}
    ${E.vvColor?"vcolor = vvGetColor(auxpos2, vvColorValues, vvColorColors) * materialColor;":"vcolor = color / 255.0 * materialColor;"}

    ${E.output===M.H.ObjectAndLayerIdColor?I.H`vcolor.a = 1.0;`:""}

    bool alphaDiscard = vcolor.a < ${I.H.float(O.b)};
    ${ue?`alphaDiscard = alphaDiscard && outlineColor.a < ${I.H.float(O.b)};`:""}
    if (alphaDiscard) {
      // "early discard" if both symbol color (= fill) and outline color (if applicable) are transparent
      gl_Position = vec4(1e38, 1e38, 1e38, 1.0);
      return;
    } else {
      ${He}
      gl_Position = posProj;
    }

    vtc = uv * textureCoordinateScaleFactor;

    ${E.debugDrawLabelBorder?"debugBorderCoords = vec4(uv01, 1.5 / combinedSize);":""}
    vsize = inputSize;
    ${E.occlusionTestEnabled?I.H`} else { vtc = vec2(0.0);
      ${E.debugDrawLabelBorder?"debugBorderCoords = vec4(0.5, 0.5, 1.5 / combinedSize);}":"}"}`:""}
  }
  `),Le.uniforms.add(new L.A("tex",Ge=>Ge.texture));const Ke=E.debugDrawLabelBorder?I.H`(isBorder > 0.0 ? 0.0 : ${I.H.float(O.F)})`:I.H.float(O.F),Xe=I.H`
    ${E.debugDrawLabelBorder?I.H`
      float isBorder = float(any(lessThan(debugBorderCoords.xy, debugBorderCoords.zw)) || any(greaterThan(debugBorderCoords.xy, 1.0 - debugBorderCoords.zw)));`:""}

    ${ue?I.H`
      vec4 fillPixelColor = vcolor;

      // Attempt to sample texel centers to avoid that thin cross outlines
      // disappear with large symbol sizes.
      // see: https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/7058#issuecomment-603041
      const float txSize = ${I.H.float(q.Ph)};
      const float texelSize = 1.0 / txSize;
      // Calculate how much we have to add/subtract to/from each texel to reach the size of an onscreen pixel
      vec2 scaleFactor = (vsize - txSize) * texelSize;
      vec2 samplePos = vtc + (vec2(1.0, -1.0) * texelSize) * scaleFactor;

      // Get distance and map it into [-0.5, 0.5]
      float d = rgba2float(texture2D(tex, samplePos)) - 0.5;

      // Distance in output units (i.e. pixels)
      float dist = d * vsize.x;

      // Create smooth transition from the icon into its outline
      float fillAlphaFactor = clamp(0.5 - dist, 0.0, 1.0);
      fillPixelColor.a *= fillAlphaFactor;

      if (outlineSize > 0.25) {
        vec4 outlinePixelColor = outlineColor;
        float clampedOutlineSize = min(outlineSize, 0.5*vsize.x);

        // Create smooth transition around outline
        float outlineAlphaFactor = clamp(0.5 - (abs(dist) - 0.5*clampedOutlineSize), 0.0, 1.0);
        outlinePixelColor.a *= outlineAlphaFactor;

        if (
          outlineAlphaFactor + fillAlphaFactor < ${Ke} ||
          fillPixelColor.a + outlinePixelColor.a < ${I.H.float(O.b)}
        ) {
          discard;
        }

        // perform un-premultiplied over operator (see https://en.wikipedia.org/wiki/Alpha_compositing#Description)
        float compositeAlpha = outlinePixelColor.a + fillPixelColor.a * (1.0 - outlinePixelColor.a);
        vec3 compositeColor = vec3(outlinePixelColor) * outlinePixelColor.a +
          vec3(fillPixelColor) * fillPixelColor.a * (1.0 - outlinePixelColor.a);

        gl_FragColor = vec4(compositeColor, compositeAlpha);
      } else {
        if (fillAlphaFactor < ${Ke}) {
          discard;
        }

        gl_FragColor = premultiplyAlpha(fillPixelColor);
      }

      // visualize SDF:
      // gl_FragColor = vec4(clamp(-dist/vsize.x*2.0, 0.0, 1.0), clamp(dist/vsize.x*2.0, 0.0, 1.0), 0.0, 1.0);
      `:I.H`
          vec4 texColor = texture2D(tex, vtc, -0.5);
          if (texColor.a < ${Ke}) {
            discard;
          }
          gl_FragColor = texColor * premultiplyAlpha(vcolor);
          `}

    // Draw debug border with transparency, so that original texels along border are still partially visible
    ${E.debugDrawLabelBorder?I.H`gl_FragColor = mix(gl_FragColor, vec4(1.0, 0.0, 1.0, 1.0), isBorder * 0.5);`:""}
  `;return E.output===M.H.Alpha&&Le.code.add(I.H`
      void main() {
        ${Xe}
        gl_FragColor = vec4(gl_FragColor.a);
      }
      `),E.output===M.H.ObjectAndLayerIdColor&&Le.code.add(I.H`
      void main() {
        ${Xe}
        outputObjectAndLayerIdColor();
      }
      `),E.output===M.H.Color&&Le.code.add(I.H`
    void main() {
      ${Xe}
      ${E.transparencyPassType===Y.A.FrontFace?"gl_FragColor.rgb /= gl_FragColor.a;":""}
    }
    `),E.output===M.H.Highlight&&(K.include($.bA,E),Le.code.add(I.H`
    void main() {
      ${Xe}
      ${E.binaryHighlightOcclusionEnabled?I.H`
          if (voccluded == 1.0) {
            gl_FragColor = vec4(1.0, 1.0, 0.0, 1.0);
          } else {
            gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);
          }`:"outputHighlight();"}
    }
    `)),K}function w(E){return E.outlineColor[3]>0&&E.outlineSize>0}function C(E,K=ie){return E.textureIsSignedDistanceField?function J(E,K,ue){(0,m.pC)(K)?(0,_.s)(ue,E[0]*(K[2]-K[0])+K[0],E[1]*(K[3]-K[1])+K[1]):(0,_.s)(ue,0,0)}(E.anchorPosition,E.distanceFieldBoundingBox,K):(0,_.c)(K,E.anchorPosition),K}const ie=(0,g.a)(),v=Object.freeze(Object.defineProperty({__proto__:null,build:Q,calculateAnchorPosForRendering:C},Symbol.toStringTag,{value:"Module"}))},32616:(Ve,Ee,a)=>{a.d(Ee,{N:()=>U,b:()=>O});var m=a(13934),_=a(78925),g=a(24255),b=a(58173),q=a(62952),M=a(92484),c=a(67022),V=a(99198),H=a(69960),W=a(65787),x=a(17625),$=a(22355),X=a(16396);function O(ce){const ye=new $.kG,{vertex:F,fragment:se}=ye;return ye.include(g.w,ce),ye.include(b.c,ce),ye.include(M.q,ce),(0,V.Sv)(F,ce),ce.stippleEnabled&&(ye.attributes.add(X.T.UV0,"vec2"),ye.attributes.add(X.T.AUXPOS1,"vec3"),F.uniforms.add(new H.N("viewport",(te,k)=>k.camera.fullViewport))),ye.attributes.add(X.T.POSITION,"vec3"),ye.varyings.add("vpos","vec3"),F.code.add(x.H`void main(void) {
vpos = position;
forwardNormalizedVertexColor();
gl_Position = transformPosition(proj, view, vpos);`),ce.stippleEnabled&&(F.code.add(x.H`vec4 vpos2 = transformPosition(proj, view, auxpos1);
vec2 ndcToPixel = viewport.zw * 0.5;
float lineSegmentPixelSize = length((vpos2.xy / vpos2.w - gl_Position.xy / gl_Position.w) * ndcToPixel);`),ce.draped?F.uniforms.add(new W.p("worldToScreenRatio",(te,k)=>1/k.screenToPCSRatio)):F.code.add(x.H`vec3 segmentCenter = (position + auxpos1) * 0.5;
float worldToScreenRatio = computeWorldToScreenRatio(segmentCenter);`),F.code.add(x.H`float discreteWorldToScreenRatio = discretizeWorldToScreenRatio(worldToScreenRatio);`),F.code.add(ce.draped?x.H`float startPseudoScreen = uv0.y * discreteWorldToScreenRatio - mix(0.0, lineSegmentPixelSize, uv0.x);
float segmentLengthPseudoScreen = lineSegmentPixelSize;`:x.H`float segmentLengthRender = length(position - auxpos1);
float startPseudoScreen = mix(uv0.y, uv0.y - segmentLengthRender, uv0.x) * discreteWorldToScreenRatio;
float segmentLengthPseudoScreen = segmentLengthRender * discreteWorldToScreenRatio;`),F.uniforms.add(new W.p("stipplePatternPixelSize",te=>(0,M.C)(te))),F.code.add(x.H`vec2 stippleDistanceLimits = computeStippleDistanceLimits(startPseudoScreen, segmentLengthPseudoScreen, lineSegmentPixelSize, stipplePatternPixelSize);
vStippleDistance = mix(stippleDistanceLimits.x, stippleDistanceLimits.y, uv0.x);
vStippleDistance *= gl_Position.w;`)),F.code.add(x.H`}`),ce.output===m.H.Highlight&&ye.include(q.bA,ce),ye.include(_.f5,ce),se.uniforms.add(new W.p("alphaCoverage",(te,k)=>Math.min(1,te.width*k.camera.pixelRatio))),ce.hasVertexColors||se.uniforms.add(new H.N("constantColor",te=>te.color)),se.code.add(x.H`
  void main() {
    discardBySlice(vpos);

    vec4 color = ${ce.hasVertexColors?"vColor":"constantColor"};

    float stippleAlpha = getStippleAlpha();
    discardByStippleAlpha(stippleAlpha, stippleAlphaColorDiscard);

    vec4 finalColor = blendStipple(vec4(color.rgb, color.a * alphaCoverage), stippleAlpha);

    ${ce.output===m.H.ObjectAndLayerIdColor?x.H`finalColor.a = 1.0;`:""}

    if (finalColor.a < ${x.H.float(c.b)}) {
      discard;
    }

    ${ce.output===m.H.Color?x.H`gl_FragColor = highlightSlice(finalColor, vpos);`:""}
    ${ce.output===m.H.Highlight?x.H`outputHighlight();`:""}
  }
  `),ye}const U=Object.freeze(Object.defineProperty({__proto__:null,build:O},Symbol.toStringTag,{value:"Module"}))},3393:(Ve,Ee,a)=>{a.d(Ee,{R:()=>L,a:()=>P,b:()=>Y});var m=a(62208),_=a(52382),g=a(13934),b=a(78925),q=a(23164),M=a(39645),c=a(54120),V=a(92484),H=a(50823),W=a(10109),x=a(39337),$=a(67022),X=a(33726),O=a(99198),U=a(95285),ce=a(69960),ye=a(65787),F=a(17625),se=a(63123),te=a(22355),k=a(44835),y=a(16396),I=a(46359),B=a(39401);const L=1;function Y(T){const Q=new te.kG,{vertex:w,fragment:C}=Q,J=T.hasMultipassTerrain&&(T.output===g.H.Color||T.output===g.H.Alpha);Q.include(x.e),Q.include(M.U,T),Q.include(V.q,T);const ie=T.applyMarkerOffset&&!T.draped;ie&&(w.uniforms.add(new ye.p("markerScale",He=>He.markerScale)),Q.include(H.Q,{space:I.I9.World})),T.output===g.H.Depth&&Q.include(c.F,T),Q.include(q.R,T),(0,O.Sv)(w,T),w.uniforms.add([new se.g("inverseProjectionMatrix",(He,Ke)=>Ke.camera.inverseProjectionMatrix),new U.A("nearFar",(He,Ke)=>Ke.camera.nearFar),new ye.p("miterLimit",He=>"miter"!==He.join?0:He.miterLimit),new ce.N("viewport",(He,Ke)=>Ke.camera.fullViewport)]),w.constants.add("LARGE_HALF_FLOAT","float",65500),Q.attributes.add(y.T.POSITION,"vec3"),Q.attributes.add(y.T.SUBDIVISIONFACTOR,"float"),Q.attributes.add(y.T.UV0,"vec2"),Q.attributes.add(y.T.AUXPOS1,"vec3"),Q.attributes.add(y.T.AUXPOS2,"vec3"),Q.varyings.add("vColor","vec4"),Q.varyings.add("vpos","vec3"),(0,_.Lm)(Q),J&&Q.varyings.add("depth","float");const v=T.capType===B.R.ROUND,E=T.stippleEnabled&&T.stippleScaleWithLineWidth||v;E&&Q.varyings.add("vLineWidth","float");const K=T.stippleEnabled&&T.stippleScaleWithLineWidth;K&&Q.varyings.add("vLineSizeInv","float");const ue=T.innerColorEnabled||v;ue&&Q.varyings.add("vLineDistance","float");const Me=T.stippleEnabled&&v,Le=T.falloffEnabled||Me;return Le&&Q.varyings.add("vLineDistanceNorm","float"),v&&(Q.varyings.add("vSegmentSDF","float"),Q.varyings.add("vReverseSegmentSDF","float")),w.code.add(F.H`#define PERPENDICULAR(v) vec2(v.y, -v.x);
float interp(float ncp, vec4 a, vec4 b) {
return (-ncp - a.z) / (b.z - a.z);
}
vec2 rotate(vec2 v, float a) {
float s = sin(a);
float c = cos(a);
mat2 m = mat2(c, -s, s, c);
return m * v;
}`),w.code.add(F.H`vec4 projectAndScale(vec4 pos) {
vec4 posNdc = proj * pos;
posNdc.xy *= viewport.zw / posNdc.w;
return posNdc;
}`),(0,_.bA)(Q),w.code.add(F.H`
    void clipAndTransform(inout vec4 pos, inout vec4 prev, inout vec4 next, in bool isStartVertex) {
      float vnp = nearFar[0] * 0.99;

      if(pos.z > -nearFar[0]) {
        //current pos behind ncp --> we need to clip
        if (!isStartVertex) {
          if(prev.z < -nearFar[0]) {
            //previous in front of ncp
            pos = mix(prev, pos, interp(vnp, prev, pos));
            next = pos;
          } else {
            pos = vec4(0.0, 0.0, 0.0, 1.0);
          }
        } else {
          if(next.z < -nearFar[0]) {
            //next in front of ncp
            pos = mix(pos, next, interp(vnp, pos, next));
            prev = pos;
          } else {
            pos = vec4(0.0, 0.0, 0.0, 1.0);
          }
        }
      } else {
        //current position visible
        if (prev.z > -nearFar[0]) {
          //previous behind ncp
          prev = mix(pos, prev, interp(vnp, pos, prev));
        }
        if (next.z > -nearFar[0]) {
          //next behind ncp
          next = mix(next, pos, interp(vnp, next, pos));
        }
      }

      ${J?"depth = pos.z;":""}
      linearDepth = calculateLinearDepth(nearFar,pos.z);

      pos = projectAndScale(pos);
      next = projectAndScale(next);
      prev = projectAndScale(prev);
    }
  `),w.uniforms.add(new ye.p("pixelRatio",(He,Ke)=>Ke.camera.pixelRatio)),w.code.add(F.H`
  void main(void) {
    // unpack values from uv0.y
    bool isStartVertex = abs(abs(uv0.y)-3.0) == 1.0;

    float coverage = 1.0;

    // Check for special value of uv0.y which is used by the Renderer when graphics
    // are removed before the VBO is recompacted. If this is the case, then we just
    // project outside of clip space.
    if (uv0.y == 0.0) {
      // Project out of clip space
      gl_Position = vec4(1e038, 1e038, 1e038, 1.0);
    }
    else {
      bool isJoin = abs(uv0.y) < 3.0;

      float lineSize = getSize();
      float lineWidth = lineSize * pixelRatio;

      ${E?F.H`vLineWidth = lineWidth;`:""}
      ${K?F.H`vLineSizeInv = 1.0 / lineSize;`:""}

      // convert sub-pixel coverage to alpha
      if (lineWidth < 1.0) {
        coverage = lineWidth;
        lineWidth = 1.0;
      }else{
        // Ribbon lines cannot properly render non-integer sizes. Round width to integer size if
        // larger than one for better quality. Note that we do render < 1 pixels more or less correctly
        // so we only really care to round anything larger than 1.
        lineWidth = floor(lineWidth + 0.5);
      }

      vec4 pos  = view * vec4(position.xyz, 1.0);
      vec4 prev = view * vec4(auxpos1.xyz, 1.0);
      vec4 next = view * vec4(auxpos2.xyz, 1.0);
  `),ie&&w.code.add(F.H`vec4 other = isStartVertex ? next : prev;
bool markersHidden = areWorldMarkersHidden(pos, other);
if(!isJoin && !markersHidden) {
pos.xyz += normalize(other.xyz - pos.xyz) * getWorldMarkerSize(pos) * 0.5;
}`),w.code.add(F.H`clipAndTransform(pos, prev, next, isStartVertex);
vec2 left = (pos.xy - prev.xy);
vec2 right = (next.xy - pos.xy);
float leftLen = length(left);
float rightLen = length(right);`),(T.stippleEnabled||v)&&w.code.add(F.H`
      float isEndVertex = float(!isStartVertex);
      vec2 segmentOrigin = mix(pos.xy, prev.xy, isEndVertex);
      vec2 segment = mix(right, left, isEndVertex);
      ${v?F.H`vec2 segmentEnd = mix(next.xy, pos.xy, isEndVertex);`:""}
    `),w.code.add(F.H`left = (leftLen > 0.001) ? left/leftLen : vec2(0.0, 0.0);
right = (rightLen > 0.001) ? right/rightLen : vec2(0.0, 0.0);
vec2 capDisplacementDir = vec2(0, 0);
vec2 joinDisplacementDir = vec2(0, 0);
float displacementLen = lineWidth;
if (isJoin) {
bool isOutside = (left.x * right.y - left.y * right.x) * uv0.y > 0.0;
joinDisplacementDir = normalize(left + right);
joinDisplacementDir = PERPENDICULAR(joinDisplacementDir);
if (leftLen > 0.001 && rightLen > 0.001) {
float nDotSeg = dot(joinDisplacementDir, left);
displacementLen /= length(nDotSeg * left - joinDisplacementDir);
if (!isOutside) {
displacementLen = min(displacementLen, min(leftLen, rightLen)/abs(nDotSeg));
}
}
if (isOutside && (displacementLen > miterLimit * lineWidth)) {`),w.code.add(T.roundJoins?F.H`
        vec2 startDir = leftLen < 0.001 ? right : left;
        startDir = PERPENDICULAR(startDir);

        vec2 endDir = rightLen < 0.001 ? left : right;
        endDir = PERPENDICULAR(endDir);

        float factor = ${T.stippleEnabled?F.H`min(1.0, subdivisionFactor * ${F.H.float((L+2)/(L+1))})`:F.H`subdivisionFactor`};

        float rotationAngle = acos(clamp(dot(startDir, endDir), -1.0, 1.0));
        joinDisplacementDir = rotate(startDir, -sign(uv0.y) * factor * rotationAngle);
      `:F.H`if (leftLen < 0.001) {
joinDisplacementDir = right;
}
else if (rightLen < 0.001) {
joinDisplacementDir = left;
}
else {
joinDisplacementDir = (isStartVertex || subdivisionFactor > 0.0) ? right : left;
}
joinDisplacementDir = PERPENDICULAR(joinDisplacementDir);`),w.code.add(F.H`
        displacementLen = lineWidth;
      }
    } else {
      // CAP handling ---------------------------------------------------
      joinDisplacementDir = isStartVertex ? right : left;
      joinDisplacementDir = PERPENDICULAR(joinDisplacementDir);

      ${T.capType!==B.R.BUTT?F.H`capDisplacementDir = isStartVertex ? -right : left;`:""}
    }
  `),w.code.add(F.H`
    // Displacement (in pixels) caused by join/or cap
    vec2 dpos = joinDisplacementDir * sign(uv0.y) * displacementLen + capDisplacementDir * displacementLen;

    ${Le||ue?F.H`float lineDistNorm = sign(uv0.y) * pos.w;`:""}

    ${ue?F.H`vLineDistance = lineWidth * lineDistNorm;`:""}
    ${Le?F.H`vLineDistanceNorm = lineDistNorm;`:""}

    pos.xy += dpos;
  `),v&&w.code.add(F.H`vec2 segmentDir = normalize(segment);
vSegmentSDF = (isJoin && isStartVertex) ? LARGE_HALF_FLOAT : (dot(pos.xy - segmentOrigin, segmentDir) * pos.w) ;
vReverseSegmentSDF = (isJoin && !isStartVertex) ? LARGE_HALF_FLOAT : (dot(pos.xy - segmentEnd, -segmentDir) * pos.w);`),T.stippleEnabled&&(T.draped?w.uniforms.add(new ye.p("worldToScreenRatio",(He,Ke)=>1/Ke.screenToPCSRatio)):w.code.add(F.H`vec3 segmentCenter = mix((auxpos2 + position) * 0.5, (position + auxpos1) * 0.5, isEndVertex);
float worldToScreenRatio = computeWorldToScreenRatio(segmentCenter);`),w.code.add(F.H`float segmentLengthScreenDouble = length(segment);
float segmentLengthScreen = segmentLengthScreenDouble * 0.5;
float discreteWorldToScreenRatio = discretizeWorldToScreenRatio(worldToScreenRatio);
float segmentLengthRender = length(mix(auxpos2 - position, position - auxpos1, isEndVertex));
vStipplePatternStretch = worldToScreenRatio / discreteWorldToScreenRatio;`),w.code.add(T.draped?F.H`float segmentLengthPseudoScreen = segmentLengthScreen / pixelRatio * discreteWorldToScreenRatio / worldToScreenRatio;
float startPseudoScreen = uv0.x * discreteWorldToScreenRatio - mix(0.0, segmentLengthPseudoScreen, isEndVertex);`:F.H`float startPseudoScreen = mix(uv0.x, uv0.x - segmentLengthRender, isEndVertex) * discreteWorldToScreenRatio;
float segmentLengthPseudoScreen = segmentLengthRender * discreteWorldToScreenRatio;`),w.uniforms.add(new ye.p("stipplePatternPixelSize",He=>(0,V.C)(He))),w.code.add(F.H`
      float patternLength = ${T.stippleScaleWithLineWidth?"lineSize * ":""} stipplePatternPixelSize;

      // Compute the coordinates at both start and end of the line segment, because we need both to clamp to in the fragment shader
      vStippleDistanceLimits = computeStippleDistanceLimits(startPseudoScreen, segmentLengthPseudoScreen, segmentLengthScreen, patternLength);

      vStippleDistance = mix(vStippleDistanceLimits.x, vStippleDistanceLimits.y, isEndVertex);

      // Adjust the coordinate to the displaced position (the pattern is shortened/overextended on the in/outside of joins)
      if (segmentLengthScreenDouble >= 0.001) {
        // Project the actual vertex position onto the line segment. Note that the resulting factor is within [0..1] at the
        // original vertex positions, and slightly outside of that range at the displaced positions
        vec2 stippleDisplacement = pos.xy - segmentOrigin;
        float stippleDisplacementFactor = dot(segment, stippleDisplacement) / (segmentLengthScreenDouble * segmentLengthScreenDouble);

        // Apply this offset to the actual vertex coordinate (can be screen or pseudo-screen space)
        vStippleDistance += (stippleDisplacementFactor - isEndVertex) * (vStippleDistanceLimits.y - vStippleDistanceLimits.x);
      }

      // Cancel out perspective correct interpolation because we want this length the really represent the screen distance
      vStippleDistanceLimits *= pos.w;
      vStippleDistance *= pos.w;

      // Disable stipple distance limits on caps
      vStippleDistanceLimits = isJoin ?
                                 vStippleDistanceLimits :
                                 isStartVertex ?
                                  vec2(-1e038, vStippleDistanceLimits.y) :
                                  vec2(vStippleDistanceLimits.x, 1e038);
    `)),w.code.add(F.H`
      // Convert back into NDC
      pos.xy = (pos.xy / viewport.zw) * pos.w;

      vColor = getColor();
      vColor.a *= coverage;

      ${T.wireframe&&!T.draped?"pos.z -= 0.001 * pos.w;":""}

      // transform final position to camera space for slicing
      vpos = (inverseProjectionMatrix * pos).xyz;
      gl_Position = pos;
      forwardObjectAndLayerIdColor();
    }
  }
  `),J&&Q.include(W.l,T),Q.include(b.f5,T),C.include(X.Y),C.code.add(F.H`
  void main() {
    discardBySlice(vpos);
    ${J?"terrainDepthTest(gl_FragCoord, depth);":""}
  `),T.wireframe?C.code.add(F.H`vec4 finalColor = vec4(1.0, 0.0, 1.0, 1.0);`):(v&&C.code.add(F.H`
      float sdf = min(vSegmentSDF, vReverseSegmentSDF);
      vec2 fragmentPosition = vec2(
        min(sdf, 0.0),
        vLineDistance
      ) * gl_FragCoord.w;

      float fragmentRadius = length(fragmentPosition);
      float fragmentCapSDF = (fragmentRadius - vLineWidth) * 0.5; // Divide by 2 to transform from double pixel scale
      float capCoverage = clamp(0.5 - fragmentCapSDF, 0.0, 1.0);

      if (capCoverage < ${F.H.float($.b)}) {
        discard;
      }
    `),C.code.add(Me?F.H`
      vec2 stipplePosition = vec2(
        min(getStippleSDF() * 2.0 - 1.0, 0.0),
        vLineDistanceNorm * gl_FragCoord.w
      );
      float stippleRadius = length(stipplePosition * vLineWidth);
      float stippleCapSDF = (stippleRadius - vLineWidth) * 0.5; // Divide by 2 to transform from double pixel scale
      float stippleCoverage = clamp(0.5 - stippleCapSDF, 0.0, 1.0);
      float stippleAlpha = step(${F.H.float($.b)}, stippleCoverage);
      `:F.H`float stippleAlpha = getStippleAlpha();`),C.uniforms.add(new ce.N("intrinsicColor",He=>He.color)),T.output!==g.H.ObjectAndLayerIdColor&&C.code.add(F.H`discardByStippleAlpha(stippleAlpha, stippleAlphaColorDiscard);`),C.code.add(F.H`vec4 color = intrinsicColor * vColor;`),T.innerColorEnabled&&(C.uniforms.add(new ce.N("innerColor",He=>(0,m.Pt)(He.innerColor,He.color))),C.uniforms.add(new ye.p("innerWidth",(He,Ke)=>He.innerWidth*Ke.camera.pixelRatio)),C.code.add(F.H`float distToInner = abs(vLineDistance * gl_FragCoord.w) - innerWidth;
float innerAA = clamp(0.5 - distToInner, 0.0, 1.0);
float innerAlpha = innerColor.a + color.a * (1.0 - innerColor.a);
color = mix(color, vec4(innerColor.rgb, innerAlpha), innerAA);`)),C.code.add(F.H`vec4 finalColor = blendStipple(color, stippleAlpha);`),T.falloffEnabled&&(C.uniforms.add(new ye.p("falloff",He=>He.falloff)),C.code.add(F.H`finalColor.a *= pow(max(0.0, 1.0 - abs(vLineDistanceNorm * gl_FragCoord.w)), falloff);`))),C.code.add(F.H`
    ${T.output===g.H.ObjectAndLayerIdColor?F.H`finalColor.a = 1.0;`:""}

    if (finalColor.a < ${F.H.float($.b)}) {
      discard;
    }

    ${T.output===g.H.Alpha?F.H`gl_FragColor = vec4(finalColor.a);`:""}
    ${T.output===g.H.Color?F.H`gl_FragColor = highlightSlice(finalColor, vpos);`:""}
    ${T.output===g.H.Color&&T.transparencyPassType===k.A.Color?"gl_FragColor = premultiplyAlpha(gl_FragColor);":""}
    ${T.output===g.H.Highlight?F.H`gl_FragColor = vec4(1.0);`:""}
    ${T.output===g.H.Depth?F.H`outputDepth(linearDepth);`:""}
    ${T.output===g.H.ObjectAndLayerIdColor?F.H`outputObjectAndLayerIdColor();`:""}
  }
  `),Q}const P=Object.freeze(Object.defineProperty({__proto__:null,RIBBONLINE_NUM_ROUND_JOIN_SUBDIVISIONS:L,build:Y},Symbol.toStringTag,{value:"Module"}))},61584:(Ve,Ee,a)=>{a.d(Ee,{W:()=>B,b:()=>I});var m=a(52382),_=a(13934),g=a(78925),b=a(24255),q=a(62952),M=a(44965),c=a(31166),V=a(10109),H=a(7025),W=a(92724),x=a(72968),$=a(61594),X=a(45780),O=a(67022),U=a(33726),ce=a(99198),ye=a(69960),F=a(65787),se=a(17625),te=a(22355),k=a(44835),y=a(16396);function I(L){const Y=new te.kG,{vertex:P,fragment:T}=Y;(0,ce.Sv)(P,L),Y.include(b.w,L),Y.attributes.add(y.T.POSITION,"vec3"),Y.attributes.add(y.T.UV0,"vec2");const Q=new ye.N("waterColor",w=>w.color);if(L.output===_.H.Color&&L.isDraped)return Y.varyings.add("vpos","vec3"),P.uniforms.add(Q),P.code.add(se.H`
        void main(void) {
          if (waterColor.a < ${se.H.float(O.b)}) {
            // Discard this vertex
            gl_Position = vec4(1e38, 1e38, 1e38, 1.0);
            return;
          }

          vpos = position;
          gl_Position = transformPosition(proj, view, vpos);
        }
    `),T.uniforms.add(Q),T.code.add(se.H`void main() {
gl_FragColor = waterColor;
}`),Y;switch(L.output!==_.H.Color&&L.output!==_.H.Alpha||(Y.include(H.n,L),Y.include(m.qj,L),Y.varyings.add("vuv","vec2"),Y.varyings.add("vpos","vec3"),Y.varyings.add("vnormal","vec3"),Y.varyings.add("vtbnMatrix","mat3"),L.hasMultipassTerrain&&Y.varyings.add("depth","float"),P.uniforms.add(Q),P.code.add(se.H`
      void main(void) {
        if (waterColor.a < ${se.H.float(O.b)}) {
          // Discard this vertex
          gl_Position = vec4(1e38, 1e38, 1e38, 1.0);
          return;
        }

        vuv = uv0;
        vpos = position;

        vnormal = getLocalUp(vpos, localOrigin);
        vtbnMatrix = getTBNMatrix(vnormal);

        ${L.hasMultipassTerrain?"depth = (view * vec4(vpos, 1.0)).z;":""}

        gl_Position = transformPosition(proj, view, vpos);
        ${L.output===_.H.Color?"forwardLinearDepth();":""}
      }
    `)),Y.include(V.l,L),L.output){case _.H.Alpha:Y.include(g.f5,L),T.uniforms.add(Q),T.code.add(se.H`
        void main() {
          discardBySlice(vpos);
          ${L.hasMultipassTerrain?"terrainDepthTest(gl_FragCoord, depth);":""}

          gl_FragColor = vec4(waterColor.a);
        }
      `);break;case _.H.Color:Y.include(c.kR,L),Y.include(M._,{pbrMode:W.f7.Disabled,lightingSphericalHarmonicsOrder:2}),Y.include(X.M),Y.include(g.f5,L),Y.include(x.XE,L),Y.include($.B,L),T.uniforms.add([Q,new F.p("timeElapsed",w=>w.timeElapsed),P.uniforms.get("view"),P.uniforms.get("localOrigin")]),(0,ce.hY)(T,L),T.include(U.Y),(0,c.Pe)(T),(0,c.F1)(T),T.code.add(se.H`
      void main() {
        discardBySlice(vpos);
        ${L.hasMultipassTerrain?"terrainDepthTest(gl_FragCoord, depth);":""}
        vec3 localUp = vnormal;
        // the created normal is in tangent space
        vec4 tangentNormalFoam = getSurfaceNormalAndFoam(vuv, timeElapsed);

        // we rotate the normal according to the tangent-bitangent-normal-Matrix
        vec3 n = normalize(vtbnMatrix * tangentNormalFoam.xyz);
        vec3 v = -normalize(vpos - cameraPosition);
        float shadow = ${L.receiveShadows?se.H`1.0 - readShadowMap(vpos, linearDepth)`:"1.0"};
        vec4 vPosView = view * vec4(vpos, 1.0);
        vec4 final = vec4(getSeaColor(n, v, mainLightDirection, waterColor.rgb, mainLightIntensity, localUp, shadow, tangentNormalFoam.w, vPosView.xyz, vpos + localOrigin), waterColor.w);

        // gamma correction
        gl_FragColor = delinearizeGamma(final);
        gl_FragColor = highlightSlice(gl_FragColor, vpos);
        ${L.transparencyPassType===k.A.Color?"gl_FragColor = premultiplyAlpha(gl_FragColor);":""}
      }
    `);break;case _.H.Normal:Y.include(H.n,L),Y.include(X.M,L),Y.include(g.f5,L),Y.varyings.add("vpos","vec3"),Y.varyings.add("vuv","vec2"),P.uniforms.add(Q),P.code.add(se.H`
        void main(void) {
          if (waterColor.a < ${se.H.float(O.b)}) {
            // Discard this vertex
            gl_Position = vec4(1e38, 1e38, 1e38, 1.0);
            return;
          }

          vuv = uv0;
          vpos = position;

          gl_Position = transformPosition(proj, view, vpos);
        }
    `),T.uniforms.add(new F.p("timeElapsed",w=>w.timeElapsed)),T.code.add(se.H`void main() {
discardBySlice(vpos);
vec4 tangentNormalFoam = getSurfaceNormalAndFoam(vuv, timeElapsed);
tangentNormalFoam.xyz = normalize(tangentNormalFoam.xyz);
gl_FragColor = vec4((tangentNormalFoam.xyz + vec3(1.0)) * 0.5, tangentNormalFoam.w);
}`);break;case _.H.Highlight:Y.include(q.bA,L),Y.varyings.add("vpos","vec3"),P.uniforms.add(Q),P.code.add(se.H`
      void main(void) {
        if (waterColor.a < ${se.H.float(O.b)}) {
          // Discard this vertex
          gl_Position = vec4(1e38, 1e38, 1e38, 1.0);
          return;
        }

        vpos = position;
        gl_Position = transformPosition(proj, view, vpos);
      }
    `),Y.include(g.f5,L),T.code.add(se.H`void main() {
discardBySlice(vpos);
outputHighlight();
}`)}return Y}const B=Object.freeze(Object.defineProperty({__proto__:null,build:I},Symbol.toStringTag,{value:"Module"}))},41743:(Ve,Ee,a)=>{a.d(Ee,{a:()=>F,c:()=>te,g:()=>Y,h:()=>v,u:()=>I}),a(8314);var _=a(63290),g=a(21286),b=a(97535),q=a(28347),M=a(43703),c=a(84161),V=a(28093),H=a(78172),W=a(10992),x=a(90014),$=a(70562),X=a(34054),O=a(26242);const U=_.Z.getLogger("esri.views.3d.support.geometryUtils.boundedPlane");function F(G=vt){return{plane:(0,x.Ue)(G.plane),origin:(0,V.a)(G.origin),basis1:(0,V.a)(G.basis1),basis2:(0,V.a)(G.basis2)}}function te(G,_e=F()){return y(G.origin,G.basis1,G.basis2,_e)}function y(G,_e,re,ne=F()){return(0,c.c)(ne.origin,G),(0,c.c)(ne.basis1,_e),(0,c.c)(ne.basis2,re),I(ne),function Ut(G,_e){Math.abs((0,c.e)(G.basis1,G.basis2)/((0,c.l)(G.basis1)*(0,c.l)(G.basis2)))>1e-6&&U.warn(_e,"Provided basis vectors are not perpendicular"),Math.abs((0,c.e)(G.basis1,Xe(G)))>1e-6&&U.warn(_e,"Basis vectors and plane normal are not perpendicular"),Math.abs(-(0,c.e)(Xe(G),G.origin)-G.plane[3])>1e-6&&U.warn(_e,"Plane offset is not consistent with plane origin")}(ne,"fromValues()"),ne}function I(G){(0,x.my)(G.basis2,G.basis1,G.origin,G.plane)}function B(G,_e,re){G!==re&&te(G,re);const ne=(0,c.g)(O.WM.get(),Xe(G),_e);return(0,c.a)(re.origin,re.origin,ne),re.plane[3]-=_e,re}function Y(G,_e=F()){const re=(G[2]-G[0])/2,ne=(G[3]-G[1])/2;return(0,c.s)(_e.origin,G[0]+re,G[1]+ne,0),(0,c.s)(_e.basis1,re,0,0),(0,c.s)(_e.basis2,0,ne,0),(0,x.al)(0,0,1,0,_e.plane),_e}function P(G,_e,re){return!!(0,x.BR)(G.plane,_e,re)&&tt(G,re)}function Q(G,_e,re){const ne=Dt.get();qe(G,_e,ne,Dt.get());let ve=Number.POSITIVE_INFINITY;for(const Z of Ot){const j=ke(G,Z,it.get()),he=O.WM.get();if((0,x.rx)(ne,j,he)){const ae=(0,c.r)(O.WM.get(),_e.origin,he),ge=Math.abs((0,g.ZF)((0,c.e)(_e.direction,ae)));ge<ve&&(ve=ge,(0,c.c)(re,he))}}return ve===Number.POSITIVE_INFINITY?w(G,_e,re):re}function w(G,_e,re){if(P(G,_e,re))return re;const ne=Dt.get(),ve=Dt.get();qe(G,_e,ne,ve);let Z=Number.POSITIVE_INFINITY;for(const j of Ot){const he=ke(G,j,it.get()),ae=O.WM.get();if((0,x.dZ)(ne,he,ae)){const ge=(0,$.Jk)(_e,ae);if(!(0,x.Ac)(ve,ae))continue;ge<Z&&(Z=ge,(0,c.c)(re,ae))}}return ie(G,_e.origin)<Z&&C(G,_e.origin,re),re}function C(G,_e,re){const ne=(0,x.nF)(G.plane,_e,O.WM.get()),ve=(0,W.ct)(Ye(G,G.basis1),ne,-1,1,O.WM.get()),Z=(0,W.ct)(Ye(G,G.basis2),ne,-1,1,O.WM.get());return(0,c.b)(re,(0,c.a)(O.WM.get(),ve,Z),G.origin),re}function J(G,_e,re){const{origin:ne,basis1:ve,basis2:Z}=G,j=(0,c.b)(O.WM.get(),_e,ne),he=(0,X.SR)(ve,j),ae=(0,X.SR)(Z,j),ge=(0,X.SR)(Xe(G),j);return(0,c.s)(re,he,ae,ge)}function ie(G,_e){const re=J(G,_e,O.WM.get()),{basis1:ne,basis2:ve}=G,Z=(0,c.l)(ne),j=(0,c.l)(ve),he=Math.max(Math.abs(re[0])-Z,0),ae=Math.max(Math.abs(re[1])-j,0),ge=re[2];return he*he+ae*ae+ge*ge}function v(G,_e){return Math.sqrt(ie(G,_e))}function Me(G,_e){const re=-G.plane[3];return(0,X.SR)(Xe(G),_e)-re}function Xe(G){return(0,x.mJ)(G.plane)}function tt(G,_e){const re=(0,c.b)(O.WM.get(),_e,G.origin),ne=(0,c.p)(G.basis1),ve=(0,c.p)(G.basis2),Z=(0,c.e)(G.basis1,re),j=(0,c.e)(G.basis2,re);return-Z-ne<0&&Z-ne<0&&-j-ve<0&&j-ve<0}function Ye(G,_e){const re=it.get();return(0,c.c)(re.origin,G.origin),(0,c.c)(re.vector,_e),re}function ke(G,_e,re){const{basis1:ne,basis2:ve,origin:Z}=G,j=(0,c.g)(O.WM.get(),ne,_e.origin[0]),he=(0,c.g)(O.WM.get(),ve,_e.origin[1]);(0,c.a)(re.origin,j,he),(0,c.a)(re.origin,re.origin,Z);const ae=(0,c.g)(O.WM.get(),ne,_e.direction[0]),ge=(0,c.g)(O.WM.get(),ve,_e.direction[1]);return(0,c.g)(re.vector,(0,c.a)(ae,ae,ge),2),re}function qe(G,_e,re,ne){const ve=Xe(G);(0,x.my)(ve,_e.direction,_e.origin,re),(0,x.my)((0,x.mJ)(re),ve,_e.origin,ne)}const vt={plane:(0,x.Ue)(),origin:(0,V.f)(0,0,0),basis1:(0,V.f)(1,0,0),basis2:(0,V.f)(0,1,0)},Dt=new b.x(x.Ue),it=new b.x(W.Ue),yt=(0,V.c)(),At=new b.x(()=>F()),Ot=[{origin:[-1,-1],direction:[1,0]},{origin:[1,-1],direction:[0,1]},{origin:[1,1],direction:[-1,0]},{origin:[-1,1],direction:[0,-1]}],Et=(0,M.c)(),ct=(0,M.c)();Object.freeze(Object.defineProperty({__proto__:null,BoundedPlaneClass:class ce{constructor(){this.plane=(0,x.Ue)(),this.origin=(0,V.c)(),this.basis1=(0,V.c)(),this.basis2=(0,V.c)()}},UP:vt,altitudeAt:Me,axisAt:function ue(G,_e,re,ne){return function Ge(G,_e,re){switch(_e){case H.R.X:(0,c.c)(re,G.basis1),(0,c.n)(re,re);break;case H.R.Y:(0,c.c)(re,G.basis2),(0,c.n)(re,re);break;case H.R.Z:(0,c.c)(re,Xe(G))}return re}(G,re,ne)},closestPoint:w,closestPointOnSilhouette:Q,copy:te,copyWithoutVerify:function k(G,_e){(0,c.c)(_e.origin,G.origin),(0,c.c)(_e.basis1,G.basis1),(0,c.c)(_e.basis2,G.basis2),(0,x.JG)(_e.plane,G.plane)},create:F,distance:v,distance2:ie,distanceToSilhouette:function E(G,_e){let re=Number.NEGATIVE_INFINITY;for(const ne of Ot){const ve=ke(G,ne,it.get()),Z=(0,W.Jk)(ve,_e);Z>re&&(re=Z)}return Math.sqrt(re)},elevate:B,equals:function Fe(G,_e){return(0,c.k)(G.basis1,_e.basis1)&&(0,c.k)(G.basis2,_e.basis2)&&(0,c.k)(G.origin,_e.origin)},extrusionContainsPoint:function K(G,_e){return(0,x.Ac)(G.plane,_e)&&tt(G,_e)},fromAABoundingRect:Y,fromValues:y,intersectRay:P,intersectRayClosestSilhouette:function T(G,_e,re){if(P(G,_e,re))return re;const ne=Q(G,_e,O.WM.get());return(0,c.a)(re,_e.origin,(0,c.g)(O.WM.get(),_e.direction,(0,c.i)(_e.origin,ne)/(0,c.l)(_e.direction))),re},normal:Xe,projectPoint:C,projectPointLocal:J,rotate:function Ke(G,_e,re,ne){return G!==ne&&te(G,ne),(0,q.d)(ct,_e,re),(0,c.m)(ne.basis1,G.basis1,ct),(0,c.m)(ne.basis2,G.basis2,ct),I(ne),ne},setAltitudeAt:function Le(G,_e,re,ne){const ve=Me(G,_e),Z=(0,c.g)(yt,Xe(G),re-ve);return(0,c.a)(ne,_e,Z),ne},setExtent:function L(G,_e,re){return Y(_e,re),B(re,Me(G,G.origin),re),re},transform:function He(G,_e,re){return G!==re&&te(G,re),(0,q.a)(Et,_e),(0,q.t)(Et,Et),(0,c.m)(re.basis1,G.basis1,Et),(0,c.m)(re.basis2,G.basis2,Et),(0,c.m)((0,x.mJ)(re.plane),(0,x.mJ)(G.plane),Et),(0,c.m)(re.origin,G.origin,_e),(0,x.T5)(re.plane,re.plane,re.origin),re},updateUnboundedPlane:I,wrap:function se(G,_e,re){const ne=At.get();return ne.origin=G,ne.basis1=_e,ne.basis2=re,ne.plane=(0,x.re)(0,0,0,0),I(ne),ne}},Symbol.toStringTag,{value:"Module"}))},36161:(Ve,Ee,a)=>{a.d(Ee,{I:()=>_,v:()=>g});var m=a(21286);function _(V,H,W=0){const x=(0,m.uZ)(V,0,M);for(let $=0;$<4;$++)H[W+$]=Math.floor(256*c(x*b[$]))}function g(V,H=0){let W=0;for(let x=0;x<4;x++)W+=V[H+x]*q[x];return W}const b=[1,256,65536,16777216],q=[1/256,1/65536,1/16777216,1/4294967296],M=g(new Uint8ClampedArray([255,255,255,255]));function c(V){return V-Math.floor(V)}},13757:(Ve,Ee,a)=>{a.d(Ee,{d:()=>g});var m=a(21286),_=a(37187);function g(V,H,W){const x=Array.isArray(V),$=x?V.length/H:V.byteLength/(4*H),X=x?V:new Uint32Array(V,0,$*H),O=W?.minReduction??0,U=W?.originalIndices||null,ce=U?U.length:0,ye=W?.componentOffsets||null;let F=0;if(ye)for(let w=0;w<ye.length-1;w++){const C=ye[w+1]-ye[w];C>F&&(F=C)}else F=$;const se=Math.floor(1.1*F)+1;(null==c||c.length<2*se)&&(c=new Uint32Array((0,m.Sf)(2*se)));for(let w=0;w<2*se;w++)c[w]=0;let te=0;const k=!!ye&&!!U,y=k?ce:$;let I=(0,_.$z)($/3);const B=new Uint32Array(ce),L=1.96;let Y=0!==O?Math.ceil(4*L*L/(O*O)*O*(1-O)):y,P=1,T=ye?ye[1]:y;for(let w=0;w<y;w++){if(w===Y){const K=1-te/w;if(K+L*Math.sqrt(K*(1-K)/w)<O)return null;Y*=2}if(w===T){for(let K=0;K<2*se;K++)c[K]=0;if(U)for(let K=ye[P-1];K<ye[P];K++)B[K]=I[U[K]];T=ye[++P]}const C=k?U[w]:w,J=C*H,ie=M(X,J,H);let v=ie%se,E=te;for(;0!==c[2*v+1];){if(c[2*v]===ie){const K=c[2*v+1]-1;if(b(X,J,K*H,H)){E=I[K];break}}v++,v>=se&&(v-=se)}E===te&&(c[2*v]=ie,c[2*v+1]=C+1,te++),I[C]=E}if(0!==O&&1-te/$<O)return null;if(k){for(let w=ye[P-1];w<B.length;w++)B[w]=I[U[w]];I=(0,_.mi)(B)}const Q=x?new Array(te):new Uint32Array(te*H);te=0;for(let w=0;w<y;w++)I[w]===te&&(q(X,(k?U[w]:w)*H,Q,te*H,H),te++);if(U&&!k){const w=new Uint32Array(ce);for(let C=0;C<w.length;C++)w[C]=I[U[C]];I=(0,_.mi)(w)}return{buffer:Array.isArray(Q)?Q:Q.buffer,indices:I,uniqueCount:te}}function b(V,H,W,x){for(let $=0;$<x;$++)if(V[H+$]!==V[W+$])return!1;return!0}function q(V,H,W,x,$){for(let X=0;X<$;X++)W[x+X]=V[H+X]}function M(V,H,W){let x=0;for(let $=0;$<W;$++)x=V[H+$]+x|0,x=x+(x<<11)+(x>>>2)|0;return x>>>0}let c=null},85334:(Ve,Ee,a)=>{a.d(Ee,{Mk:()=>c,ZI:()=>W,bT:()=>q});var W,x,m=a(11915),_=a(25748),g=a(13757),b=a(6040);function q(x){const $=c(x.rings,x.hasZ,W.CCW_IS_HOLE),X=new Array;let O=0,U=0;for(const F of $.polygons){const te=F.index,k=(0,b.Rq)($.position,3*te,3*F.count),y=F.holeIndices.map(B=>B-te),I=new Uint32Array((0,m.e)(k,y,3));X.push({position:k,faces:I}),O+=k.length,U+=I.length}const ce=function M(x,$,X){if(1===x.length)return x[0];const O=(0,b.bg)($),U=new Uint32Array(X);let ce=0,ye=0,F=0;for(const se of x){for(let te=0;te<se.position.length;te++)O[ce++]=se.position[te];for(let te=0;te<se.faces.length;te++)U[ye++]=se.faces[te]+F;F=ce/3}return{position:O,faces:U}}(X,O,U),ye=Array.isArray(ce.position)?(0,g.d)(ce.position,3,{originalIndices:ce.faces}):(0,g.d)(ce.position.buffer,6,{originalIndices:ce.faces});return ce.position=new Float64Array(ye.buffer),ce.faces=ye.indices,ce}function c(x,$,X){const O=x.length,U=new Array(O),ce=new Array(O),ye=new Array(O);let F=0,se=0,te=0,k=0;for(let B=0;B<O;++B)k+=x[B].length;const y=(0,b.bg)(3*k);let I=0;for(let B=O-1;B>=0;B--){const L=x[B],Y=X===W.CCW_IS_HOLE&&H(L);if(Y&&1!==O)U[F++]=L;else{let P=L.length;for(let Q=0;Q<F;++Q)P+=U[Q].length;const T={index:I,pathLengths:new Array(F+1),count:P,holeIndices:new Array(F)};T.pathLengths[0]=L.length,L.length>0&&(ye[te++]={index:I,count:L.length}),I=Y?V(L,L.length-1,-1,y,I,L.length,$):V(L,0,1,y,I,L.length,$);for(let Q=0;Q<F;++Q){const w=U[Q];T.holeIndices[Q]=I,T.pathLengths[Q+1]=w.length,w.length>0&&(ye[te++]={index:I,count:w.length}),I=V(w,0,1,y,I,w.length,$)}F=0,T.count>0&&(ce[se++]=T)}}for(let B=0;B<F;++B){const L=U[B];L.length>0&&(ye[te++]={index:I,count:L.length}),I=V(L,0,1,y,I,L.length,$)}return ce.length=se,ye.length=te,{position:y,polygons:ce,outlines:ye}}function V(x,$,X,O,U,ce,ye){U*=3;for(let F=0;F<ce;++F){const se=x[$];O[U++]=se[0],O[U++]=se[1],O[U++]=ye?se[2]:0,$+=X}return U/3}function H(x){return!(0,_.bu)(x,!1,!1)}(x=W||(W={}))[x.NONE=0]="NONE",x[x.CCW_IS_HOLE=1]="CCW_IS_HOLE"},88530:(Ve,Ee,a)=>{function m(_){return"point"===_.type}a.d(Ee,{f:()=>m})},84786:(Ve,Ee,a)=>{a.d(Ee,{D:()=>k,Ou:()=>W,WG:()=>te,kB:()=>O,mW:()=>X}),a(29132);var _=a(88879),b=(a(8314),a(58817)),q=a(62208),M=a(55713),c=a(91179),V=a(38114),H=a(65234);function W(y){return"declaredClass"in y}function x(y){return"declaredClass"in y}function X(y,I){return y?function $(y){return"declaredClass"in y}(y)?y:new _.Z({layer:I,sourceLayer:I,visible:y.visible,symbol:(0,b.d9)(y.symbol),attributes:(0,b.d9)(y.attributes),geometry:O(y.geometry)}):null}function O(y){return(0,q.Wi)(y)?null:W(y)?y:(0,c.im)(function U(y){const{wkid:I,wkt:B,latestWkid:L}=y.spatialReference,Y={wkid:I,wkt:B,latestWkid:L};switch(y.type){case"point":{const{x:P,y:T,z:Q,m:w}=y;return{x:P,y:T,z:Q,m:w,spatialReference:Y}}case"polygon":{const{rings:P,hasZ:T,hasM:Q}=y;return{rings:ce(P),hasZ:T,hasM:Q,spatialReference:Y}}case"polyline":{const{paths:P,hasZ:T,hasM:Q}=y;return{paths:ce(P),hasZ:T,hasM:Q,spatialReference:Y}}case"extent":{const{xmin:P,xmax:T,ymin:Q,ymax:w,zmin:C,zmax:J,mmin:ie,mmax:v,hasZ:E,hasM:K}=y;return{xmin:P,xmax:T,ymin:Q,ymax:w,zmin:C,zmax:J,mmin:ie,mmax:v,hasZ:E,hasM:K,spatialReference:Y}}case"multipoint":{const{points:P,hasZ:T,hasM:Q}=y;return{points:se(P)?ye(P):P,hasZ:T,hasM:Q,spatialReference:Y}}default:return}}(y))}function ce(y){return function F(y){for(const I of y)if(0!==I.length)return se(I);return!1}(y)?y.map(I=>ye(I)):y}function ye(y){return y.map(I=>Array.from(I))}function se(y){return y.length>0&&((0,M.xZ)(y[0])||(0,M.fS)(y[0]))}function te(y,I){if(!y)return null;let B;if(x(y)){if(null==I)return y.clone();if(x(I))return I.copy(y)}return null!=I?(B=I,B.x=y.x,B.y=y.y,B.spatialReference=y.spatialReference,y.hasZ?(B.z=y.z,B.hasZ=y.hasZ):(B.z=void 0,B.hasZ=!1),y.hasM?(B.m=y.m,B.hasM=!0):(B.m=void 0,B.hasM=!1)):(B=(0,V.Tx)(y.x,y.y,y.z,y.spatialReference),y.hasM&&(B.m=y.m,B.hasM=!0)),B}function k(y){const{wkid:I,wkt:B,latestWkid:L}=y;return H.Z.fromJSON({wkid:I,wkt:B,latestWkid:L})}},12015:(Ve,Ee,a)=>{a.d(Ee,{co:()=>M,ii:()=>b});var q,M,c,H,m=a(43703),_=a(28093),g=a(75583);class b{constructor(){this.readChannels=g.uz.RG,this.renderingStage=g.jL.FINISHED,this.startTime=0,this.startTimeHeightFade=0,this.cameraPositionLastFrame=(0,_.c)(),this.isCameraPositionFinal=!0,this.parallax=new V,this.parallaxNew=new V,this.crossFade={enabled:!1,factor:1,distanceThresholdFactor:.3},this.fadeInOut={stage:M.FINISHED,factor:1,distanceThresholdFactor:.6},this.fadeIn={stage:q.FINISHED,factor:1,distanceThresholdFactor:2},this.fadeInOutHeight={stage:c.FINISHED,factor:-1}}get isFading(){return this.fadeInOut.stage===M.FADE_OUT||this.fadeInOut.stage===M.FADE_IN||this.fadeIn.stage===q.FADE_IN||this.fadeInOutHeight.stage!==c.FINISHED||this.renderingStage===g.jL.FADING_TEXTURE_CHANNELS}}(H=q||(q={}))[H.FINISHED=0]="FINISHED",H[H.CHANGE_ANCHOR=1]="CHANGE_ANCHOR",H[H.FADE_IN=2]="FADE_IN",function(H){H[H.FINISHED=0]="FINISHED",H[H.FADE_OUT=1]="FADE_OUT",H[H.SWITCH=2]="SWITCH",H[H.FADE_IN=3]="FADE_IN"}(M||(M={})),function(H){H[H.FINISHED=0]="FINISHED",H[H.HEIGHT_FADE=1]="HEIGHT_FADE"}(c||(c={}));class V{constructor(){this.anchorPointClouds=(0,_.c)(),this.cloudsHeight=1e5,this.radiusCurvatureCorrectionFactor=0,this.transform=(0,m.c)()}}},75583:(Ve,Ee,a)=>{var m,_,q;a.d(Ee,{jL:()=>m,uz:()=>_}),(q=m||(m={}))[q.RENDERING=0]="RENDERING",q[q.FINISHED_RENDERING=1]="FINISHED_RENDERING",q[q.FADING_TEXTURE_CHANNELS=2]="FADING_TEXTURE_CHANNELS",q[q.SWITCH_CHANNELS=3]="SWITCH_CHANNELS",q[q.FINISHED=4]="FINISHED",function(q){q[q.RG=0]="RG",q[q.BA=1]="BA"}(_||(_={}))},79112:(Ve,Ee,a)=>{a.d(Ee,{o:()=>b});var m=a(62208),_=a(29505),g=a(74746);class b{constructor(){this._meterUnitOffset=0,this._renderUnitOffset=0,this._unit="meters",this._metersPerElevationInfoUnit=1,this._featureExpressionInfoContext=null,this.centerPointInElevationSR=null,this.mode=null}get featureExpressionInfoContext(){return this._featureExpressionInfoContext}get meterUnitOffset(){return this._meterUnitOffset}get unit(){return this._unit}set unit(M){this._unit=M,this._metersPerElevationInfoUnit=(0,_.Z7)(M)}get requiresSampledElevationInfo(){return"absolute-height"!==this.mode}reset(){this.mode=null,this._meterUnitOffset=0,this._renderUnitOffset=0,this._featureExpressionInfoContext=null,this.unit="meters"}set offsetMeters(M){this._meterUnitOffset=M,this._renderUnitOffset=0}set offsetElevationInfoUnits(M){this._meterUnitOffset=M*this._metersPerElevationInfoUnit,this._renderUnitOffset=0}addOffsetRenderUnits(M){this._renderUnitOffset+=M}geometryZWithOffset(M,c){const V=this.calculateOffsetRenderUnits(c);return null!=this.featureExpressionInfoContext?V:M+V}calculateOffsetRenderUnits(M){let c=this._meterUnitOffset;const V=this.featureExpressionInfoContext;return null!=V&&(c+=(0,g.ht)(V)*this._metersPerElevationInfoUnit),c/M.unitInMeters+this._renderUnitOffset}setFromElevationInfo(M){this.mode=M.mode,this.unit=(0,_.lt)(M.unit)?M.unit:"meters",this.offsetElevationInfoUnits=(0,m.Pt)(M.offset,0)}updateFeatureExpressionInfoContext(M,c,V){if((0,m.Wi)(M))return void(this._featureExpressionInfoContext=null);const H=M&&M.arcade;H&&(0,m.pC)(c)&&(0,m.pC)(V)?(this._featureExpressionInfoContext=(0,g.d9)(M),(0,g.aO)(this._featureExpressionInfoContext,(0,g.Tz)(H.modules,c,V))):this._featureExpressionInfoContext=M}static fromElevationInfo(M){const c=new b;return(0,m.pC)(M)&&c.setFromElevationInfo(M),c}}},81468:(Ve,Ee,a)=>{a.d(Ee,{B5:()=>O,GC:()=>$,Lm:()=>k,Xf:()=>X,bD:()=>U,lO:()=>y,qZ:()=>W,rR:()=>H,w7:()=>x});var y,P,m=a(62208),_=a(28347),g=a(43703),b=a(28093),q=a(55915),M=a(88530),c=a(67225),V=a(53929);function H(P,T,Q,w,C,J,ie,v,E,K,ue){const Me=I[ue.mode];let Le,Fe,He=0;if((0,q.CM)(P,T,Q,w,E.spatialReference,C,v))return Me.requiresAlignment(ue)?(He=Me.applyElevationAlignmentBuffer(w,C,J,ie,v,E,K,ue),Le=J,Fe=ie):(Le=w,Fe=C),(0,q.CM)(Le,E.spatialReference,Fe,J,K.spatialReference,ie,v)?He:void 0}function W(P,T,Q,w,C){const J=((0,M.f)(P)?P.z:(0,V.Fb)(P)?P.array[P.offset+2]:P[2])||0;switch(Q.mode){case"on-the-ground":{const ie=(0,m.Pt)((0,V.KO)(T,P,"ground"),0);return C.verticalDistanceToGround=0,C.sampledElevation=ie,void(C.z=ie)}case"relative-to-ground":{const ie=(0,m.Pt)((0,V.KO)(T,P,"ground"),0),v=Q.geometryZWithOffset(J,w);return C.verticalDistanceToGround=v,C.sampledElevation=ie,void(C.z=v+ie)}case"relative-to-scene":{const ie=(0,m.Pt)((0,V.KO)(T,P,"scene"),0),v=Q.geometryZWithOffset(J,w);return C.verticalDistanceToGround=v,C.sampledElevation=ie,void(C.z=v+ie)}case"absolute-height":{const ie=Q.geometryZWithOffset(J,w),v=(0,m.Pt)((0,V.KO)(T,P,"ground"),0);return C.verticalDistanceToGround=ie-v,C.sampledElevation=v,void(C.z=ie)}default:return void(C.z=0)}}function x(P,T,Q,w){return W(P,T,Q,w,L),L.z}function $(P,T,Q){return null==T||null==Q?P.definedChanged:"on-the-ground"===T&&"on-the-ground"===Q?P.staysOnTheGround:T===Q||"on-the-ground"!==T&&"on-the-ground"!==Q?y.UPDATE:P.onTheGroundChanged}function X(P){return"relative-to-ground"===P||"relative-to-scene"===P}function O(P){return"absolute-height"!==P}function U(P,T,Q,w,C){W(T,Q,C,w,L),(0,c.CV)(P,L.verticalDistanceToGround);const J=L.sampledElevation,ie=(0,_.c)(B,P.transformation);return Y[0]=T.x,Y[1]=T.y,Y[2]=L.z,(0,q.Bm)(T.spatialReference,Y,ie,w.spatialReference)?P.transformation=ie:console.warn("Could not locate symbol object properly, it might be misplaced"),J}class k{constructor(){this.verticalDistanceToGround=0,this.sampledElevation=0,this.z=0}}(P=y||(y={}))[P.NONE=0]="NONE",P[P.UPDATE=1]="UPDATE",P[P.RECREATE=2]="RECREATE";const I={"absolute-height":{applyElevationAlignmentBuffer:function te(P,T,Q,w,C,J,ie,v){const E=v.calculateOffsetRenderUnits(ie),K=v.featureExpressionInfoContext;T*=3,w*=3;for(let ue=0;ue<C;++ue){const Le=P[T+1],Fe=P[T+2];Q[w+0]=P[T+0],Q[w+1]=Le,Q[w+2]=null==K?Fe+E:E,T+=3,w+=3}return 0},requiresAlignment:function se(P){return 0!==P.meterUnitOffset||null!=P.featureExpressionInfoContext}},"on-the-ground":{applyElevationAlignmentBuffer:function ce(P,T,Q,w,C,J){let ie=0;const v=J.spatialReference;T*=3,w*=3;for(let E=0;E<C;++E){const K=P[T+0],ue=P[T+1],Le=(0,m.Pt)(J.getElevation(K,ue,P[T+2],v,"ground"),0);ie+=Le,Q[w+0]=K,Q[w+1]=ue,Q[w+2]=Le,T+=3,w+=3}return ie/C},requiresAlignment:()=>!0},"relative-to-ground":{applyElevationAlignmentBuffer:function ye(P,T,Q,w,C,J,ie,v){let E=0;const K=v.calculateOffsetRenderUnits(ie),ue=v.featureExpressionInfoContext,Me=J.spatialReference;T*=3,w*=3;for(let Le=0;Le<C;++Le){const Fe=P[T+0],He=P[T+1],Ke=P[T+2],Xe=(0,m.Pt)(J.getElevation(Fe,He,Ke,Me,"ground"),0);E+=Xe,Q[w+0]=Fe,Q[w+1]=He,Q[w+2]=null==ue?Ke+Xe+K:Xe+K,T+=3,w+=3}return E/C},requiresAlignment:()=>!0},"relative-to-scene":{applyElevationAlignmentBuffer:function F(P,T,Q,w,C,J,ie,v){let E=0;const K=v.calculateOffsetRenderUnits(ie),ue=v.featureExpressionInfoContext,Me=J.spatialReference;T*=3,w*=3;for(let Le=0;Le<C;++Le){const Fe=P[T+0],He=P[T+1],Ke=P[T+2],Xe=(0,m.Pt)(J.getElevation(Fe,He,Ke,Me,"scene"),0);E+=Xe,Q[w+0]=Fe,Q[w+1]=He,Q[w+2]=null==ue?Ke+Xe+K:Xe+K,T+=3,w+=3}return E/C},requiresAlignment:()=>!0}},B=(0,g.c)(),L=new k,Y=(0,b.c)()},74746:(Ve,Ee,a)=>{a.d(Ee,{O$:()=>U,Tz:()=>x,WI:()=>O,aO:()=>$,d9:()=>c,ht:()=>X,kr:()=>H});var m=a(15861),_=a(63290),g=a(10699),b=a(84786),q=a(46679);const M=_.Z.getLogger("esri.views.3d.layers.graphics.featureExpressionInfoUtils");function c(F){return{cachedResult:F.cachedResult,arcade:F.arcade?{func:F.arcade.func,context:F.arcade.modules.arcadeUtils.createExecContext(null,{sr:F.arcade.context.spatialReference}),modules:F.arcade.modules}:null}}function H(F,se,te,k){return W.apply(this,arguments)}function W(){return(W=(0,m.Z)(function*(F,se,te,k){const y=F&&F.expression;if("string"!=typeof y)return null;const I=ye(y);if(null!=I)return{cachedResult:I};const B=yield(0,q.LC)();(0,g.k_)(te);const L=B.arcadeUtils,Y=L.createSyntaxTree(y);return L.dependsOnView(Y)?(k?.error("Expressions containing '$view' are not supported on ElevationInfo"),{cachedResult:0}):{arcade:{func:L.createFunction(Y),context:L.createExecContext(null,{sr:se}),modules:B}}})).apply(this,arguments)}function x(F,se,te){return F.arcadeUtils.createFeature(se.attributes,se.geometry,te)}function $(F,se){if(null!=F&&!ce(F)){if(!se||!F.arcade)return void M.errorOncePerTick("Arcade support required but not provided");se._geometry&&(se._geometry=(0,b.kB)(se._geometry)),F.arcade.modules.arcadeUtils.updateExecContext(F.arcade.context,se)}}function X(F){if(null!=F){if(ce(F))return F.cachedResult;const se=F.arcade;let te=se?.modules.arcadeUtils.executeFunction(se.func,se.context);return"number"!=typeof te&&(F.cachedResult=0,te=0),te}return 0}function O(F,se=!1){let te=F&&F.featureExpressionInfo;return se||"0"===(te&&te.expression)||(te=null),te??null}const U={cachedResult:0};function ce(F){return null!=F.cachedResult}function ye(F){return"0"===F?0:null}},67225:(Ve,Ee,a)=>{a.d(Ee,{CV:()=>y,Go:()=>k,Si:()=>w,Uu:()=>I,ZL:()=>T,_Z:()=>Q,bD:()=>L,bh:()=>P,zE:()=>ce});var m=a(62208),_=a(16730),g=a(28347),b=a(43703),q=a(28093),M=a(993),c=a(4794),V=a(55915),H=a(5548),W=a(65401),x=a(27105),$=a(25748),X=a(38114),O=a(84786),U=a(16396);function ce(C,J){if("point"===C.type)return te(C,J,!1);if((0,O.Ou)(C))switch(C.type){case"extent":return te(C.center,J,!1);case"polygon":return te(C.centroid,J,!1);case"polyline":return te(ye(C),J,!0);case"mesh":return te(C.origin,J,!1)}else switch(C.type){case"extent":return te(function F(C){return(0,X.Tx)(.5*(C.xmax+C.xmin),.5*(C.ymax+C.ymin),null!=C.zmin&&null!=C.zmax&&isFinite(C.zmin)&&isFinite(C.zmax)?.5*(C.zmax+C.zmin):void 0,C.spatialReference)}(C),J,!0);case"polygon":return te(function se(C){const J=C.rings[0];if(!J||0===J.length)return null;const ie=(0,x.a)(C.rings,!!C.hasZ);return(0,X.Tx)(ie[0],ie[1],ie[2],C.spatialReference)}(C),J,!0);case"polyline":return te(ye(C),J,!0)}}function ye(C){const J=C.paths[0];if(!J||0===J.length)return null;const ie=(0,$.n8)(J,(0,$.ok)(J)/2);return(0,X.Tx)(ie[0],ie[1],ie[2],C.spatialReference)}function te(C,J,ie){const v=ie?C:(0,O.WG)(C);return J&&C?(0,V.nF)(C,v,J)?v:null:v}function k(C,J,ie,v=0){if(C){J||(J=(0,W.Ue)());let K=.5*C.width*(ie-1),ue=.5*C.height*(ie-1);return C.width<1e-7*C.height?K+=ue/20:C.height<1e-7*C.width&&(ue+=K/20),(0,M.s)(J,C.xmin-K-v,C.ymin-ue-v,C.xmax+K+v,C.ymax+ue+v),J}return null}function y(C,J){for(let ie=0;ie<C.geometries.length;++ie){const v=C.geometries[ie].getMutableAttribute(U.T.AUXPOS1);v&&v.data[3]!==J&&(v.data[3]=J,C.geometryVertexAttrsUpdated(C.geometries[ie]))}}function I(C,J){const ie=(0,c.d)(c.O);return(0,m.pC)(C)&&(ie[0]=C[0],ie[1]=C[1],ie[2]=C[2]),(0,m.pC)(J)?ie[3]=J:(0,m.pC)(C)&&C.length>3&&(ie[3]=C[3]),ie}function L(C=q.O,J,ie,v=1){const E=new Array(3);if((0,m.Wi)(J)||(0,m.Wi)(ie))E[0]=1,E[1]=1,E[2]=1;else{let K,ue=0;for(let Me=2;Me>=0;Me--){const Le=C[Me];let Fe;const He=null!=Le,Xe=ie[Me];"symbol-value"===Le||0===Me&&!K&&!He?Fe=0!==Xe?J[Me]/Xe:1:He&&"proportional"!==Le&&isFinite(Le)&&(Fe=0!==Xe?Le/Xe:1),null!=Fe&&(E[Me]=Fe,K=Fe,ue=Math.max(ue,Math.abs(Fe)))}for(let Me=2;Me>=0;Me--)null==E[Me]?E[Me]=K:0===E[Me]&&(E[Me]=.001*ue)}for(let K=2;K>=0;K--)E[K]/=v;return(0,q.d)(E)}function P(C){return T(function Y(C){return null!=C.isPrimitive}(C)?[C.width,C.depth,C.height]:C)?null:"Symbol sizes may not be negative values"}function T(C){if(Array.isArray(C)){for(const J of C)if(!T(J))return!1;return!0}return null==C||C>=0}function Q(C,J,ie,v=(0,b.c)()){const E=C||0,K=J||0,ue=ie||0;return 0!==E&&(0,g.o)(v,v,-E/180*Math.PI),0!==K&&(0,g.r)(v,v,K/180*Math.PI),0!==ue&&(0,g.n)(v,v,ue/180*Math.PI),v}function w(C,J,ie){if(null!=ie.minDemResolution)return ie.minDemResolution;const v=(0,_.c9)(J),E=(0,H.bf)(C)*v,K=(0,H.Ye)(C)*v,ue=(0,H.Cb)(C)*(J.isGeographic?1:v);return 0===E&&0===K&&0===ue?ie.minDemResolutionForPoints:.01*Math.max(E,K,ue)}},62600:(Ve,Ee,a)=>{var m,_,g,b;a.d(Ee,{Lw:()=>m,al:()=>g,eZ:()=>_}),(b=m||(m={}))[b.RasterImage=0]="RasterImage",b[b.Features=1]="Features",function(b){b[b.MapLayer=0]="MapLayer",b[b.ViewLayer=1]="ViewLayer",b[b.Outline=2]="Outline",b[b.SnappingHint=3]="SnappingHint"}(_||(_={})),function(b){b[b.WithRasterImage=0]="WithRasterImage",b[b.WithoutRasterImage=1]="WithoutRasterImage"}(g||(g={}))},53929:(Ve,Ee,a)=>{a.d(Ee,{Fb:()=>b,KO:()=>q,sb:()=>g});var m=a(62208),_=a(88530);class g{constructor(c,V=null,H=0){this.array=c,this.spatialReference=V,this.offset=H}}function b(M){return"array"in M}function q(M,c,V="ground"){if((0,_.f)(c))return M.getElevation(c.x,c.y,c.z||0,c.spatialReference,V);if(b(c)){let H=c.offset;return M.getElevation(c.array[H++],c.array[H++],c.array[H]||0,(0,m.Pt)(c.spatialReference,M.spatialReference),V)}return M.getElevation(c[0],c[1],c[2]||0,M.spatialReference,V)}},4511:(Ve,Ee,a)=>{a.d(Ee,{K:()=>g});var m=a(67969),_=a(40852);function g(M,c=0){const V=M.stride;return M.fieldNames.filter(H=>{const W=M.fields.get(H).optional;return!(W&&W.glPadding)}).map(H=>{const W=M.fields.get(H),x=W.constructor.ElementCount,$=function b(M){const c=q[M];if(c)return c;throw new Error("BufferType not supported in WebGL")}(W.constructor.ElementType);return new _.G(H,x,$,W.offset,V,!(!W.optional||!W.optional.glNormalized),c)})}const q={u8:m.g.UNSIGNED_BYTE,u16:m.g.UNSIGNED_SHORT,u32:m.g.UNSIGNED_INT,i8:m.g.BYTE,i16:m.g.SHORT,i32:m.g.INT,f32:m.g.FLOAT}},79020:(Ve,Ee,a)=>{a.d(Ee,{Y:()=>U});var m=a(62208),_=a(67831),g=a(84161),b=a(28093),q=a(4794),M=a(92383),c=a(55915),V=a(59617),H=a(94255),W=a(24425),x=a(6040),$=a(25833),X=a(44968),O=a(16396);function U(T,Q,w=null){const C=[],J=[],ie=Q.mapPositions;!function ce(T,Q,w){const{attributeData:{position:C},removeDuplicateStartEnd:J}=T,ie=function B(T){const Q=T.length;return T[0]===T[Q-3]&&T[1]===T[Q-2]&&T[2]===T[Q-1]}(C)&&J,v=C.length/3-(ie?1:0),E=new Array(2*(v-1)),K=ie?C.slice(0,C.length-3):C;let ue=0;for(let Me=0;Me<v-1;Me++)E[ue++]=Me,E[ue++]=Me+1;Q.push([O.T.POSITION,new H.a(K,3,ie)]),w.push([O.T.POSITION,E])}(Q,J,C);const v=J[0][1].data,K=new Array(C[0][1].length).fill(0);return function ye(T,Q,w,C){if((0,m.pC)(T.attributeData.colorFeature))return;Q.push([O.T.COLOR,new H.a((0,m.Pt)(T.attributeData.color,q.O),4)]),w.push([O.T.COLOR,C])}(Q,J,C,K),function te(T,Q,w,C){if((0,m.pC)(T.attributeData.sizeFeature))return;Q.push([O.T.SIZE,new H.a([(0,m.Pt)(T.attributeData.size,1)],1,!0)]),w.push([O.T.SIZE,C])}(Q,J,C,K),function F(T,Q,w,C){if(!(0,m.pC)(T.attributeData.normal))return;Q.push([O.T.NORMAL,new H.a(T.attributeData.normal,3)]),w.push([O.T.NORMAL,C])}(Q,J,C,K),function se(T,Q,w,C){const J=T.attributeData.colorFeature;(0,m.Wi)(J)||(Q.push([O.T.COLORFEATUREATTRIBUTE,new H.a([J],1,!0)]),w.push([O.T.COLOR,C]))}(Q,J,C,K),function k(T,Q,w,C){const J=T.attributeData.sizeFeature;(0,m.Wi)(J)||(Q.push([O.T.SIZEFEATUREATTRIBUTE,new H.a([J],1,!0)]),w.push([O.T.SIZEFEATUREATTRIBUTE,C]))}(Q,J,C,K),function y(T,Q,w,C){const J=T.attributeData.opacityFeature;(0,m.Wi)(J)||(Q.push([O.T.OPACITYFEATUREATTRIBUTE,new H.a([J],1,!0)]),w.push([O.T.OPACITYFEATUREATTRIBUTE,C]))}(Q,J,C,K),function I(T,Q,w,C){if((0,m.Wi)(T.overlayInfo)||T.overlayInfo.renderCoordsHelper.viewingMode!==V.JY.Global||!T.overlayInfo.spatialReference.isGeographic)return;const J=(0,x.bg)(C.length),ie=(0,M.Iu)(T.overlayInfo.spatialReference);for(let Fe=0;Fe<J.length;Fe+=3)(0,c.gH)(C,Fe,J,Fe,ie);const v=C.length/3,E=(0,$.xx)(v+1);let K=L,ue=Y,Me=0,Le=0;(0,g.s)(K,J[Le++],J[Le++],J[Le++]),E[0]=0;for(let Fe=1;Fe<v+1;++Fe)Fe===v&&(Le=0),(0,g.s)(ue,J[Le++],J[Le++],J[Le++]),Me+=(0,_.p)(K,ue),E[Fe]=Me,[K,ue]=[ue,K];Q.push([O.T.DISTANCETOSTART,new H.a(E,1,!0)]),w.push([O.T.DISTANCETOSTART,w[0][1]])}(Q,J,C,v),new X.Z(T,J,C,ie,W.U.Line,w)}const L=(0,b.c)(),Y=(0,b.c)()},81805:(Ve,Ee,a)=>{a.d(Ee,{Ch:()=>g,Hl:()=>M,_Z:()=>q,uM:()=>c,vT:()=>_});var m=a(8782);const _=64,g=_/2,b=g/5,q=_/b,M=.25;function c(V,H){return V.fromData(`${H}-marker`,()=>(0,m.cU)(H,_,g,b))}},8782:(Ve,Ee,a)=>{a.d(Ee,{Ns:()=>M,Ph:()=>q,cU:()=>c}),a(8314);var _=a(36161),g=a(9983),b=a(67969);const q=128,M=.5;function c(k,y=q,I=y*M,B=0){const L=function V(k,y=q,I=y*M,B=0){switch(k){case"circle":default:return function H(k,y){const I=k/2-.5;return te(k,F(I,I,y/2))}(y,I);case"square":return function W(k,y){return ce(k,y,!1)}(y,I);case"cross":return function $(k,y,I=0){return ye(k,y,!1,I)}(y,I,B);case"x":return function X(k,y,I=0){return ye(k,y,!0,I)}(y,I,B);case"kite":return function x(k,y){return ce(k,y,!0)}(y,I);case"triangle":return function O(k,y){return te(k,se(k/2,y,y/2))}(y,I);case"arrow":return function U(k,y){const I=y,B=y/2,L=k/2,Y=.8*I,P=F(L,(k-y)/2-Y,Math.sqrt(Y*Y+B*B)),T=se(L,I,B);return te(k,(Q,w)=>Math.max(T(Q,w),-P(Q,w)))}(y,I)}}(k,y,I,B);return new g.x(L,{mipmap:!1,wrap:{s:b.e8.CLAMP_TO_EDGE,t:b.e8.CLAMP_TO_EDGE},width:y,height:y,components:4,noUnpackFlip:!0})}function ce(k,y,I){return I&&(y/=Math.SQRT2),te(k,(B,L)=>{let Y=B-.5*k+.25,P=.5*k-L-.75;if(I){const T=(Y+P)/Math.SQRT2;P=(P-Y)/Math.SQRT2,Y=T}return Math.max(Math.abs(Y),Math.abs(P))-.5*y})}function ye(k,y,I,B=0){y-=B,I&&(y*=Math.SQRT2);const L=.5*y;return te(k,(Y,P)=>{let T,Q=Y-.5*k,w=.5*k-P-1;if(I){const C=(Q+w)/Math.SQRT2;w=(w-Q)/Math.SQRT2,Q=C}return Q=Math.abs(Q),w=Math.abs(w),T=Q>w?Q>L?Math.sqrt((Q-L)*(Q-L)+w*w):w:w>L?Math.sqrt(Q*Q+(w-L)*(w-L)):Q,T-=B/2,T})}function F(k,y,I){return(B,L)=>{const Y=B-k,P=L-y;return Math.sqrt(Y*Y+P*P)-I}}function se(k,y,I){const B=Math.sqrt(y*y+I*I);return(L,Y)=>{const P=Math.abs(L-k)-I,T=Y-k+y/2+.75;return Math.max((y*P+I*T)/B,-T)}}function te(k,y){const I=new Uint8Array(4*k*k);for(let B=0;B<k;B++)for(let L=0;L<k;L++){const Y=L+k*B;let P=y(L,B);P=P/k+.5,(0,_.I)(P,I,4*Y)}return I}},27632:(Ve,Ee,a)=>{a.d(Ee,{V:()=>c,r:()=>V});var m=a(62208),_=a(55915),g=a(85334),b=a(81468),q=a(46021),M=a(6040);function c(W,x,$,X){const O="polygon"===W.type?g.ZI.CCW_IS_HOLE:g.ZI.NONE,U="polygon"===W.type?W.rings:W.paths,{position:ce,outlines:ye}=(0,g.Mk)(U,!!W.hasZ,O),F=(0,M.bg)(ce.length),se=(0,b.rR)(ce,W.spatialReference,0,F,0,ce,0,ce.length/3,x,$,X),te=null!=se;return{lines:te?H(ye,ce,F):[],projectionSuccess:te,sampledElevation:se}}function V(W,x){const $="polygon"===W.type?g.ZI.CCW_IS_HOLE:g.ZI.NONE,X="polygon"===W.type?W.rings:W.paths,{position:O,outlines:U}=(0,g.Mk)(X,!1,$),ce=(0,_.CM)(O,W.spatialReference,0,O,x,0,O.length/3);for(let ye=2;ye<O.length;ye+=3)O[ye]=q.Rn;return{lines:ce?H(U,O):[],projectionSuccess:ce}}function H(W,x,$=null){const X=new Array;for(const{index:O,count:U}of W){if(U<=1)continue;const ce=3*O,ye=3*U;X.push({position:(0,M.Rq)(x,3*O,3*U),mapPositions:(0,m.pC)($)?(0,M.Rq)($,ce,ye):void 0})}return X}},46021:(Ve,Ee,a)=>{a.d(Ee,{Rn:()=>rs});var k,y,I,B,L,Y,P,h,m=a(15861),_=a(17626),g=a(14517),b=a(61885),q=a(72392),M=a(88159),c=a(62208),V=a(77029),H=a(32917),W=a(28862),x=a(77712),X=(a(90912),a(85931)),O=a(76898),U=a(28347),ce=a(84161),ye=a(28093),F=a(59617),se=a(62600),te=a(93605);(h=k||(k={}))[h.INNER=0]="INNER",h[h.OUTER=1]="OUTER",function(h){h[h.REGULAR=0]="REGULAR",h[h.HAS_NORTH_POLE=1]="HAS_NORTH_POLE",h[h.HAS_SOUTH_POLE=2]="HAS_SOUTH_POLE",h[h.HAS_BOTH_POLES=3]="HAS_BOTH_POLES"}(y||(y={})),function(h){h[h.NORTH=0]="NORTH",h[h.NORTH_EAST=1]="NORTH_EAST",h[h.EAST=2]="EAST",h[h.SOUTH_EAST=3]="SOUTH_EAST",h[h.SOUTH=4]="SOUTH",h[h.SOUTH_WEST=5]="SOUTH_WEST",h[h.WEST=6]="WEST",h[h.NORTH_WEST=7]="NORTH_WEST"}(I||(I={})),function(h){h[h.OFF=0]="OFF",h[h.ON=1]="ON"}(B||(B={})),function(h){h[h.Color=0]="Color",h[h.ColorNoRasterImage=1]="ColorNoRasterImage",h[h.Highlight=2]="Highlight",h[h.Water=3]="Water",h[h.Occluded=4]="Occluded",h[h.ObjectAndLayerIdColor=5]="ObjectAndLayerIdColor"}(L||(L={})),function(h){h[h.FADING=0]="FADING",h[h.IMMEDIATE=1]="IMMEDIATE",h[h.UNFADED=2]="UNFADED"}(Y||(Y={})),function(h){h[h.INSIDE=0]="INSIDE",h[h.INTERSECTS=1]="INTERSECTS",h[h.OUTSIDE=2]="OUTSIDE"}(P||(P={}));var C,T=a(65401),Q=a(42743),w=a(30993);!function(h){h[h.None=0]="None",h[h.ColorAndWater=1]="ColorAndWater",h[h.Highlight=2]="Highlight",h[h.Occluded=3]="Occluded",h[h.ObjectAndLayerIdColor=4]="ObjectAndLayerIdColor"}(C||(C={}));class J{get extent(){return this._extent}constructor(l,p){this.index=l,this.renderTargets=p,this._extent=(0,T.Ue)(),this.resolution=0,this.renderLocalOrigin=(0,w.a)(0,0,0,"O"),this.pixelRatio=1,this.mapUnitsPerPixel=1,this.canvasGeometries=new ie,this.hasDrapedFeatureSource=!1,this.hasDrapedRasterSource=!1,this.hasTargetWithoutRasterImage=!1,this.index=l,this.validTargets=new Array(p.renderTargets.length).fill(!1)}getValidTexture(l){return this.validTargets[l]?this.renderTargets.getTarget(l).getTexture():null}get _needsColorWithoutRasterImage(){return this.hasDrapedRasterSource&&this.hasDrapedFeatureSource&&this.hasTargetWithoutRasterImage}getColorTexture(l){const p=this.renderTargets.getTarget(l===C.ColorAndWater?L.Color:l===C.Highlight?L.Highlight:l===C.ObjectAndLayerIdColor?L.ObjectAndLayerIdColor:L.Occluded);return p?p.getTexture():null}getColorTextureNoRasterImage(){return this._needsColorWithoutRasterImage?this.getValidTexture(L.ColorNoRasterImage):this.hasDrapedFeatureSource?this.getValidTexture(L.Color):null}getNormalTexture(l){const p=l===C.ColorAndWater?this.renderTargets.getTarget(L.Water):null;return p?p.getTexture():null}draw(l,p){const D=this.computeRenderTargetValidityBitfield();for(const z of this.renderTargets.renderTargets)this.validTargets[z.type]=!(z.type===L.ColorNoRasterImage&&!this._needsColorWithoutRasterImage)&&l.drawTarget(this,z,p);return D^this.computeRenderTargetValidityBitfield()?Q.Yg.CHANGED:Q.Yg.UNCHANGED}computeRenderTargetValidityBitfield(){const l=this.validTargets;return+l[L.Color]|+l[L.ColorNoRasterImage]<<1|+l[L.Highlight]<<2|+l[L.Water]<<3|+l[L.Occluded]<<4}setupGeometryViewsCyclical(l){this.setupGeometryViewsDirect();const p=.001*l.range;if(this._extent[0]-p<=l.min){const D=this.canvasGeometries.extents[this.canvasGeometries.numViews++];(0,T.cv)(this._extent,l.range,0,D)}if(this._extent[2]+p>=l.max){const D=this.canvasGeometries.extents[this.canvasGeometries.numViews++];(0,T.cv)(this._extent,-l.range,0,D)}}setupGeometryViewsDirect(){this.canvasGeometries.numViews=1,(0,T.JG)(this.canvasGeometries.extents[0],this._extent)}hasSomeSizedView(){for(let l=0;l<this.canvasGeometries.numViews;l++){const p=this.canvasGeometries.extents[l];if(p[0]!==p[2]&&p[1]!==p[3])return!0}return!1}applyViewport(l){l.setViewport(this.index===k.INNER?0:this.resolution,0,this.resolution,this.resolution)}}class ie{constructor(){this.extents=[(0,T.Ue)(),(0,T.Ue)(),(0,T.Ue)()],this.numViews=0}}var v=a(9545),E=a(67969),K=a(85775);class ue{constructor(l,p){this._size=(0,v.c)(),this._fbo=null,this._fbo=new K.X(l,{colorTarget:E.Lm.TEXTURE,depthStencilTarget:E.OU.NONE},{target:E.No.TEXTURE_2D,pixelFormat:E.VI.RGBA,dataType:E.Br.UNSIGNED_BYTE,wrapMode:E.e8.CLAMP_TO_EDGE,samplingMode:E.cw.LINEAR_MIPMAP_LINEAR,hasMipmap:p,maxAnisotropy:8,width:0,height:0})}dispose(){this._fbo=(0,c.M2)(this._fbo)}getTexture(){return this._fbo?this._fbo.colorTexture:null}isValid(){return null!==this._fbo}resize(l,p){this._size[0]=l,this._size[1]=p,this._fbo.resize(this._size[0],this._size[1])}bind(l){l.bindFramebuffer(this._fbo)}generateMipMap(){const l=this._fbo.colorTexture;l.descriptor.hasMipmap&&l.generateMipmap()}disposeRenderTargetMemory(){this._fbo?.resize(0,0)}get gpuMemoryUsage(){return this._fbo?.gpuMemoryUsage??0}}var Me=a(8314),Le=a(13934);class Fe{constructor(l,p,D,z=!0){this.output=p,this.type=D,this.valid=!1,this.lastUsed=1/0,this.fbo=new ue(l,z)}}class He{constructor(l){this.renderTargets=[new Fe(l,Le.H.Color,L.Color),new Fe(l,Le.H.Color,L.ColorNoRasterImage),new Fe(l,Le.H.Highlight,L.Highlight,!1),new Fe(l,Le.H.Normal,L.Water),new Fe(l,Le.H.Color,L.Occluded)],(0,Me.Z)("enable-feature:objectAndLayerId-rendering")&&this.renderTargets.push(new Fe(l,Le.H.ObjectAndLayerIdColor,L.ObjectAndLayerIdColor))}getTarget(l){return this.renderTargets[l].fbo}dispose(){for(const l of this.renderTargets)l.fbo.dispose()}disposeRenderTargetMemory(){for(const l of this.renderTargets)l.fbo.disposeRenderTargetMemory()}validateUsageForTarget(l,p,D){if(l)p.lastUsed=D;else if(D-p.lastUsed>Ke)p.fbo.disposeRenderTargetMemory(),p.lastUsed=1/0;else if(p.lastUsed<1/0)return!0;return!1}get gpuMemoryUsage(){return this.renderTargets.reduce((l,p)=>l+p.fbo.gpuMemoryUsage,0)}}const Ke=1e3;var Xe=a(98361),Ge=a(1101),tt=a(87601);class Ye{constructor(l){this._context=l,this._perConstructorInstances=new Ge.r,this._frameCounter=0,this._keepAliveFrameCount=Ut}get viewingMode(){return this._context.viewingMode}get constructionContext(){return this._context}destroy(){this._perConstructorInstances.forEach(l=>l.forEach(p=>p.technique.destroy())),this._perConstructorInstances.clear()}acquire(l,p=qe){const D=p.key;let z=this._perConstructorInstances.get(l,D);if((0,c.Wi)(z)){const Ce=new l(this._context,p,()=>this.release(Ce));z=new ke(Ce),this._perConstructorInstances.set(l,D,z)}return++z.refCount,z.technique}releaseAndAcquire(l,p,D){if((0,c.pC)(D)){if(p.key===D.key)return D;this.release(D)}return this.acquire(l,p)}release(l){if((0,c.Wi)(l)||this._perConstructorInstances.empty)return;const p=this._perConstructorInstances.get(l.constructor,l.key);(0,c.Wi)(p)||(--p.refCount,0===p.refCount&&(p.refZeroFrame=this._frameCounter))}frameUpdate(){this._frameCounter++,this._keepAliveFrameCount!==Ut&&this._perConstructorInstances.forEach((l,p)=>{l.forEach((D,z)=>{0===D.refCount&&D.refZeroFrame+this._keepAliveFrameCount<this._frameCounter&&(D.technique.destroy(),this._perConstructorInstances.delete(p,z))})})}reloadAll(){var l=this;return(0,m.Z)(function*(){const p=new Array;l._perConstructorInstances.forEach((D,z)=>{const Ce=function(){var we=(0,m.Z)(function*(Be,ze){const $e=ze.shader;$e&&(yield $e.reload(),Be.forEach(st=>st.technique.reload(l._context)))});return function(ze,$e){return we.apply(this,arguments)}}();p.push(Ce(D,z))}),yield Promise.all(p)})()}}class ke{constructor(l){this.technique=l,this.refCount=0,this.refZeroFrame=0}}const Ut=-1,qe=new tt.m;var vt=a(59598),Dt=a(63290),it=a(2282);class yt{constructor(l,p,D,z){this._textureRepository=l,this._techniqueRepository=p,this.materialChanged=D,this.requestRender=z,this._id2glMaterialRef=new Ge.r}dispose(){this._textureRepository.destroy()}acquire(l,p,D){if(this._ownMaterial(l),!l.requiresSlot(p,D))return null;let z=this._id2glMaterialRef.get(D,l.id);if((0,c.Wi)(z)){const Ce=l.createGLMaterial({material:l,techniqueRep:this._techniqueRepository,textureRep:this._textureRepository,output:D});z=new At(Ce),this._id2glMaterialRef.set(D,l.id,z)}return z.ref(),z.glMaterial}release(l,p){const D=this._id2glMaterialRef.get(p,l.id);(0,c.pC)(D)&&(D.unref(),D.referenced||((0,c.M2)(D.glMaterial),this._id2glMaterialRef.delete(p,l.id)))}_ownMaterial(l){(0,c.pC)(l.repository)&&l.repository!==this&&Dt.Z.getLogger("esri.views.3d.webgl-engine.lib.GLMaterialRepository").error("Material is already owned by a different material repository"),l.repository=this}}class At{constructor(l){this.glMaterial=l,this._refCnt=0}ref(){++this._refCnt}unref(){--this._refCnt,(0,it.hu)(this._refCnt>=0)}get referenced(){return this._refCnt>0}}var Ot=a(77172),Et=a(32042),ct=a(40723),Qe=a(99770),G=a(12015),_e=a(82793),re=a(10109),ne=a(45867),ve=a(5894),Z=a(44835),j=a(95279);class he{constructor(l,p,D){this.shadowMap=l,this.ssaoHelper=p,this.slicePlane=D,this.slot=ve.r.OPAQUE_MATERIAL,this.hasOccludees=!1,this.enableFillLights=!0,this.transparencyPassType=Z.A.NONE,this._camera=new vt.V,this._inverseViewport=(0,Qe.a)(),this.oldLighting=new j.c,this.newLighting=new j.c,this._fadedLighting=new j.c,this._lighting=this.newLighting,this.ssr=new ne.O,this.multipassTerrain=new re.a,this.multipassGeometry=new _e._,this.overlays=[],this.cloudsFade=new G.ii}get camera(){return this._camera}set camera(l){this._camera=this.ssr.camera=l,this._inverseViewport[0]=1/l.fullViewport[2],this._inverseViewport[1]=1/l.fullViewport[3]}get inverseViewport(){return this._inverseViewport}get lighting(){return this._lighting}get weatherFading(){return this._lighting===this._fadedLighting}fadeLighting(l){const{oldLighting:p,newLighting:D}=this;l>=1?this._lighting=D:(this._fadedLighting.lerpLighting(p,D,l),this._lighting=this._fadedLighting)}}class ae{constructor(l,p,D,z=null){this.rctx=l,this.sliceHelper=z,this.lastFrameCamera=new vt.V,this.output=Le.H.Color,this.renderOccludedMask=xe,this.bindParameters=new he(p,D,(0,c.pC)(z)?z.plane:null)}resetRenderOccludedMask(){this.renderOccludedMask=xe}}const xe=ct.yD.Occlude|ct.yD.OccludeAndTransparent|ct.yD.OccludeAndTransparentStencil;var Oe=a(21286),de=a(550),me=a(43703),oe=a(67831),be=a(993),je=a(4794);let Te=class extends vt.V{constructor(){super(...arguments),this._projectionMatrix=(0,me.c)()}get projectionMatrix(){return this._projectionMatrix}};(0,_._)([(0,x.Cb)()],Te.prototype,"_projectionMatrix",void 0),(0,_._)([(0,x.Cb)({readOnly:!0})],Te.prototype,"projectionMatrix",null),Te=(0,_._)([(0,O.j)("esri.views.3d.webgl-engine.lib.CascadeCamera")],Te);var le,ee=a(55086),fe=a(26906);!function(h){h[h.Highlight=0]="Highlight",h[h.Default=1]="Default"}(le||(le={}));class pe{constructor(){this.camera=new Te,this.lightMat=(0,me.c)()}}class Se{get depthTexture(){return this._depthTexture}get textureSize(){return this._textureSize}get numCascades(){return this._numCascades}get cascadeDistances(){return(0,be.s)(this._usedCascadeDistances,this._cascadeDistances[0],this._numCascades>1?this._cascadeDistances[1]:1/0,this._numCascades>2?this._cascadeDistances[2]:1/0,this._numCascades>3?this._cascadeDistances[3]:1/0)}constructor(l,p){this._rctx=l,this._viewingMode=p,this._enabled=!1,this._snapshots=new Array,this._textureSize=0,this._numCascades=1,this._maxNumCascades=4,this._projectionView=(0,me.c)(),this._projectionViewInverse=(0,me.c)(),this._modelViewLight=(0,me.c)(),this._splitSchemeLambda=0,this._cascadeDistances=[0,0,0,0,0],this._usedCascadeDistances=(0,je.c)(),this._cascades=[new pe,new pe,new pe,new pe],this._lastOrigin=null,this._maxTextureSize=Math.min((0,Me.Z)("esri-mobile")?2048:8192,this._rctx.parameters.maxTextureSize)}dispose(){this.enabled=!1,this.disposeOffscreenBuffers()}disposeOffscreenBuffers(){this._discardDepthTexture(),this._discardAllSnapshots()}set maxCascades(l){this._maxNumCascades=(0,Oe.uZ)(Math.floor(l),1,4)}get maxCascades(){return this._maxNumCascades}set enabled(l){this._enabled=l,l||(this._discardDepthTexture(),this._discardAllSnapshots())}get enabled(){return this._enabled}get ready(){return this._enabled&&(0,c.pC)(this._depthTexture)}getSnapshot(l){return this.enabled?this._snapshots[l]:null}get cascades(){for(let l=0;l<this._numCascades;++l)ot[l]=this._cascades[l];return ot.length=this._numCascades,ot}start(l,p,D){(0,it.hu)(this.enabled),this._textureSize=this._computeTextureSize(l.fullWidth,l.fullHeight),this._ensureDepthTexture();const{near:z,far:Ce}=this._clampNearFar(D);this._computeCascadeDistances(Ce,z),this._setupMatrices(l,p);const{viewMatrix:we,projectionMatrix:Be}=l;for(let ze=0;ze<this._numCascades;++ze)this._constructCascade(ze,Be,we,p);this._lastOrigin=null,this.clear()}finish(l){(0,it.hu)(this.enabled),this._rctx.bindFramebuffer(l)}getShadowMapMatrices(l){if(!this._lastOrigin||!(0,ce.k)(l,this._lastOrigin)){this._lastOrigin=this._lastOrigin||(0,ye.c)(),(0,ce.c)(this._lastOrigin,l);for(let p=0;p<this._numCascades;++p){(0,U.w)(Tt,this._cascades[p].lightMat,l);for(let D=0;D<16;++D)ft[16*p+D]=Tt[D]}}return ft}takeCascadeSnapshotTo(l,p){(0,it.hu)(this.enabled);const D=this._ensureSnapshot(p);this._bindFbo();const z=this._rctx,Ce=z.bindTexture(D,ee.x.TEXTURE_UNIT_FOR_UPDATES);z.gl.copyTexSubImage2D(E.No.TEXTURE_2D,0,l.camera.viewport[0],l.camera.viewport[1],l.camera.viewport[0],l.camera.viewport[1],l.camera.viewport[2],l.camera.viewport[3]),z.bindTexture(Ce,ee.x.TEXTURE_UNIT_FOR_UPDATES)}clear(){const l=this._rctx;this._bindFbo(),l.setClearColor(1,1,1,1),l.clearSafe(E.lk.COLOR_BUFFER_BIT|E.lk.DEPTH_BUFFER_BIT)}_computeTextureSize(l,p){const D=.5*Math.log(l*l+p*p)*Math.LOG2E,Ce=2**Math.round(D+.35);return Math.min(this._maxTextureSize,2*Ce)}_ensureDepthTexture(){(0,c.pC)(this._depthTexture)&&this._depthTexture.descriptor.width===this._textureSize||(this._discardDepthTexture(),this._depthTexture=new ee.x(this._rctx,{target:E.No.TEXTURE_2D,pixelFormat:E.VI.RGBA,dataType:E.Br.UNSIGNED_BYTE,wrapMode:E.e8.CLAMP_TO_EDGE,samplingMode:E.cw.NEAREST,flipped:!0,width:this._textureSize,height:this._textureSize}),this._fbo=new K.X(this._rctx,{colorTarget:E.Lm.TEXTURE,depthStencilTarget:E.OU.DEPTH_RENDER_BUFFER,width:this._textureSize,height:this._textureSize},this._depthTexture))}_ensureSnapshot(l){let p=this._snapshots[l];return(0,c.pC)(p)&&p.descriptor.width===this._textureSize||(this._discardSnapshot(l),p=new ee.x(this._rctx,{target:E.No.TEXTURE_2D,pixelFormat:E.VI.RGBA,dataType:E.Br.UNSIGNED_BYTE,wrapMode:E.e8.CLAMP_TO_EDGE,samplingMode:E.cw.NEAREST,flipped:!0,width:this._textureSize,height:this._textureSize}),this._snapshots[l]=p),p}_discardDepthTexture(){this._fbo=(0,c.M2)(this._fbo),this._depthTexture=(0,c.M2)(this._depthTexture)}_discardSnapshot(l){this._snapshots[l]=(0,c.M2)(this._snapshots[l])}_discardAllSnapshots(){for(let l=0;l<this._snapshots.length;++l)this._discardSnapshot(l);this._snapshots.length=0}_bindFbo(){const l=this._rctx;l.unbindTexture(this._depthTexture),l.bindFramebuffer(this._fbo)}_constructCascade(l,p,D,z){const Ce=this._cascades[l],we=-this._cascadeDistances[l],Be=-this._cascadeDistances[l+1],ze=(p[10]*we+p[14])/Math.abs(p[11]*we+p[15]),$e=(p[10]*Be+p[14])/Math.abs(p[11]*Be+p[15]);(0,it.hu)(ze<$e);for(let Ze=0;Ze<8;++Ze){(0,be.s)(De,Ze%4==0||Ze%4==3?-1:1,Ze%4==0||Ze%4==1?-1:1,Ze<4?ze:$e,1);const pt=Ue[Ze];(0,be.t)(pt,De,this._projectionViewInverse),pt[0]/=pt[3],pt[1]/=pt[3],pt[2]/=pt[3]}(0,ce.o)(ut,Ue[0]),Ce.camera.viewMatrix=(0,U.w)(Ae,this._modelViewLight,ut);for(let Ze=0;Ze<8;++Ze)(0,ce.m)(Ue[Ze],Ue[Ze],Ce.camera.viewMatrix);let st=Ue[0][2],dt=Ue[0][2];for(let Ze=1;Ze<8;++Ze)st=Math.min(st,Ue[Ze][2]),dt=Math.max(dt,Ue[Ze][2]);st-=200,dt+=200,Ce.camera.near=-dt,Ce.camera.far=-st,function vr(h,l,p,D,z){const Ce=1/Ue[0][3],we=1/Ue[4][3];(0,it.hu)(Ce<we);let Be=Ce+Math.sqrt(Ce*we);const ze=Math.sin((0,Oe.ZF)(h[2]*l[0]+h[6]*l[1]+h[10]*l[2]));Be/=ze,function _r(h,l,p,D,z,Ce,we,Be){(0,oe.s)(at,0,0);for(let _t=0;_t<4;++_t)(0,oe.j)(at,at,h[_t]);(0,oe.b)(at,at,.25),(0,oe.s)(nt,0,0);for(let _t=4;_t<8;++_t)(0,oe.j)(nt,nt,h[_t]);(0,oe.b)(nt,nt,.25),(0,oe.l)(Ne[0],h[4],h[5],.5),(0,oe.l)(Ne[1],h[5],h[6],.5),(0,oe.l)(Ne[2],h[6],h[7],.5),(0,oe.l)(Ne[3],h[7],h[4],.5);let ze=0,$e=(0,oe.k)(Ne[0],at);for(let _t=1;_t<4;++_t){const Pt=(0,oe.k)(Ne[_t],at);Pt<$e&&($e=Pt,ze=_t)}(0,oe.a)(lt,Ne[ze],h[ze+4]);const st=lt[0];let dt,ht;lt[0]=-lt[1],lt[1]=st,(0,oe.a)(gt,nt,at),(0,oe.h)(gt,lt)<0&&(0,oe.n)(lt,lt),(0,oe.l)(lt,lt,gt,p),(0,oe.f)(lt,lt),dt=ht=(0,oe.h)((0,oe.a)(mt,h[0],at),lt);for(let _t=1;_t<8;++_t){const Pt=(0,oe.h)((0,oe.a)(mt,h[_t],at),lt);Pt<dt?dt=Pt:Pt>ht&&(ht=Pt)}(0,oe.c)(D,at),(0,oe.b)(mt,lt,dt-l),(0,oe.j)(D,D,mt);let Ze=-1,pt=1,Lt=0,Wt=0;for(let _t=0;_t<8;++_t){(0,oe.a)(St,h[_t],D),(0,oe.f)(St,St);const Pt=lt[0]*St[1]-lt[1]*St[0];Pt>0?Pt>Ze&&(Ze=Pt,Lt=_t):Pt<pt&&(pt=Pt,Wt=_t)}(0,it.T)(Ze>0,"leftArea"),(0,it.T)(pt<0,"rightArea"),(0,oe.b)(It,lt,dt),(0,oe.j)(It,It,at),(0,oe.b)(Ct,lt,ht),(0,oe.j)(Ct,Ct,at),zt[0]=-lt[1],zt[1]=lt[0];const xt=(0,it.ep)(D,h[Wt],Ct,(0,oe.j)(mt,Ct,zt),1,z),wt=(0,it.ep)(D,h[Lt],Ct,mt,1,Ce),Ht=(0,it.ep)(D,h[Lt],It,(0,oe.j)(mt,It,zt),1,we),bt=(0,it.ep)(D,h[Wt],It,mt,1,Be);(0,it.T)(xt,"rayRay"),(0,it.T)(wt,"rayRay"),(0,it.T)(Ht,"rayRay"),(0,it.T)(bt,"rayRay")}(Ue,Be,ze,Re,Ie,rt,Pe,Je),function gr(h,l,p,D,z){(0,oe.a)(Mt,p,D),(0,oe.b)(Mt,Mt,.5),We[0]=Mt[0],We[1]=Mt[1],We[2]=0,We[3]=Mt[1],We[4]=-Mt[0],We[5]=0,We[6]=Mt[0]*Mt[0]+Mt[1]*Mt[1],We[7]=Mt[0]*Mt[1]-Mt[1]*Mt[0],We[8]=1,We[et(0,2)]=-(0,oe.h)(Rt(We,0),h),We[et(1,2)]=-(0,oe.h)(Rt(We,1),h);let Ce=(0,oe.h)(Rt(We,0),p)+We[et(0,2)],we=(0,oe.h)(Rt(We,1),p)+We[et(1,2)],Be=(0,oe.h)(Rt(We,0),D)+We[et(0,2)],ze=(0,oe.h)(Rt(We,1),D)+We[et(1,2)];Ce=-(Ce+Be)/(we+ze),We[et(0,0)]+=We[et(1,0)]*Ce,We[et(0,1)]+=We[et(1,1)]*Ce,We[et(0,2)]+=We[et(1,2)]*Ce,Ce=1/((0,oe.h)(Rt(We,0),p)+We[et(0,2)]),we=1/((0,oe.h)(Rt(We,1),p)+We[et(1,2)]),We[et(0,0)]*=Ce,We[et(0,1)]*=Ce,We[et(0,2)]*=Ce,We[et(1,0)]*=we,We[et(1,1)]*=we,We[et(1,2)]*=we,We[et(2,0)]=We[et(1,0)],We[et(2,1)]=We[et(1,1)],We[et(2,2)]=We[et(1,2)],We[et(1,2)]+=1,Ce=(0,oe.h)(Rt(We,1),l)+We[et(1,2)],we=(0,oe.h)(Rt(We,2),l)+We[et(2,2)],Be=(0,oe.h)(Rt(We,1),p)+We[et(1,2)],ze=(0,oe.h)(Rt(We,2),p)+We[et(2,2)],Ce=-.5*(Ce/we+Be/ze),We[et(1,0)]+=We[et(2,0)]*Ce,We[et(1,1)]+=We[et(2,1)]*Ce,We[et(1,2)]+=We[et(2,2)]*Ce,Ce=(0,oe.h)(Rt(We,1),l)+We[et(1,2)],we=(0,oe.h)(Rt(We,2),l)+We[et(2,2)],Be=-we/Ce,We[et(1,0)]*=Be,We[et(1,1)]*=Be,We[et(1,2)]*=Be,z[0]=We[0],z[1]=We[1],z[2]=0,z[3]=We[2],z[4]=We[3],z[5]=We[4],z[6]=0,z[7]=We[5],z[8]=0,z[9]=0,z[10]=1,z[11]=0,z[12]=We[6],z[13]=We[7],z[14]=0,z[15]=We[8]}(Re,Ie,Pe,Je,z.projectionMatrix),z.projectionMatrix[10]=2/(p-D),z.projectionMatrix[14]=-(p+D)/(p-D)}(D,z,st,dt,Ce.camera),(0,U.m)(Ce.lightMat,Ce.camera.projectionMatrix,Ce.camera.viewMatrix);const ht=this._textureSize/2;Ce.camera.viewport=[l%2==0?0:ht,0===Math.floor(l/2)?0:ht,ht,ht]}_setupMatrices(l,p){(0,U.m)(this._projectionView,l.projectionMatrix,l.viewMatrix),(0,U.a)(this._projectionViewInverse,this._projectionView);const D=this._viewingMode===F.JY.Global?l.eye:(0,ce.s)(ut,0,0,1);(0,U.u)(this._modelViewLight,[0,0,0],[-p[0],-p[1],-p[2]],D)}_clampNearFar(l){let{near:p,far:D}=l;return p<2&&(p=2),D<2&&(D=2),p>=D&&(p=2,D=4),{near:p,far:D}}_computeCascadeDistances(l,p){this._numCascades=Math.min(1+Math.floor((0,it.E6)(l/p,4)),this._maxNumCascades);const D=(l-p)/this._numCascades,z=(l/p)**(1/this._numCascades);let Ce=p,we=p;for(let Be=0;Be<this._numCascades+1;++Be)this._cascadeDistances[Be]=(0,Oe.t7)(Ce,we,this._splitSchemeLambda),Ce*=z,we+=D}get gpuMemoryUsage(){return this._snapshots.reduce((l,p)=>l+(0,fe.un)(p),this._fbo?.gpuMemoryUsage??0)}get test(){const l=this;return{maxNumCascades:this._maxNumCascades,cascades:this._cascades,textureSize:this._textureSize,set splitSchemeLambda(p){l._splitSchemeLambda=p},get splitSchemeLambda(){return l._splitSchemeLambda}}}}const Ae=(0,me.c)(),De=(0,je.c)(),Ue=[];for(let h=0;h<8;++h)Ue.push((0,je.c)());const Re=(0,Qe.a)(),Ie=(0,Qe.a)(),rt=(0,Qe.a)(),Pe=(0,Qe.a)(),Je=(0,Qe.a)(),ut=(0,ye.c)(),ot=[],Tt=(0,me.c)(),ft=new Float32Array(64),at=(0,Qe.a)(),nt=(0,Qe.a)(),Ne=[(0,Qe.a)(),(0,Qe.a)(),(0,Qe.a)(),(0,Qe.a)()],lt=(0,Qe.a)(),gt=(0,Qe.a)(),mt=(0,Qe.a)(),St=(0,Qe.a)(),It=(0,Qe.a)(),Ct=(0,Qe.a)(),zt=(0,Qe.a)();function et(h,l){return 3*l+h}const rr=(0,Qe.a)();function Rt(h,l){return(0,oe.s)(rr,h[l],h[l+3]),rr}const Mt=(0,Qe.a)(),We=(0,de.c)();var Qt=a(67857),mr=a(9502);a(91480);class yr extends mr.Dx{constructor(l,p,D){super(l,p),this.triangleNr=D}}class Or{constructor(){this.adds=new V.Z,this.removes=new V.Z,this.updates=new V.Z({allocator:l=>l||new Er,deallocator:l=>(l.renderGeometry=null,l)})}clear(){this.adds.clear(),this.removes.clear(),this.updates.clear()}prune(){this.adds.prune(),this.removes.prune(),this.updates.prune()}get empty(){return 0===this.adds.length&&0===this.removes.length&&0===this.updates.length}}class Er{}class Tr{constructor(){this.adds=new Array,this.removes=new Array,this.updates=new Array}}var Cr=a(62483),Nt=a(54840);function kt(h){return h.geometry.indexCount>=1}var Dr=a(4511),sr=a(83994);class Mr{constructor(l){this._rctx=l,this._indexBuffer=this._createIndexbuffer(),this._program=this._createProgram()}_createProgram(){return this._rctx.programCache.acquire("\n    void main(void) {\n      gl_Position = vec4(0.0, 0.0, float(gl_VertexID)-2.0, 1.0);\n    }","\n    void main(void) {\n      gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }",new Map([]))}_createIndexbuffer(){return sr.f.createIndex(this._rctx,E.l1.STATIC_DRAW,new Uint32Array([0]))}resetIndicesType(){this._program.compiled&&this._indexBuffer&&(this._rctx.bindVAO(null),this._rctx.useProgram(this._program),this._rctx.bindBuffer(this._indexBuffer,E.w0.ELEMENT_ARRAY_BUFFER),this._rctx.drawElements(E.MX.POINTS,1,E.g.UNSIGNED_INT,0))}dispose(){this._program.dispose(),this._indexBuffer.dispose()}}var Ar=a(32393),Sr=a(21799);class Rr extends Sr.Pf{constructor(l=(0,ye.c)()){super(),this.origin=l,this.slicePlaneLocalOrigin=this.origin}}var xr=a(90978);class qt{constructor(l=0,p=0){this.from=l,this.to=p}get numElements(){return this.to-this.from}}function ir(h){const l=new Map;h.forAll(D=>l.set(D.from,D));let p=!0;for(;p;)p=!1,h.forEach(D=>{const z=l.get(D.to);z&&(D.to=z.to,l.delete(z.from),h.removeUnordered(z),p=!0)})}class or extends qt{constructor(l,p,D){super(p,D),this.geometry=l}get isVisible(){return this.geometry.visible}get hasHighlights(){return(0,c.pC)(this.geometry.highlights)&&this.isVisible}get hasOccludees(){return(0,c.pC)(this.geometry.occludees)}}class Ir{constructor(){this.first=0,this.count=0}}class Lr{constructor(){this._numElements=0,this._instances=new Map,this.holes=new V.Z({allocator:l=>l||new qt,deallocator:null}),this.hasHiddenInstances=!1,this.hasHighlights=!1,this.hasOccludees=!1,this.drawCommandsDirty=!0,this.drawCommandsDefault=Gt(),this.drawCommandsHighlight=Gt(),this.drawCommandsOccludees=Gt(),this.drawCommandsShadowHighlightRest=Gt()}get numElements(){return this._numElements}get instances(){return this._instances}addInstance(l,p){this.deleteInstance(l),this._instances.set(l,p),this._numElements+=p.numElements}deleteInstance(l){const p=this._instances.get(l);p&&(this._numElements-=p.numElements,this._instances.delete(l))}updateInstance(l,p,D){const z=this._instances.get(l);z&&(this._numElements-=z.numElements,z.from=p,z.to=D,this._numElements+=z.numElements)}updateDrawState(l){l.isVisible?(l.hasHighlights&&(this.hasHighlights=!0),l.hasOccludees&&(this.hasOccludees=!0)):this.hasHiddenInstances=!0}updateDrawCommands(l){if(this.drawCommandsDefault.clear(),this.drawCommandsHighlight.clear(),this.drawCommandsOccludees.clear(),this.drawCommandsShadowHighlightRest.clear(),this.drawCommandsDirty=!1,0===this._instances.size)return;if(!this.needsMultipleCommands()){const D=this.drawCommandsDefault.pushNew(),z=this.holes.front();return(0,c.pC)(this.vao)&&1===this.holes.length&&z.to===Math.floor(this.vao.size/l)?(D.first=0,void(D.count=z.from)):(D.first=1/0,D.count=0,this._instances.forEach(Ce=>{D.first=Math.min(D.first,Ce.from),D.count=Math.max(D.count,Ce.to)}),void(D.count-=D.first))}const p=Array.from(this._instances.values()).sort((D,z)=>D.from===z.from?D.to-z.to:D.from-z.from);for(const D of p)D.isVisible&&(nr(D.hasOccludees?this.drawCommandsOccludees:this.drawCommandsDefault,D),nr(D.hasHighlights?this.drawCommandsHighlight:this.drawCommandsShadowHighlightRest,D))}needsMultipleCommands(){return this.hasOccludees||this.hasHighlights||this.hasHiddenInstances}}function Gt(){return new V.Z({allocator:h=>h||new Ir,deallocator:h=>h})}function nr(h,l){const p=h.back();if(null==p){const D=h.pushNew();return D.first=l.from,void(D.count=l.numElements)}if(function br(h,l){return h.first+h.count>=l.from}(p,l))p.count=l.from-p.first+l.numElements;else{const D=h.pushNew();D.first=l.from,D.count=l.numElements}}class Ur{constructor(l){this.origin=l,this.buffers=new Array}dispose(){this.buffers.forEach(l=>l.vao.dispose()),this.buffers.length=0}findBuffer(l){return this.buffers.find(p=>p.instances.has(l))}}var ar=a(1036),jr=a(86236),Wr=a(76438);const Hr=ar.an+1;class Nr{constructor(l,p,D){this._rctx=l,this._locations=p,this._layout=D,this._cache=l.newCache(`VaoCache ${(0,jr.D)()}`,Br)}dispose(){this._cache.destroy()}newVao(l){const p=l.toString(),D=this._cache.pop(p);if((0,c.pC)(D)){const Ce=D.pop();return D.length>0&&this._cache.put(p,D,l*D.length,Hr),Ce}const z=new Wr.U(this._rctx,this._locations,{geometry:this._layout},{geometry:sr.f.createVertex(this._rctx,E.l1.STATIC_DRAW)});return z.vertexBuffers.geometry.setSize(l),z}deleteVao(l){if((0,c.Wi)(l))return null;const p=l.size,D=p.toString(),z=this._cache.pop(D);return(0,c.pC)(z)?(z.push(l),this._cache.put(D,z,p*z.length,-1)):this._cache.put(D,[l],p,-1),null}}function Br(h,l){if(l===ar.lN.ALL)return void h.forEach(z=>z.dispose());const p=h.pop(),D=h.length*p.size;return p.dispose(),D}class Fr{constructor(l,p,D){this._rctx=l,this._materialRepository=p,this.material=D,this._dataByOrigin=new Map,this._appleAmdDriverHelper=null,this._hasHighlights=!1,this._hasOccludees=!1,this._glMaterials=new Ar.p(this.material,this._materialRepository),this._bufferWriter=D.createBufferWriter(),this._vaoCache=new Nr(l,D.vertexAttributeLocations,(0,Dr.K)(this._bufferWriter.vertexBufferLayout)),this._rctx.driverTest.drawArraysRequiresIndicesTypeReset.result&&(this._appleAmdDriverHelper=new Mr(this._rctx))}dispose(){this._glMaterials.destroy(),this._dataByOrigin.forEach(l=>l.dispose()),this._dataByOrigin.clear(),this._vaoCache.dispose(),this._appleAmdDriverHelper?.dispose()}get isEmpty(){return 0===this._dataByOrigin.size}get hasHighlights(){return this._hasHighlights}get hasOccludees(){return this._hasOccludees}get hasWater(){return!this.isEmpty&&this.material instanceof xr.H}get rendersOccluded(){return!this.isEmpty&&this.material.renderOccluded!==ct.yD.Occlude}get numGeometries(){let l=0;return this._dataByOrigin.forEach(p=>l+=p.buffers.reduce((D,z)=>D+z.instances.size,0)),l}forEachGeometry(l){this._dataByOrigin.forEach(p=>p.buffers.forEach(D=>D.instances.forEach(z=>l(z.geometry))))}modify(l){this._updateGeometries(l.updates),this._addAndRemoveGeometries(l.adds,l.removes),this._updateDrawCommands()}_updateGeometries(l){const p=this._bufferWriter,D=p.vertexBufferLayout.stride/4;for(const z of l){const Ce=z.renderGeometry,we=this._dataByOrigin.get(Ce.localOrigin.id)?.findBuffer(Ce.id);if((0,c.Wi)(we))return;const Be=we.instances.get(Ce.id);if(z.updateType&(Nt.$.GEOMETRY|Nt.$.TRANSFORMATION)){const ze=Xt(p.elementCount(Be.geometry.geometry)*D),$e=p.vertexBufferLayout.createView(ze.buffer);this._writeGeometry(Ce,$e,0),we.vao.vertexBuffers.geometry.setSubData(ze,Be.from*D,0,Be.numElements*D)}z.updateType&(Nt.$.HIGHLIGHT|Nt.$.OCCLUDEE|Nt.$.VISIBILITY)&&(we.drawCommandsDirty=!0)}}_computeDeltas(l,p){const D=new Ge.r;for(const z of l){const Ce=z.localOrigin;if((0,c.Wi)(Ce))continue;let we=D.get(Ce.id,null);(0,c.Wi)(we)&&(we=new lr(Ce.vec3),D.set(Ce.id,null,we)),we.changes.push(z)}for(const z of p){const Ce=z.localOrigin;if((0,c.Wi)(Ce))continue;const we=this._dataByOrigin.get(Ce.id)?.findBuffer(z.id);if((0,c.Wi)(we))continue;let Be=D.get(Ce.id,we);(0,c.Wi)(Be)&&(Be=new lr(Ce.vec3),D.set(Ce.id,we,Be)),Be.changes.push(z)}return D}_addAndRemoveGeometries(l,p){const{_bufferWriter:D,_dataByOrigin:z}=this,Ce=D.vertexBufferLayout.stride/4,we=this._computeDeltas(l,p);we.forEach((Be,ze)=>{const $e=Be.get(null),st=(0,c.pC)($e)?$e.changes:[];we.delete(ze,null);let dt=z.get(ze);if(Be.forEach((ht,Ze)=>{if(we.delete(ze,Ze),(0,c.Wi)(Ze))return void(0,it.hu)(!1,"No VAO for removed geometries");if(Ze.instances.size===ht.changes.length)return this._vaoCache.deleteVao(Ze.vao),(0,X.e$)(dt.buffers,Ze),void(0===dt.buffers.length&&0===st.length&&z.delete(ze));const pt=Ze.numElements,Lt=Ze.vao.size/4,Wt=st.reduce((bt,_t)=>bt+D.elementCount(_t.geometry),0),xt=ht.changes.reduce((bt,_t)=>bt+D.elementCount(_t.geometry),0),wt=Math.min((pt+Wt-xt)*Ce,Jt),Ht=wt>Lt;wt>Zt&&wt<Lt/2?(ht.changes.forEach(({id:bt})=>Ze.deleteInstance(bt)),Ze.instances.forEach(({geometry:bt})=>st.push(bt)),this._vaoCache.deleteVao(Ze.vao),(0,X.e$)(dt.buffers,Ze)):Ht?this._applyAndRebuild(Ze,st,ht):this._applyRemoves(Ze,ht)}),st.length>0)for((0,c.Wi)(dt)&&(dt=new Ur($e.origin),z.set(ze,dt)),dt.buffers.forEach(ht=>this._applyAdds(ht,st));st.length>0;)dt.buffers.push(this._applyAndRebuild(new Lr,st,null))})}_updateDrawCommands(){this._hasHighlights=!1,this._hasOccludees=!1,this._dataByOrigin.forEach(l=>{l.buffers.forEach(p=>{p.drawCommandsDirty&&(p.hasHiddenInstances=!1,p.hasHighlights=!1,p.hasOccludees=!1,(0,M.oE)(p.instances,D=>(p.updateDrawState(D),p.hasHiddenInstances&&p.hasHighlights&&p.hasOccludees)),p.updateDrawCommands(this._bufferWriter.vertexBufferLayout.stride)),this._hasHighlights=this._hasHighlights||p.hasHighlights,this._hasOccludees=this._hasOccludees||p.hasOccludees})})}_applyAndRebuild(l,p,D){if((0,c.pC)(D))for(const pt of D.changes)l.deleteInstance(pt.id);const z=this._bufferWriter,Ce=z.vertexBufferLayout.stride,we=Ce/4,Be=Math.floor(Jt/we);let ze=l.numElements;for(;p.length>0;){const pt=p.pop(),Lt=z.elementCount(pt.geometry);if(ze+Lt>Be&&ze>0){p.push(pt);break}ze+=Lt;const Wt=new or(pt,0,0);(0,it.hu)(null==l.instances.get(pt.id)),l.addInstance(pt.id,Wt)}const $e=ze*we,st=Xt($e),dt=z.vertexBufferLayout.createView(st.buffer);let ht=0;l.hasHiddenInstances=!1,l.hasHighlights=!1,l.hasOccludees=!1,l.instances.forEach((pt,Lt)=>{this._writeGeometry(pt.geometry,dt,ht);const Wt=ht;ht+=z.elementCount(pt.geometry.geometry),l.updateInstance(Lt,Wt,ht),l.updateDrawState(pt)}),this._vaoCache.deleteVao(l.vao),l.vao=this._vaoCache.newVao(hr($e)),l.vao.vertexBuffers.geometry.setSubData(st,0,0,ht*we),l.holes.clear();const Ze=l.holes.pushNew();return Ze.from=ht,Ze.to=Math.floor(l.vao.size/Ce),l.updateDrawCommands(Ce),l}_applyRemoves(l,p){if(0===p.changes.length)return;for(const Be of p.changes){const ze=Be.id,$e=l.instances.get(ze);if(!$e)continue;l.deleteInstance(ze);const st=Bt.back();if(st){if(st.to===$e.from){st.to=$e.to;continue}if(st.from===$e.to){st.from=$e.from;continue}}const dt=Bt.pushNew();dt.from=$e.from,dt.to=$e.to}ir(Bt);const D=this._bufferWriter.vertexBufferLayout.stride/4,z=Bt.reduce((Be,ze)=>Math.max(Be,ze.numElements),0)*D,Ce=Xt(z);Ce.fill(0,0,z);const we=l.vao.vertexBuffers.geometry;Bt.forAll(Be=>we.setSubData(Ce,Be.from*D,0,Be.numElements*D)),l.holes.pushArray(Bt.data,Bt.length),Bt.forAll((Be,ze)=>Bt.data[ze]=null),Bt.clear(),l.drawCommandsDirty=!0}_applyAdds(l,p){if(0===p.length)return;if(!function wr(h){return(0,c.pC)(h.vao)}(l))return void this._applyAndRebuild(l,p,null);const D=this._bufferWriter,z=D.vertexBufferLayout.stride/4,Ce=l.numElements,we=p.reduce((xt,wt)=>xt+D.elementCount(wt.geometry),0),Be=Math.min((Ce+we)*z,Jt),ze=4*Be;if(l.vao.size<hr(Jt-Zt)&&ze>l.vao.size)return void this._applyAndRebuild(l,p,null);ir(l.holes);const $e=new Array;for(const xt of p){const wt=D.elementCount(xt.geometry),Ht=zr(l.holes,wt);$e.push(Ht)}const st=l.vao.vertexBuffers.geometry;let dt=0,ht=0,Ze=0;const pt=Xt(Be),Lt=D.vertexBufferLayout.createView(pt.buffer);p.forEach((xt,wt)=>{const Ht=$e[wt];if((0,c.Wi)(Ht))return;if(Ze!==Ht){const Pt=Ze-ht;Pt>0&&st.setSubData(pt,ht*z,0,Pt*z),ht=Ht,dt=0}const bt=D.elementCount(xt.geometry);this._writeGeometry(xt,Lt,dt),dt+=bt,Ze=Ht+bt;const _t=new or(xt,Ht,Ht+bt);(0,it.hu)(null==l.instances.get(xt.id)),l.addInstance(xt.id,_t),l.drawCommandsDirty=!0});const Wt=Ze-ht;Wt>0&&st.setSubData(pt,ht*z,0,Wt*z),(0,X.hv)(p,(xt,wt)=>(0,c.Wi)($e[wt]))}_writeGeometry(l,p,D){const z=l.localOrigin.vec3;(0,it.u_)(cr,-z[0],-z[1],-z[2]);const Ce=(0,U.m)(Vr,cr,l.transformation);(0,U.a)(Kt,Ce),(0,U.t)(Kt,Kt),this._bufferWriter.write(Ce,Kt,l.geometry,p,D)}updateAnimation(l){return this.material.update(l)}requiresSlot(l,p){return this.material.requiresSlot(l,p)}render(l,p){if(!this.requiresSlot(p.slot,l))return!1;const D=l===Le.H.Highlight||l===Le.H.ShadowHighlight;if(D&&!this._hasHighlights)return!1;const z=l===Le.H.ShadowExcludeHighlight,Ce=!(D||z),we=this._rctx;let Be;const ze=()=>{if((0,c.pC)(Be))return Be;const $e=this._glMaterials.load(we,p.slot,l);return(0,c.Wi)($e)?null:(Be=$e.beginSlot(p),(0,c.Wi)(Be)?null:(we.bindTechnique(Be,this.material.parameters,p),Be))};this._appleAmdDriverHelper?.resetIndicesType();for(const $e of this._dataByOrigin.values())for(const st of $e.buffers){if(D&&!st.hasHighlights)continue;const dt=(D?st.drawCommandsHighlight:z&&st.needsMultipleCommands()?st.drawCommandsShadowHighlightRest:st.drawCommandsDefault)||null,ht=Ce&&st.drawCommandsOccludees||null;if(dt?.length||ht?.length){const Ze=ze();if((0,c.Wi)(Ze))return!1;Ze.program.bindDraw(new Rr($e.origin),p,this.material.parameters),Ze.ensureAttributeLocations(st.vao),we.bindVAO(st.vao),dt?.length&&(Ze.bindPipelineState(we,p.slot,!1),dt.forAll(pt=>we.drawArrays(Ze.primitiveType,pt.first,pt.count))),ht?.length&&(Ze.bindPipelineState(we,p.slot,!0),ht.forAll(pt=>we.drawArrays(Ze.primitiveType,pt.first,pt.count)))}}return(0,c.pC)(Be)}get test(){return{material:this.material,glMaterials:this._glMaterials,dataByOrigin:this._dataByOrigin}}}class lr{constructor(l){this.origin=l,this.changes=new Array}}function zr(h,l){let p;if(!h.some(z=>!(z.numElements<l||(p=z,0))))return null;const D=p.from;return p.from+=l,p.from>=p.to&&h.removeUnordered(p),D}const cr=(0,me.c)(),Vr=(0,me.c)(),Kt=(0,me.c)(),Bt=new V.Z({allocator:h=>h||new qt,deallocator:null}),Zt=65536,$t=4*Zt,Jt=4194304;let er=new Float32Array(Zt);function Xt(h){return er.length<h&&(er=new Float32Array(h)),er}function hr(h){const l=4*h;return l<$t?$t:Math.max(Math.min(Math.ceil(1.5*l/$t)*$t,16777216),l)}let jt=class extends g.Z{constructor(h){super(h),this._pending=new Gr,this._changes=new Or,this._materialRenderers=new Map,this._sortedMaterialRenderers=new V.Z,this._geometries=new Map,this._hasHighlights=!1,this._hasWater=!1}destroy(){this._changes.prune(),this._materialRenderers.forEach(h=>h.dispose()),this._materialRenderers.clear(),this._sortedMaterialRenderers.clear(),this._geometries.clear()}get updating(){return!this._pending.empty||this._changes.updates.length>0}get rctx(){return this.rendererContext.rctx}get _materialRepository(){return this.rendererContext.materialRepository}get _localOriginFactory(){return this.rendererContext.localOriginFactory}get hasHighlights(){return this._hasHighlights}get hasWater(){return this._hasWater}get rendersOccluded(){return(0,M.oE)(this._materialRenderers,h=>h.rendersOccluded)}get isEmpty(){return!this.updating&&0===this._materialRenderers.size&&0===this._geometries.size}commitChanges(){if(!this.updating)return!1;this._processAddsRemoves();const h=function Pr(h){const l=new Map,p=D=>{let z=l.get(D);return z||(z=new Tr,l.set(D,z)),z};return h.removes.forAll(D=>{kt(D)&&p(D.material).removes.push(D)}),h.adds.forAll(D=>{kt(D)&&p(D.material).adds.push(D)}),h.updates.forAll(D=>{kt(D.renderGeometry)&&p(D.renderGeometry.material).updates.push(D)}),l}(this._changes);let l=!1,p=!1,D=!1;return h.forEach((z,Ce)=>{let we=this._materialRenderers.get(Ce);if(!we&&z.adds.length>0&&(we=new Fr(this.rctx,this._materialRepository,Ce),this._materialRenderers.set(Ce,we),l=!0,p=!0,D=!0),!we)return;const Be=p||we.hasHighlights,ze=D||we.hasWater;we.modify(z),p=p||Be!==we.hasHighlights,D=D||ze!==we.hasWater,we.isEmpty&&(this._materialRenderers.delete(Ce),we.dispose(),l=!0)}),this._changes.clear(),l&&this._updateSortedMaterialRenderers(),p&&(this._hasHighlights=(0,M.oE)(this._materialRenderers,z=>z.hasHighlights)),D&&(this._hasWater=(0,M.oE)(this._materialRenderers,z=>z.hasWater)),this.notifyChange("updating"),!0}addGeometries(h,l){if(0===h.length)return;const p=this._validateRenderGeometries(h);for(const z of p)this._geometries.set(z.id,z);const D=this._pending.empty;for(const z of p)this._pending.adds.add(z);D&&this.notifyChange("updating"),l===Nt.T.UPDATE&&this._notifyGraphicGeometryChanged(h)}removeGeometries(h,l){const p=this._pending.empty,D=this._pending.adds;for(const z of h)D.has(z)?(this._pending.removed.add(z),D.delete(z)):this._pending.removed.has(z)||this._pending.removes.add(z),this._geometries.delete((0,c.Wg)(z.id));p&&!this._pending.empty&&this.notifyChange("updating"),l===Nt.T.UPDATE&&this._notifyGraphicGeometryChanged(h)}modifyGeometries(h,l){const p=0===this._changes.updates.length;for(const D of h){const z=this._changes.updates.pushNew();z.renderGeometry=this._validateRenderGeometry(D),z.updateType=l}switch(p&&this._changes.updates.length>0&&this.notifyChange("updating"),l){case Nt.$.TRANSFORMATION:case Nt.$.GEOMETRY:return this._notifyGraphicGeometryChanged(h);case Nt.$.VISIBILITY:return this._notifyGraphicVisibilityChanged(h)}}updateAnimation(h){let l=!1;return this._sortedMaterialRenderers.forAll(p=>l=p.updateAnimation(h)||l),l}render(h){this._sortedMaterialRenderers.forAll(l=>{l.material.shouldRender(h)&&l.render(h.output,h.bindParameters)})}intersect(h,l,p,D,z){return this._geometries.forEach(Ce=>{if(D&&!D(Ce))return;this._intersectRenderGeometry(Ce,p,l,0,h,z);const we=this.rendererContext.longitudeCyclical;we&&(Ce.boundingSphere[0]-Ce.boundingSphere[3]<we.min&&this._intersectRenderGeometry(Ce,p,l,we.range,h,z),Ce.boundingSphere[0]+Ce.boundingSphere[3]>we.max&&this._intersectRenderGeometry(Ce,p,l,-we.range,h,z)),z++}),z}_updateSortedMaterialRenderers(){this._sortedMaterialRenderers.clear();let h=0;this._materialRenderers.forEach((l,p)=>{p.insertOrder=h++,this._sortedMaterialRenderers.push(l)}),this._sortedMaterialRenderers.sort((l,p)=>{const D=p.material.renderPriority-l.material.renderPriority;return 0!==D?D:l.material.insertOrder-p.material.insertOrder})}_processAddsRemoves(){this._changes.adds.clear(),this._changes.removes.clear(),this._changes.adds.pushArray(Array.from(this._pending.adds)),this._changes.removes.pushArray(Array.from(this._pending.removes));for(let h=0;h<this._changes.updates.length;)this._pending.has(this._changes.updates.data[h].renderGeometry)?this._changes.updates.removeUnorderedIndex(h):h++;this._pending.clear()}_intersectRenderGeometry(h,l,p,D,z,Ce){if(!h.visible)return;let we=0;we=h.transformation[13],tr[0]=p[0]-(D+=h.transformation[12]),tr[1]=p[1]-we,h.screenToWorldRatio=this.rendererContext.screenToWorldRatio,h.material.intersectDraped(h,null,z,tr,(Be,ze,$e)=>{!function Kr(h,l,p,D,z,Ce,we){const Be=new yr(Ce,we,l),ze=$e=>{$e.set(Qt.q7.OVERLAY,Be,h.dist,h.normal,h.transformation,p,D)};if((null==z.results.min.drapedLayerOrder||p>=z.results.min.drapedLayerOrder)&&(null==z.results.min.dist||z.results.ground.dist<=z.results.min.dist)&&ze(z.results.min),z.options.store!==Qt.eC.MIN&&(null==z.results.max.drapedLayerOrder||p<z.results.max.drapedLayerOrder)&&(null==z.results.max.dist||z.results.ground.dist>z.results.max.dist)&&ze(z.results.max),z.options.store===Qt.eC.ALL){const $e=(0,Cr.LP)(z.ray);ze($e),z.results.all.push($e)}}(l,$e,h.material.renderPriority,Ce,z,h.layerUid,h.graphicUid)},l)}_notifyGraphicGeometryChanged(h){if((0,c.Wi)(this.drapeSource.notifyGraphicGeometryChanged))return;let l;for(const p of h){const D=p.graphicUid;(0,c.pC)(D)&&D!==l&&(this.drapeSource.notifyGraphicGeometryChanged(D),l=D)}}_notifyGraphicVisibilityChanged(h){if((0,c.Wi)(this.drapeSource.notifyGraphicVisibilityChanged))return;let l;for(const p of h){const D=p.graphicUid;(0,c.pC)(D)&&D!==l&&(this.drapeSource.notifyGraphicVisibilityChanged(D),l=D)}}_validateRenderGeometries(h){for(const l of h)this._validateRenderGeometry(l);return h}_validateRenderGeometry(h){return(0,c.Wi)(h.localOrigin)&&(h.localOrigin=this._localOriginFactory.getOrigin(h.boundingSphere)),h}get test(){return{sortedMaterialRenderers:this._sortedMaterialRenderers}}};(0,_._)([(0,x.Cb)()],jt.prototype,"drapeSource",void 0),(0,_._)([(0,x.Cb)()],jt.prototype,"updating",null),(0,_._)([(0,x.Cb)()],jt.prototype,"rctx",null),(0,_._)([(0,x.Cb)()],jt.prototype,"rendererContext",void 0),(0,_._)([(0,x.Cb)()],jt.prototype,"_materialRepository",null),(0,_._)([(0,x.Cb)()],jt.prototype,"_localOriginFactory",null),(0,_._)([(0,x.Cb)({readOnly:!0})],jt.prototype,"isEmpty",null),(0,_._)([(0,x.Cb)()],jt.prototype,"_materialRenderers",void 0),(0,_._)([(0,x.Cb)()],jt.prototype,"_geometries",void 0),jt=(0,_._)([(0,O.j)("esri.views.3d.webgl-engine.lib.SortedRenderGeometryRenderer")],jt);class Gr{constructor(){this.adds=new Set,this.removes=new Set,this.removed=new Set}get empty(){return 0===this.adds.size&&0===this.removes.size&&0===this.removed.size}has(l){return this.adds.has(l)||this.removes.has(l)||this.removed.has(l)}clear(){this.adds.clear(),this.removes.clear(),this.removed.clear()}}const tr=(0,Qe.a)();var Zr=a(35671),$r=a(651),Jr=a(91056),Xr=a(39114),Yr=a(12407),Vt=a(2078);class Yt extends Jr.A{initializeProgram(l){return new Yr.$(l.rctx,Yt.shader.get().build(),Xr.i)}initializePipeline(){return(0,Vt.sm)(this.configuration.hasAlpha?{blending:(0,Vt.wK)(E.zi.SRC_ALPHA,E.zi.ONE,E.zi.ONE_MINUS_SRC_ALPHA,E.zi.ONE_MINUS_SRC_ALPHA),colorWrite:Vt.BK}:{colorWrite:Vt.BK})}}Yt.shader=new $r.J(Xe.a,()=>a.e(6859).then(a.bind(a,98101)));class ur extends tt.m{constructor(){super(...arguments),this.hasAlpha=!1}}(0,_._)([(0,tt.o)()],ur.prototype,"hasAlpha",void 0);var Qr=a(23147),kr=a(82244),qr=a(51899),pr=a(84259);let Ft=class extends g.Z{get _bindParameters(){return this._renderContext.bindParameters}get rctx(){return this._rctx}get materialRepository(){return this._materialRepository}get screenToWorldRatio(){return this._screenToWorldRatio}get localOriginFactory(){return this._localOriginFactory}constructor(h){super(h),this._overlays=null,this._overlayRenderTarget=null,this._hasHighlights=!1,this._rendersOccluded=!1,this._hasWater=!1,this._handles=new q.Z,this._renderers=new Map,this._sortedDrapeSourceRenderersDirty=!1,this._sortedRenderers=new V.Z,this._passParameters=new Xe.T,this._rctx=null,this._materialRepository=null,this._screenToWorldRatio=1,this._localOriginFactory=null,this._camera=new vt.V,this.worldToPCSRatio=1,this.events=new b.Z,this.longitudeCyclical=null}initialize(){const h=this.view._stage.renderView;this._rctx=h.renderingContext;const l=h.waterTextureRepository;this._stippleTextureRepository=new qr.h0(h.renderingContext),this._shaderTechniqueRepository=new Ye({rctx:this._rctx,viewingMode:F.JY.Local,stippleTextureRepository:this._stippleTextureRepository,waterTextureRepository:l}),this._renderContext=new ae(this._rctx,new Se(this._rctx,this.view.state.viewingMode),new Zr.L(this.view,this._shaderTechniqueRepository,this._rctx,()=>{})),this._handles.add([(0,H.YP)(()=>l.updating,()=>this.events.emit("content-changed"),H.tX),(0,H.YP)(()=>this.spatialReference,p=>this._localOriginFactory=new Et.C(p),H.tX),(0,H.on)(()=>this.view.allLayerViews,"after-changes",()=>this._sortedDrapeSourceRenderersDirty=!0)]),this._materialRepository=new yt(h.textureRepository,this._shaderTechniqueRepository,p=>{(p.renderOccluded&fr)>0!==this._rendersOccluded&&this._updateRendersOccluded(),this.events.emit("content-changed"),this.notifyChange("updating"),this.notifyChange("isEmpty")},()=>this.events.emit("content-changed")),this._bindParameters.slot=ve.r.DRAPED_MATERIAL,this._bindParameters.highlightDepthTexture=(0,Ot.hf)(this._rctx),this._camera.near=1,this._camera.far=1e4,this._camera.relativeElevation=null,this._bindParameters.camera=this._camera,this._bindParameters.transparencyPassType=Z.A.NONE,this._bindParameters.newLighting.noonFactor=0,this._bindParameters.newLighting.globalFactor=0,this._bindParameters.newLighting.set([new kr.Mi((0,ye.f)(1,1,1))]),this._handles.add(this.view.resourceController.scheduler.registerTask(pr.T8.STAGE,this))}destroy(){this._handles.destroy(),this._renderers.forEach(h=>h.destroy()),this._renderers.clear(),this._debugTextureTechnique=(0,c.RY)(this._debugTextureTechnique),this._passParameters.texture=(0,c.M2)(this._passParameters.texture),this._bindParameters.highlightDepthTexture=(0,c.M2)(this._bindParameters.highlightDepthTexture),this._shaderTechniqueRepository=(0,c.SC)(this._shaderTechniqueRepository),this._temporaryFBO=(0,c.M2)(this._temporaryFBO),this._quadVAO=(0,c.M2)(this._quadVAO),this.disposeOverlays()}get updating(){return this._sortedDrapeSourceRenderersDirty||(0,M.oE)(this._renderers,h=>h.updating)}get hasOverlays(){return(0,c.pC)(this._overlays)&&(0,c.pC)(this._overlayRenderTarget)}get gpuMemoryUsage(){return(0,c.pC)(this._overlayRenderTarget)?this._overlayRenderTarget.gpuMemoryUsage:0}createGeometryDrapeSourceRenderer(h){return this.createDrapeSourceRenderer(h,jt)}createDrapeSourceRenderer(h,l,p){const D=this._renderers.get(h);(0,c.pC)(D)&&D.destroy();const z=new l({...p,rendererContext:this,drapeSource:h});return this._renderers.set(h,z),this._sortedDrapeSourceRenderersDirty=!0,"fullOpacity"in h&&this._handles.add((0,H.YP)(()=>h.fullOpacity,()=>this.events.emit("content-changed")),h),z}removeDrapeSourceRenderer(h){if((0,c.Wi)(h))return;const l=this._renderers.get(h);(0,c.Wi)(l)||(this._sortedDrapeSourceRenderersDirty=!0,this._renderers.delete(h),this._handles.remove(h),l.destroy())}collectUnusedRenderTargetMemory(h){let l=!1;if((0,c.pC)(this._overlayRenderTarget))for(const p of this._overlayRenderTarget.renderTargets){const[D,z]=this.overlays;l=this._overlayRenderTarget.validateUsageForTarget(D.validTargets[p.type]||!z.validTargets[p.type],p,h)||l}return l}get overlays(){return(0,c.Pt)(this._overlays,[])}ensureDrapeTargets(h){(0,c.pC)(this._overlays)&&this._overlays.forEach(l=>l.hasTargetWithoutRasterImage=(0,W.f)(h,p=>p.drapeTargetType===se.al.WithoutRasterImage))}ensureDrapeSources(h){(0,c.pC)(this._overlays)&&this._overlays.forEach(l=>{l.hasDrapedFeatureSource=(0,W.f)(h,p=>p.drapeSourceType===se.Lw.Features),l.hasDrapedRasterSource=(0,W.f)(h,p=>p.drapeSourceType===se.Lw.RasterImage)})}ensureOverlays(h,l){(0,c.Wi)(this._overlays)&&(this._overlayRenderTarget=new He(this._rctx),this._overlays=[new J(k.INNER,this._overlayRenderTarget),new J(k.OUTER,this._overlayRenderTarget)]),this.ensureDrapeTargets(h),this.ensureDrapeSources(l)}disposeOverlays(){this._overlays=null,this._overlayRenderTarget=(0,c.M2)(this._overlayRenderTarget),this.events.emit("textures-disposed")}get running(){return this.updating}runTask(h){this._processDrapeSources(h,()=>!0)}_processDrapeSources(h,l){let p=!1;for(const[D,z]of this._renderers){if(h.done)break;(D.destroyed||l(D))&&z.commitChanges()&&(p=!0,h.madeProgress())}this._sortedDrapeSourceRenderersDirty&&(this._sortedDrapeSourceRenderersDirty=!1,p=!0,this._updateSortedDrapeSourceRenderers()),p&&((0,c.pC)(this._overlays)&&0===this._renderers.size&&this.disposeOverlays(),this.notifyChange("updating"),this.notifyChange("isEmpty"),this.events.emit("content-changed"),this._updateHasHighlights(),this._updateRendersOccluded(),this._updateHasWater())}processSyncDrapeSources(){this._processDrapeSources(pr.G5,h=>h.updatePolicy===Qr.j.SYNC)}get isEmpty(){return!te.Z.OVERLAY_DRAW_DEBUG_TEXTURE&&!(0,M.oE)(this._renderers,h=>!h.isEmpty)}get hasHighlights(){return this._hasHighlights}get hasWater(){return this._hasWater}get rendersOccluded(){return this._rendersOccluded}updateAnimation(h){let l=!1;return this._renderers.forEach(p=>l=p.updateAnimation(h)||l),l}updateDrapeSourceOrder(){this._sortedDrapeSourceRenderersDirty=!0}drawTarget(h,l,p){const D=h.canvasGeometries;if(0===D.numViews)return!1;this._screenToWorldRatio=p*h.mapUnitsPerPixel;const z=l.output;if(this.isEmpty||z===Le.H.Highlight&&!this.hasHighlights||z===Le.H.Normal&&!this.hasWater||!h.hasSomeSizedView())return!1;const Ce=l.fbo;if(!Ce.isValid())return!1;const we=2*h.resolution,Be=h.resolution;Ce.resize(we,Be);const ze=this._rctx;if(this._camera.pixelRatio=h.pixelRatio*p,this._renderContext.output=z,this._bindParameters.screenToWorldRatio=this._screenToWorldRatio,this._bindParameters.screenToPCSRatio=this._screenToWorldRatio*this.worldToPCSRatio,this._bindParameters.slot=z===Le.H.Normal?ve.r.DRAPED_WATER:ve.r.DRAPED_MATERIAL,h.applyViewport(this._rctx),Ce.bind(ze),h.index===k.INNER&&(ze.setClearColor(0,0,0,0),ze.clearSafe(E.lk.COLOR_BUFFER_BIT)),l.type===L.Occluded&&(this._renderContext.renderOccludedMask=fr),te.Z.OVERLAY_DRAW_DEBUG_TEXTURE&&l.type!==L.Occluded)for(let $e=0;$e<D.numViews;$e++)this._setViewParameters(D.extents[$e],h),this._drawDebugTexture(h.resolution,ts[h.index]);return this._renderers.size>0&&this._sortedRenderers.forAll(({drapeSource:$e,renderer:st})=>{if(l.type===L.ColorNoRasterImage&&$e.drapeSourceType===se.Lw.RasterImage)return;const{fullOpacity:dt}=$e,ht=(0,c.pC)(dt)&&dt<1&&z===Le.H.Color;ht&&(this.bindTemporaryFramebuffer(this._rctx,we,Be),ze.clearSafe(E.lk.COLOR_BUFFER_BIT));for(let Ze=0;Ze<D.numViews;Ze++)this._setViewParameters(D.extents[Ze],h),st.render(this._renderContext);ht&&(0,c.pC)(this._temporaryFBO)&&(Ce.bind(ze),this.view._stage.renderView.compositingHelper.compositeOverlay(this._renderContext.bindParameters,this._temporaryFBO.getTexture(),dt,h.index))}),ze.bindFramebuffer(null),Ce.generateMipMap(),this._renderContext.resetRenderOccludedMask(),!0}bindTemporaryFramebuffer(h,l,p){(0,c.Wi)(this._temporaryFBO)&&(this._temporaryFBO=new ue(h,!1)),this._temporaryFBO.resize(l,p),this._temporaryFBO.bind(h)}reloadShaders(){var h=this;return(0,m.Z)(function*(){yield h._shaderTechniqueRepository.reloadAll()})()}notifyContentChanged(){this.events.emit("content-changed")}intersect(h,l,p,D){let z=0;for(const Ce of this._renderers.values())z=Ce.intersect?.(h,l,p,D,z)??z}_updateSortedDrapeSourceRenderers(){if(this._sortedRenderers.clear(),0===this._renderers.size)return;const h=this.view.map.allLayers;this._renderers.forEach((l,p)=>{const D=h.indexOf(p.layer),z=D>=0;this._sortedRenderers.push(new es(p,l,this._renderers.size*(p.renderGroup??(z?se.eZ.MapLayer:se.eZ.ViewLayer))+(z?D:0)))}),this._sortedRenderers.sort((l,p)=>l.index-p.index)}_setViewParameters(h,l){const p=this._camera;p.viewport=[0,0,l.resolution,l.resolution],(0,U.x)(p.projectionMatrix,0,h[2]-h[0],0,h[3]-h[1],p.near,p.far),(0,U.f)(p.viewMatrix,[-h[0],-h[1],0])}_updateHasWater(){const h=(0,M.oE)(this._renderers,l=>l.hasWater);h!==this._hasWater&&(this._hasWater=h,this.events.emit("has-water",h))}_updateHasHighlights(){const h=(0,M.oE)(this._renderers,l=>l.hasHighlights);h!==this._hasHighlights&&(this._hasHighlights=h,this.events.emit("has-highlights",h))}_updateRendersOccluded(){const h=(0,M.oE)(this._renderers,l=>l.rendersOccluded);h!==this._rendersOccluded&&(this._rendersOccluded=h,this.events.emit("renders-occluded",h))}_drawDebugTexture(h,l){this._ensureDebugPatternResources(h,h,l);const p=this._rctx;p.bindTechnique(this._debugTextureTechnique,this._passParameters,null),p.bindVAO(this._quadVAO),p.drawArrays(E.MX.TRIANGLE_STRIP,0,(0,fe._V)(this._quadVAO,"geometry"))}_ensureDebugPatternResources(h,l,p){if((0,ce.s)(this._passParameters.color,p[0],p[1],p[2]),this._passParameters.texture)return;const D=new Uint8Array(h*l*4);let z=0;for(let we=0;we<l;we++)for(let Be=0;Be<h;Be++){const ze=Math.floor(Be/10),$e=Math.floor(we/10);ze<2||$e<2||10*ze>h-20||10*$e>l-20?(D[z++]=255,D[z++]=255,D[z++]=255,D[z++]=255):(D[z++]=255,D[z++]=255,D[z++]=255,D[z++]=1&ze&&1&$e?1&Be^1&we?0:255:1&ze^1&$e?0:128)}this._passParameters.texture=new ee.x(this._rctx,{target:E.No.TEXTURE_2D,pixelFormat:E.VI.RGBA,dataType:E.Br.UNSIGNED_BYTE,samplingMode:E.cw.NEAREST,width:h,height:l},D);const Ce=new ur;Ce.hasAlpha=!0,this._debugTextureTechnique=this._shaderTechniqueRepository.acquire(Yt,Ce),this._quadVAO=(0,Ot.ow)(this._rctx)}get test(){return{drapedRenderers:Array.from(this._renderers.values()),getDrapeSourceRenderer:h=>this._renderers.get(h)}}};(0,_._)([(0,x.Cb)()],Ft.prototype,"_sortedDrapeSourceRenderersDirty",void 0),(0,_._)([(0,x.Cb)({autoDestroy:!0})],Ft.prototype,"_shaderTechniqueRepository",void 0),(0,_._)([(0,x.Cb)({autoDestroy:!0})],Ft.prototype,"_stippleTextureRepository",void 0),(0,_._)([(0,x.Cb)({constructOnly:!0})],Ft.prototype,"view",void 0),(0,_._)([(0,x.Cb)()],Ft.prototype,"worldToPCSRatio",void 0),(0,_._)([(0,x.Cb)()],Ft.prototype,"spatialReference",void 0),(0,_._)([(0,x.Cb)({type:Boolean,readOnly:!0})],Ft.prototype,"updating",null),(0,_._)([(0,x.Cb)()],Ft.prototype,"isEmpty",null),Ft=(0,_._)([(0,O.j)("esri.views.3d.terrain.OverlayRenderer")],Ft);class es{constructor(l,p,D){this.drapeSource=l,this.renderer=p,this.index=D}}const ts=[[1,.5,.5],[.5,.5,1]],rs=-2,fr=ct.yD.OccludeAndTransparent},39645:(Ve,Ee,a)=>{a.d(Ee,{U:()=>H});var m=a(97139),_=a(48565),g=a(65787),b=a(7090),q=a(17625),M=a(16396),c=a(41857);function H(W,x){const $=W.vertex;$.uniforms.add(new g.p("intrinsicWidth",X=>X.width)),x.vvSize?(W.attributes.add(M.T.SIZEFEATUREATTRIBUTE,"float"),$.uniforms.add(new m.J("vvSizeMinSize",X=>X.vvSizeMinSize)),$.uniforms.add(new m.J("vvSizeMaxSize",X=>X.vvSizeMaxSize)),$.uniforms.add(new m.J("vvSizeOffset",X=>X.vvSizeOffset)),$.uniforms.add(new m.J("vvSizeFactor",X=>X.vvSizeFactor)),$.code.add(q.H`float getSize() {
return intrinsicWidth * clamp(vvSizeOffset + sizeFeatureAttribute * vvSizeFactor, vvSizeMinSize, vvSizeMaxSize).x;
}`)):(W.attributes.add(M.T.SIZE,"float"),$.code.add(q.H`float getSize(){
return intrinsicWidth * size;
}`)),x.vvOpacity?(W.attributes.add(M.T.OPACITYFEATUREATTRIBUTE,"float"),$.constants.add("vvOpacityNumber","int",8),$.uniforms.add([new b.O("vvOpacityValues",X=>X.vvOpacityValues,8),new b.O("vvOpacityOpacities",X=>X.vvOpacityOpacities,8)]),$.code.add(q.H`float interpolateOpacity( float value ){
if (value <= vvOpacityValues[0]) {
return vvOpacityOpacities[0];
}
for (int i = 1; i < vvOpacityNumber; ++i) {
if (vvOpacityValues[i] >= value) {
float f = (value - vvOpacityValues[i-1]) / (vvOpacityValues[i] - vvOpacityValues[i-1]);
return mix(vvOpacityOpacities[i-1], vvOpacityOpacities[i], f);
}
}
return vvOpacityOpacities[vvOpacityNumber - 1];
}
vec4 applyOpacity( vec4 color ){
return vec4(color.xyz, interpolateOpacity(opacityFeatureAttribute));
}`)):$.code.add(q.H`vec4 applyOpacity( vec4 color ){
return color;
}`),x.vvColor?(W.attributes.add(M.T.COLORFEATUREATTRIBUTE,"float"),$.constants.add("vvColorNumber","int",c.x),$.uniforms.add(new b.O("vvColorValues",X=>X.vvColorValues,c.x)),$.uniforms.add(new _.b("vvColorColors",X=>X.vvColorColors,c.x)),$.code.add(q.H`vec4 interpolateColor( float value ) {
if (value <= vvColorValues[0]) {
return vvColorColors[0];
}
for (int i = 1; i < vvColorNumber; ++i) {
if (vvColorValues[i] >= value) {
float f = (value - vvColorValues[i-1]) / (vvColorValues[i] - vvColorValues[i-1]);
return mix(vvColorColors[i-1], vvColorColors[i], f);
}
}
return vvColorColors[vvColorNumber - 1];
}
vec4 getColor(){
return applyOpacity(interpolateColor(colorFeatureAttribute));
}`)):(W.attributes.add(M.T.COLOR,"vec4"),$.code.add(q.H`vec4 getColor(){
return applyOpacity(color);
}`))}},35283:(Ve,Ee,a)=>{a.d(Ee,{H:()=>_});var m=a(17625);function _(g){const b=m.H`vec4 alignToPixelCenter(vec4 clipCoord, vec2 widthHeight) {
vec2 xy = vec2(0.500123) + 0.5 * clipCoord.xy / clipCoord.w;
vec2 pixelSz = vec2(1.0) / widthHeight;
vec2 ij = (floor(xy * widthHeight) + vec2(0.5)) * pixelSz;
vec2 result = (ij * 2.0 - vec2(1.0)) * clipCoord.w;
return vec4(result, clipCoord.zw);
}`,q=m.H`vec4 alignToPixelOrigin(vec4 clipCoord, vec2 widthHeight) {
vec2 xy = vec2(0.5) + 0.5 * clipCoord.xy / clipCoord.w;
vec2 pixelSz = vec2(1.0) / widthHeight;
vec2 ij = floor((xy + 0.5 * pixelSz) * widthHeight) * pixelSz;
vec2 result = (ij * 2.0 - vec2(1.0)) * clipCoord.w;
return vec4(result, clipCoord.zw);
}`;g.vertex.code.add(b),g.vertex.code.add(q),g.fragment.code.add(b),g.fragment.code.add(q)}},3090:(Ve,Ee,a)=>{a.d(Ee,{R:()=>x,d:()=>W});var _,$,m=a(66085);($=_||(_={}))[$.Occluded=0]="Occluded",$[$.NotOccluded=1]="NotOccluded",$[$.Both=2]="Both",$[$.COUNT=3]="COUNT";var W,g=a(71850),b=a(99198),q=a(69960),M=a(65787),c=a(17625),V=a(35387),H=a(16396);function x($,X){$.include(g.cK),$.attributes.add(H.T.POSITION,"vec3"),$.attributes.add(H.T.NORMAL,"vec3"),$.attributes.add(H.T.AUXPOS1,"vec4");const O=$.vertex;(0,b.Sv)(O,X),(0,b.hY)(O,X),O.uniforms.add([new q.N("viewport",(U,ce)=>ce.camera.fullViewport),new M.p("polygonOffset",U=>U.shaderPolygonOffset),new M.p("cameraGroundRelative",(U,ce)=>ce.camera.aboveGround?1:-1),new M.p("renderTransparentlyOccludedHUD",(U,ce)=>ce.renderTransparentlyOccludedHUD===_.Occluded?1:ce.renderTransparentlyOccludedHUD===_.NotOccluded?0:.75),new V.A("hudVisibilityTexture",(U,ce)=>ce.hudVisibilityTexture)]),X.hasVerticalOffset&&(0,m.V)(O),O.constants.add("smallOffsetAngle","float",.984807753012208),O.code.add(c.H`struct ProjectHUDAux {
vec3 posModel;
vec3 posView;
vec3 vnormal;
float distanceToCamera;
float absCosAngle;
};`),O.code.add(c.H`float applyHUDViewDependentPolygonOffset(float pointGroundDistance, float absCosAngle, inout vec3 posView) {
float pointGroundSign = sign(pointGroundDistance);
if (pointGroundSign == 0.0) {
pointGroundSign = cameraGroundRelative;
}
float groundRelative = cameraGroundRelative * pointGroundSign;
if (polygonOffset > .0) {
float cosAlpha = clamp(absCosAngle, 0.01, 1.0);
float tanAlpha = sqrt(1.0 - cosAlpha * cosAlpha) / cosAlpha;
float factor = (1.0 - tanAlpha / viewport[2]);
if (groundRelative > 0.0) {
posView *= factor;
}
else {
posView /= factor;
}
}
return groundRelative;
}`),X.isDraped&&!X.hasVerticalOffset||(0,b._8)(O),X.isDraped||(O.uniforms.add(new M.p("perDistancePixelRatio",(U,ce)=>Math.tan(ce.camera.fovY/2)/(ce.camera.fullViewport[2]/2))),O.code.add(c.H`void applyHUDVerticalGroundOffset(vec3 normalModel, inout vec3 posModel, inout vec3 posView) {
float distanceToCamera = length(posView);
float pixelOffset = distanceToCamera * perDistancePixelRatio * 0.5;
vec3 modelOffset = normalModel * cameraGroundRelative * pixelOffset;
vec3 viewOffset = (viewNormal * vec4(modelOffset, 1.0)).xyz;
posModel += modelOffset;
posView += viewOffset;
}`)),X.screenCenterOffsetUnitsEnabled===W.Screen&&O.uniforms.add(new M.p("pixelRatio",(U,ce)=>ce.camera.pixelRatio)),X.hasScreenSizePerspective&&(0,g.m8)(O),O.code.add(c.H`
    vec4 projectPositionHUD(out ProjectHUDAux aux) {
      // centerOffset is in view space and is used to implement world size offsetting
      // of labels with respect to objects. It also pulls the label towards the viewer
      // so that the label is visible in front of the object.
      vec3 centerOffset = auxpos1.xyz;

      // The pointGroundDistance is the distance of the geometry to the ground and is
      // negative if the point is below the ground, or positive if the point is above
      // ground.
      float pointGroundDistance = auxpos1.w;

      aux.posModel = position;
      aux.posView = (view * vec4(aux.posModel, 1.0)).xyz;
      aux.vnormal = normal;
      ${X.isDraped?"":"applyHUDVerticalGroundOffset(aux.vnormal, aux.posModel, aux.posView);"}

      // Screen sized offset in world space, used for example for line callouts
      // Note: keep this implementation in sync with the CPU implementation, see
      //   - MaterialUtil.verticalOffsetAtDistance
      //   - HUDMaterial.applyVerticalOffsetTransformation

      aux.distanceToCamera = length(aux.posView);

      vec3 viewDirObjSpace = normalize(cameraPosition - aux.posModel);
      float cosAngle = dot(aux.vnormal, viewDirObjSpace);

      aux.absCosAngle = abs(cosAngle);

      ${X.hasScreenSizePerspective&&(X.hasVerticalOffset||X.screenCenterOffsetUnitsEnabled===W.Screen)?"vec4 perspectiveFactor = screenSizePerspectiveScaleFactor(aux.absCosAngle, aux.distanceToCamera, screenSizePerspectiveAlignment);":""}

      ${X.hasVerticalOffset?X.hasScreenSizePerspective?"float verticalOffsetScreenHeight = applyScreenSizePerspectiveScaleFactorFloat(verticalOffset.x, perspectiveFactor);":"float verticalOffsetScreenHeight = verticalOffset.x;":""}

      ${X.hasVerticalOffset?c.H`
            float worldOffset = clamp(verticalOffsetScreenHeight * verticalOffset.y * aux.distanceToCamera, verticalOffset.z, verticalOffset.w);
            vec3 modelOffset = aux.vnormal * worldOffset;
            aux.posModel += modelOffset;
            vec3 viewOffset = (viewNormal * vec4(modelOffset, 1.0)).xyz;
            aux.posView += viewOffset;
            // Since we elevate the object, we need to take that into account
            // in the distance to ground
            pointGroundDistance += worldOffset;`:""}

      float groundRelative = applyHUDViewDependentPolygonOffset(pointGroundDistance, aux.absCosAngle, aux.posView);

      ${X.screenCenterOffsetUnitsEnabled!==W.Screen?c.H`
            // Apply x/y in view space, but z in screen space (i.e. along posView direction)
            aux.posView += vec3(centerOffset.x, centerOffset.y, 0.0);

            // Same material all have same z != 0.0 condition so should not lead to
            // branch fragmentation and will save a normalization if it's not needed
            if (centerOffset.z != 0.0) {
              aux.posView -= normalize(aux.posView) * centerOffset.z;
            }
          `:""}

      vec4 posProj = proj * vec4(aux.posView, 1.0);

      ${X.screenCenterOffsetUnitsEnabled===W.Screen?X.hasScreenSizePerspective?"float centerOffsetY = applyScreenSizePerspectiveScaleFactorFloat(centerOffset.y, perspectiveFactor);":"float centerOffsetY = centerOffset.y;":""}

      ${X.screenCenterOffsetUnitsEnabled===W.Screen?"posProj.xy += vec2(centerOffset.x, centerOffsetY) * pixelRatio * 2.0 / viewport.zw * posProj.w;":""}

      // constant part of polygon offset emulation
      posProj.z -= groundRelative * polygonOffset * posProj.w;
      return posProj;
    }
  `),O.code.add(c.H`bool testVisibilityHUD(vec4 posProj) {
vec4 posProjCenter = alignToPixelCenter(posProj, viewport.zw);
vec4 occlusionPixel = texture2D(hudVisibilityTexture, .5 + .5 * posProjCenter.xy / posProjCenter.w);
if (renderTransparentlyOccludedHUD > 0.5) {
return occlusionPixel.r * occlusionPixel.g > 0.0 && occlusionPixel.g * renderTransparentlyOccludedHUD < 1.0;
}
return occlusionPixel.r * occlusionPixel.g > 0.0 && occlusionPixel.g == 1.0;
}`)}!function($){$[$.World=0]="World",$[$.Screen=1]="Screen",$[$.COUNT=2]="COUNT"}(W||(W={}))},27776:(Ve,Ee,a)=>{a.d(Ee,{R:()=>H});var m=a(47923),_=a(82793),g=a(19278),b=a(43177),q=a(95285),M=a(17625),c=a(35387),V=a(19755);function H(W,x){const{vertex:$,fragment:X}=W;x.hasMultipassGeometry&&$.include(_.S),x.hasMultipassTerrain&&W.varyings.add("depth","float"),$.code.add(M.H`
  void main(void) {
    vec4 posProjCenter;
    if (dot(position, position) > 0.0) {
      // Render single point to center of the pixel to avoid subpixel
      // filtering to affect the marker color
      ProjectHUDAux projectAux;
      vec4 posProj = projectPositionHUD(projectAux);
      posProjCenter = alignToPixelCenter(posProj, viewport.zw);

      ${x.hasMultipassGeometry?M.H`
        // Don't draw vertices behind geometry
        if(geometryDepthTest(.5 + .5 * posProjCenter.xy / posProjCenter.w, projectAux.posView.z)){
          posProjCenter = vec4(1e038, 1e038, 1e038, 1.0);
        }`:""}

      ${x.hasMultipassTerrain?"depth = projectAux.posView.z;":""}
      vec3 vpos = projectAux.posModel;
      if (rejectBySlice(vpos)) {
        // Project out of clip space
        posProjCenter = vec4(1e038, 1e038, 1e038, 1.0);
      }

    } else {
      // Project out of clip space
      posProjCenter = vec4(1e038, 1e038, 1e038, 1.0);
    }

    gl_Position = posProjCenter;
    gl_PointSize = 1.0;
  }
  `),x.hasMultipassTerrain&&X.include(m.S),x.hasMultipassTerrain&&X.uniforms.add([...(0,c.J)("terrainDepthTexture",(O,U)=>U.multipassTerrain.linearDepthTexture,x.hasWebGL2Context?V.D.None:V.D.InvSize),new q.A("nearFar",(O,U)=>U.camera.nearFar)]),X.include(g.n),X.code.add(M.H`
  void main() {
    gl_FragColor = vec4(1, 1, 1, 1);
    ${x.hasMultipassTerrain?M.H`
          vec2 uv = gl_FragCoord.xy;

          // Read the rgba data from the texture linear depth
          vec4 terrainDepthData = ${(0,b.b6)(x,"terrainDepthTexture","uv")};

          float terrainDepth = linearDepthFromFloat(rgba2float(terrainDepthData), nearFar);

          // If HUD vertex is behind terrain and the terrain depth is not the initialize value (e.g. we are not looking at the sky)
          // Mark the HUD vertex as occluded by transparent terrain
          if(depth < terrainDepth && terrainDepthData != vec4(0,0,0,1)){
            gl_FragColor.g = 0.5;
          }`:""}
  }
  `)}},45027:(Ve,Ee,a)=>{a.d(Ee,{E:()=>g,K:()=>_});var m=a(17625);function _(b){b.fragment.code.add(m.H`float normals2FoamIntensity(vec3 n, float waveStrength){
float normalizationFactor =  max(0.015, waveStrength);
return max((n.x + n.y)*0.3303545/normalizationFactor + 0.3303545, 0.0);
}`)}function g(b){b.fragment.code.add(m.H`vec3 foamIntensity2FoamColor(float foamIntensityExternal, float foamPixelIntensity, vec3 skyZenitColor, float dayMod){
return foamIntensityExternal * (0.075 * skyZenitColor * pow(foamPixelIntensity, 4.) +  50.* pow(foamPixelIntensity, 23.0)) * dayMod;
}`)}},92484:(Ve,Ee,a)=>{a.d(Ee,{q:()=>U,C:()=>se});var m=a(62208),_=a(19278),g=a(99198),b=a(43177),q=a(69960),M=a(65787),c=a(17625),V=a(35387),H=a(19755),W=a(51899),x=a(993),$=a(4794);const O=(0,$.c)();function U(k,y){k.constants.add("stippleAlphaColorDiscard","float",.001),k.constants.add("stippleAlphaHighlightDiscard","float",.5),y.stippleEnabled?function ce(k,y){const I=!(y.draped&&y.stipplePreferContinuous),{vertex:B,fragment:L}=k;L.include(_.n),y.draped||((0,g.hY)(B,y),B.uniforms.add(new M.p("worldToScreenPerDistanceRatio",(P,T)=>1/T.camera.perScreenPixelRatio)),B.code.add(c.H`float computeWorldToScreenRatio(vec3 segmentCenter) {
float segmentDistanceToCamera = length(segmentCenter - cameraPosition);
return worldToScreenPerDistanceRatio / segmentDistanceToCamera;
}`)),k.varyings.add("vStippleDistance","float"),y.stippleRequiresClamp&&k.varyings.add("vStippleDistanceLimits","vec2"),y.stippleRequiresStretchMeasure&&k.varyings.add("vStipplePatternStretch","float"),B.code.add(c.H`
    float discretizeWorldToScreenRatio(float worldToScreenRatio) {
      float step = ${te};

      float discreteWorldToScreenRatio = log(worldToScreenRatio);
      discreteWorldToScreenRatio = ceil(discreteWorldToScreenRatio / step) * step;
      discreteWorldToScreenRatio = exp(discreteWorldToScreenRatio);
      return discreteWorldToScreenRatio;
    }
  `),B.code.add(c.H`vec2 computeStippleDistanceLimits(float startPseudoScreen, float segmentLengthPseudoScreen, float segmentLengthScreen, float patternLength) {`),B.code.add(c.H`
    if (segmentLengthPseudoScreen >= ${I?"patternLength":"1e4"}) {
  `),B.uniforms.add(new M.p("pixelRatio",(P,T)=>T.camera.pixelRatio)),B.code.add(c.H`
        // Round the screen length to get an integer number of pattern repetitions (minimum 1).
        float repetitions = segmentLengthScreen / (patternLength * pixelRatio);
        float flooredRepetitions = max(1.0, floor(repetitions + 0.5));
        float segmentLengthScreenRounded = flooredRepetitions * patternLength;

        ${y.stippleRequiresStretchMeasure?c.H`
              float stretch = repetitions / flooredRepetitions;

              // We need to impose a lower bound on the stretch factor to prevent the dots from merging together when there is only 1 repetition.
              // 0.75 is the lowest possible stretch value for flooredRepetitions > 1, so it makes sense as lower bound.
              vStipplePatternStretch = max(0.75, stretch);`:""}

        return vec2(0.0, segmentLengthScreenRounded);
      }
      return vec2(startPseudoScreen, startPseudoScreen + segmentLengthPseudoScreen);
    }
  `),L.constants.add("stippleTexturePadding","float",W.it);L.uniforms.add((0,V.J)("stipplePatternTexture",P=>P.stippleTexture,y.hasWebGL2Context?H.D.None:H.D.Size)),L.uniforms.add([new M.p("stipplePatternSDFNormalizer",P=>function F(k){return(0,m.pC)(k)?(Math.floor(.5*((0,W.kj)(k)-1))+.5)/k.pixelRatio:1}(P.stipplePattern)),new M.p("stipplePatternPixelSizeInv",P=>1/se(P))]),L.code.add(c.H`
    float padStippleTexture(float u) {
      float paddedTextureSize = ${(0,b.w_)(y,"stipplePatternTexture")}.x;
      float unpaddedTextureSize = paddedTextureSize - stippleTexturePadding;

      return (u * unpaddedTextureSize + stippleTexturePadding * 0.5) / paddedTextureSize;
    }
  `),L.code.add(c.H`
    float getStippleSDF(out bool isClamped) {
      ${y.stippleRequiresClamp?c.H`
          float stippleDistanceClamped = clamp(vStippleDistance, vStippleDistanceLimits.x, vStippleDistanceLimits.y);
          vec2 aaCorrectedLimits = vStippleDistanceLimits + vec2(1.0, -1.0) / gl_FragCoord.w;
          isClamped = vStippleDistance < aaCorrectedLimits.x || vStippleDistance > aaCorrectedLimits.y;`:c.H`
          float stippleDistanceClamped = vStippleDistance;
          isClamped = false;`}

      float u = stippleDistanceClamped * gl_FragCoord.w * stipplePatternPixelSizeInv;
      ${y.stippleScaleWithLineWidth?c.H`u *= vLineSizeInv;`:""}
      u = padStippleTexture(fract(u));

      float encodedSDF = rgba2float(texture2D(stipplePatternTexture, vec2(u, 0.5)));
      float sdf = (encodedSDF * 2.0 - 1.0) * stipplePatternSDFNormalizer;

      ${y.stippleRequiresStretchMeasure?c.H`return (sdf - 0.5) * vStipplePatternStretch + 0.5;`:c.H`return sdf;`}
    }

    float getStippleSDF() {
      bool ignored;
      return getStippleSDF(ignored);
    }

    float getStippleAlpha() {
      bool isClamped;
      float stippleSDF = getStippleSDF(isClamped);

      float antiAliasedResult = ${y.stippleScaleWithLineWidth?c.H`clamp(stippleSDF * vLineWidth + 0.5, 0.0, 1.0);`:c.H`clamp(stippleSDF + 0.5, 0.0, 1.0);`}

      return isClamped ? floor(antiAliasedResult + 0.5) : antiAliasedResult;
    }
  `),y.stippleOffColorEnabled?(L.uniforms.add(new q.N("stippleOffColor",P=>function X(k){return(0,m.Wi)(k)?$.Z:4===k.length?k:(0,x.s)(O,k[0],k[1],k[2],1)}(P.stippleOffColor))),L.code.add(c.H`#define discardByStippleAlpha(stippleAlpha, threshold) {}
#define blendStipple(color, stippleAlpha) mix(color, stippleOffColor, stippleAlpha)`)):L.code.add(c.H`#define discardByStippleAlpha(stippleAlpha, threshold) if (stippleAlpha < threshold) { discard; }
#define blendStipple(color, stippleAlpha) vec4(color.rgb, color.a * stippleAlpha)`)}(k,y):function ye(k){k.fragment.code.add(c.H`float getStippleAlpha() { return 1.0; }
#define discardByStippleAlpha(_stippleAlpha_, _threshold_) {}
#define blendStipple(color, _stippleAlpha_) color`)}(k)}function se(k){const y=k.stipplePattern;return(0,m.pC)(y)?(0,W.$A)(k.stipplePattern)/y.pixelRatio:1}const te=c.H.float(.4)},50823:(Ve,Ee,a)=>{a.d(Ee,{Q:()=>M});var m=a(62208),_=a(81805),g=a(65787),b=a(17625),q=a(46359);function M(c,V){const H=c.vertex;c.constants.add("markerSizePerLineWidth","float",_._Z),H.uniforms.add(new g.p("pixelRatio",(W,x)=>x.camera.pixelRatio)),(0,m.Wi)(H.uniforms.get("markerScale"))&&H.constants.add("markerScale","float",1),H.code.add(b.H`float getLineWidth() {
return max(getSize(), 1.0) * pixelRatio;
}
float getScreenMarkerSize() {
return markerSizePerLineWidth * markerScale * getLineWidth();
}`),V.space===q.I9.World&&(H.constants.add("maxSegmentLengthFraction","float",.45),H.uniforms.add(new g.p("perRenderPixelRatio",(W,x)=>x.camera.perRenderPixelRatio)),H.code.add(b.H`float getWorldMarkerSize(vec4 pos) {
float distanceToCamera = length(pos.xyz);
float screenToWorldRatio = perRenderPixelRatio * distanceToCamera * 0.5;
return getScreenMarkerSize() * screenToWorldRatio;
}
bool areWorldMarkersHidden(vec4 pos, vec4 other) {
vec3 midPoint = mix(pos.xyz, other.xyz, 0.5);
float distanceToCamera = length(midPoint);
float screenToWorldRatio = perRenderPixelRatio * distanceToCamera * 0.5;
float worldMarkerSize = getScreenMarkerSize() * screenToWorldRatio;
float segmentLen = length(pos.xyz - other.xyz);
return worldMarkerSize > maxSegmentLengthFraction * segmentLen;
}`))}},82793:(Ve,Ee,a)=>{a.d(Ee,{S:()=>q,_:()=>M});var m=a(47923),_=a(95285),g=a(17625),b=a(35387);function q(c){c.include(m.S),c.uniforms.add([new b.A("geometryDepthTexture",(V,H)=>H.multipassGeometry.linearDepthTexture),new _.A("nearFar",(V,H)=>H.camera.nearFar)]),c.code.add(g.H`bool geometryDepthTest(vec2 pos, float elementDepth) {
float geometryDepth = linearDepthFromTexture(geometryDepthTexture, pos, nearFar);
return (elementDepth < (geometryDepth - 1.0));
}`)}class M{constructor(){this.enabled=!1}}},7025:(Ve,Ee,a)=>{a.d(Ee,{n:()=>_});var m=a(17625);function _(g,b){g.vertex.code.add(b.spherical?m.H`vec3 getLocalUp(in vec3 pos, in vec3 origin) {
return normalize(pos + origin);
}`:m.H`vec3 getLocalUp(in vec3 pos, in vec3 origin) {
return vec3(0.0, 0.0, 1.0);
}`),g.vertex.code.add(b.spherical?m.H`mat3 getTBNMatrix(in vec3 n) {
vec3 t = normalize(cross(vec3(0.0, 0.0, 1.0), n));
vec3 b = normalize(cross(n, t));
return mat3(t, b, n);
}`:m.H`mat3 getTBNMatrix(in vec3 n) {
vec3 t = vec3(1.0, 0.0, 0.0);
vec3 b = normalize(cross(n, t));
return mat3(t, b, n);
}`)}},45867:(Ve,Ee,a)=>{a.d(Ee,{O:()=>H,P:()=>V});var m=a(43703),_=a(47923),g=a(95285),b=a(65787),q=a(17625),M=a(63123),c=a(35387);function V(W,x){const $=W.fragment;$.include(_.S),$.uniforms.add(new g.A("nearFar",(X,O)=>O.camera.nearFar)),$.uniforms.add(new c.A("depthMap",(X,O)=>O.linearDepthTexture)),$.uniforms.add(new M.g("proj",(X,O)=>O.ssr.camera.projectionMatrix)),$.uniforms.add(new b.p("invResolutionHeight",(X,O)=>1/O.ssr.camera.height)),$.uniforms.add(new M.g("reprojectionMatrix",(X,O)=>O.ssr.reprojectionMatrix)),$.code.add(q.H`
  vec2 reprojectionCoordinate(vec3 projectionCoordinate)
  {
    vec4 zw = proj * vec4(0.0, 0.0, -projectionCoordinate.z, 1.0);
    vec4 reprojectedCoord = reprojectionMatrix * vec4(zw.w * (projectionCoordinate.xy * 2.0 - 1.0), zw.z, zw.w);
    reprojectedCoord.xy /= reprojectedCoord.w;
    return reprojectedCoord.xy * 0.5 + 0.5;
  }

  const int maxSteps = ${x.highStepCount?"150":"75"};

  vec4 applyProjectionMat(mat4 projectionMat, vec3 x)
  {
    vec4 projectedCoord =  projectionMat * vec4(x, 1.0);
    projectedCoord.xy /= projectedCoord.w;
    projectedCoord.xy = projectedCoord.xy*0.5 + 0.5;
    return projectedCoord;
  }

  vec3 screenSpaceIntersection(vec3 dir, vec3 startPosition, vec3 viewDir, vec3 normal)
  {
    vec3 viewPos = startPosition;
    vec3 viewPosEnd = startPosition;

    // Project the start position to the screen
    vec4 projectedCoordStart = applyProjectionMat(proj, viewPos);
    vec3  Q0 = viewPos / projectedCoordStart.w; // homogeneous camera space
    float k0 = 1.0/ projectedCoordStart.w;

    // advance the position in the direction of the reflection
    viewPos += dir;

    vec4 projectedCoordVanishingPoint = applyProjectionMat(proj, dir);

    // Project the advanced position to the screen
    vec4 projectedCoordEnd = applyProjectionMat(proj, viewPos);
    vec3  Q1 = viewPos / projectedCoordEnd.w; // homogeneous camera space
    float k1 = 1.0/ projectedCoordEnd.w;

    // calculate the reflection direction in the screen space
    vec2 projectedCoordDir = (projectedCoordEnd.xy - projectedCoordStart.xy);
    vec2 projectedCoordDistVanishingPoint = (projectedCoordVanishingPoint.xy - projectedCoordStart.xy);

    float yMod = min(abs(projectedCoordDistVanishingPoint.y), 1.0);

    float projectedCoordDirLength = length(projectedCoordDir);
    float maxSt = float(maxSteps);

    // normalize the projection direction depending on maximum steps
    // this determines how blocky the reflection looks
    vec2 dP = yMod * (projectedCoordDir)/(maxSt * projectedCoordDirLength);

    // Normalize the homogeneous camera space coordinates
    vec3  dQ = yMod * (Q1 - Q0)/(maxSt * projectedCoordDirLength);
    float dk = yMod * (k1 - k0)/(maxSt * projectedCoordDirLength);

    // initialize the variables for ray marching
    vec2 P = projectedCoordStart.xy;
    vec3 Q = Q0;
    float k = k0;
    float rayStartZ = -startPosition.z; // estimated ray start depth value
    float rayEndZ = -startPosition.z;   // estimated ray end depth value
    float prevEstimateZ = -startPosition.z;
    float rayDiffZ = 0.0;
    float dDepth;
    float depth;
    float rayDiffZOld = 0.0;

    // early outs
    if (dot(normal, dir) < 0.0 || dot(-viewDir, normal) < 0.0)
      return vec3(P, 0.0);

    for(int i = 0; i < maxSteps-1; i++)
    {
      depth = -linearDepthFromTexture(depthMap, P, nearFar); // get linear depth from the depth buffer

      // estimate depth of the marching ray
      rayStartZ = prevEstimateZ;
      dDepth = -rayStartZ - depth;
      rayEndZ = (dQ.z * 0.5 + Q.z)/ ((dk * 0.5 + k));
      rayDiffZ = rayEndZ- rayStartZ;
      prevEstimateZ = rayEndZ;

      if(-rayEndZ > nearFar[1] || -rayEndZ < nearFar[0] || P.y < 0.0  || P.y > 1.0 )
      {
        return vec3(P, 0.);
      }

      // If we detect a hit - return the intersection point, two conditions:
      //  - dDepth > 0.0 - sampled point depth is in front of estimated depth
      //  - if difference between dDepth and rayDiffZOld is not too large
      //  - if difference between dDepth and 0.025/abs(k) is not too large
      //  - if the sampled depth is not behind far plane or in front of near plane

      if((dDepth) < 0.025/abs(k) + abs(rayDiffZ) && dDepth > 0.0 && depth > nearFar[0] && depth < nearFar[1] && abs(P.y - projectedCoordStart.y) > invResolutionHeight)
      {
        return vec3(P, depth);
      }

      // continue with ray marching
      P += dP;
      Q.z += dQ.z;
      k += dk;
      rayDiffZOld = rayDiffZ;
    }
    return vec3(P, 0.0);
  }
  `)}class H{constructor(){this.enabled=!1,this.fadeFactor=1,this.reprojectionMatrix=(0,m.c)()}}},61594:(Ve,Ee,a)=>{a.d(Ee,{B:()=>k});var m=a(45027),_=a(17625);function g(y){y.fragment.code.add(_.H`const float GAMMA = 2.2;
const float INV_GAMMA = 0.4545454545;
vec4 delinearizeGamma(vec4 color) {
return vec4(pow(color.rgb, vec3(INV_GAMMA)), color.w);
}
vec3 linearizeGamma(vec3 color) {
return pow(color, vec3(GAMMA));
}`)}var b=a(98898),q=a(45867),M=a(21286),c=a(62208),V=a(94425),H=a(12015),W=a(75583),x=a(31166),$=a(78038),X=a(97139),O=a(65787),U=a(63123),ce=a(85930),ye=a(37847);class F extends ce.x{constructor(I,B){super(I,"samplerCube",ye.P.Pass,(L,Y,P)=>L.bindTexture(I,B(Y,P)))}}function se(y){const I=y.fragment;I.uniforms.add([new U.g("rotationMatrixClouds",(B,L)=>L.cloudsFade.parallax.transform),new U.g("rotationMatrixCloudsCrossFade",(B,L)=>L.cloudsFade.parallaxNew.transform),new X.J("anchorPosition",(B,L)=>L.cloudsFade.parallax.anchorPointClouds),new X.J("anchorPositionCrossFade",(B,L)=>L.cloudsFade.parallaxNew.anchorPointClouds),new O.p("cloudsHeight",(B,L)=>L.cloudsFade.parallax.cloudsHeight),new O.p("radiusCurvatureCorrectionFactor",(B,L)=>L.cloudsFade.parallax.radiusCurvatureCorrectionFactor),new O.p("totalFadeInOut",(B,L)=>L.cloudsFade.fadeInOut.stage===H.co.FINISHED?L.cloudsFade.fadeInOutHeight.factor+1-L.cloudsFade.fadeIn.factor:L.cloudsFade.fadeInOutHeight.factor+1-L.cloudsFade.fadeInOut.factor),new O.p("crossFadeAnchorFactor",(B,L)=>(0,M.uZ)(L.cloudsFade.crossFade.factor,0,1)),new F("cubeMap",(B,L)=>(0,c.pC)(L.cloudsFade.data)&&(0,c.pC)(L.cloudsFade.data.cubeMap)?L.cloudsFade.data.cubeMap.colorTexture:null),new $.U("crossFade",(B,L)=>L.cloudsFade.crossFade.enabled),new $.U("readChannelsRG",(B,L)=>L.cloudsFade.readChannels===W.uz.RG),new $.U("fadeTextureChannels",(B,L)=>L.cloudsFade.renderingStage===W.jL.FADING_TEXTURE_CHANNELS)]),I.constants.add("planetRadius","float",V.sv.radius),I.code.add(_.H`vec3 intersectWithCloudLayer(vec3 dir, vec3 cameraPosition, vec3 spherePos)
{
float radiusClouds = planetRadius + cloudsHeight;
float B = 2.0 * dot(cameraPosition, dir);
float C = dot(cameraPosition, cameraPosition) - radiusClouds * radiusClouds;
float det = B * B - 4.0 * C;
float pointIntDist = max(0.0, 0.5 *(-B + sqrt(det)));
vec3 intersectionPont = cameraPosition + dir * pointIntDist;
intersectionPont =  intersectionPont - spherePos;
return intersectionPont;
}`),I.code.add(_.H`vec3 correctForPlanetCurvature(vec3 dir)
{
dir.z = dir.z*(1.-radiusCurvatureCorrectionFactor) + radiusCurvatureCorrectionFactor;
return dir;
}`),I.code.add(_.H`vec3 rotateDirectionToAnchorPoint(mat4 rotMat, vec3 inVec)
{
return (rotMat * vec4(inVec, 0.0)).xyz;
}`),(0,x.Pe)(I),(0,x.F1)(I),I.code.add(_.H`const float SUNSET_TRANSITION_FACTOR = 0.3;
const vec3 RIM_COLOR = vec3(0.28, 0.175, 0.035);
const float RIM_SCATTERING_FACTOR = 140.0;
const float BACKLIGHT_FACTOR = 0.2;
const float BACKLIGHT_SCATTERING_FACTOR = 10.0;
const float BACKLIGHT_TRANSITION_FACTOR = 0.3;
vec3 calculateCloudColor(vec3 cameraPosition, vec3 worldSpaceRay, vec4 clouds)
{
float upDotLight = dot(normalize(cameraPosition), normalize(mainLightDirection));
float dirDotLight = max(dot(normalize(-worldSpaceRay), normalize(mainLightDirection)), 0.0);
float sunsetTransition = clamp(pow(max(upDotLight, 0.0), SUNSET_TRANSITION_FACTOR), 0.0, 1.0);
vec3 ambientLight = calculateAmbientIrradiance(normalize(cameraPosition),  0.0);
vec3 mainLight = evaluateMainLighting(normalize(cameraPosition),  0.0);
vec3 combinedLight = clamp((mainLightIntensity + ambientLight )/PI, vec3(0.0), vec3(1.0));
vec3 baseCloudColor = pow(combinedLight * pow(clouds.xyz, vec3(GAMMA)), vec3(INV_GAMMA));
float scatteringMod = max(clouds.a < 0.5 ? clouds.a / 0.5 : - clouds.a / 0.5 + 2.0, 0.0);
float rimLightIntensity = 0.5 + 0.5 *pow(max(upDotLight, 0.0), 0.35);
vec3 directSunScattering = RIM_COLOR * rimLightIntensity * (pow(dirDotLight, RIM_SCATTERING_FACTOR)) * scatteringMod;
float additionalLight = BACKLIGHT_FACTOR * pow(dirDotLight, BACKLIGHT_SCATTERING_FACTOR) * (1. - pow(sunsetTransition, BACKLIGHT_TRANSITION_FACTOR)) ;
return vec3(baseCloudColor * (1. + additionalLight) + directSunScattering);
}`),I.code.add(_.H`vec4 getCloudData(vec3 rayDir, bool readOtherChannel)
{
vec4 cloudData = textureCube(cubeMap, rayDir);
float mu = dot(rayDir, vec3(0, 0, 1));
bool readChannels = readChannelsRG ^^ readOtherChannel;
if (readChannels) {
cloudData = vec4(vec3(cloudData.r), cloudData.g);
} else {
cloudData = vec4(vec3(cloudData.b), cloudData.a);
}
if (length(cloudData) == 0.0) {
return vec4(cloudData.rgb, 1.0);
}
return cloudData;
}`),I.code.add(_.H`vec4 renderCloudsNoFade(vec3 worldRay, vec3 cameraPosition)
{
vec3 intersectionPoint = intersectWithCloudLayer(normalize(worldRay), cameraPosition, anchorPosition);
vec3 worldRayRotated = rotateDirectionToAnchorPoint(rotationMatrixClouds, normalize(intersectionPoint));
vec3 worldRayRotatedCorrected = correctForPlanetCurvature(worldRayRotated);
vec4 cloudData = getCloudData(worldRayRotatedCorrected, false);
float totalTransmittance = clamp(cloudData.a * (1.0 - totalFadeInOut) + totalFadeInOut, 0.0 , 1.0);
if (length(cloudData.rgb) == 0.0) {
totalTransmittance = 1.0;
}
return vec4(calculateCloudColor(cameraPosition, normalize(-worldRay), cloudData), totalTransmittance);
}`),I.code.add(_.H`vec4 renderCloudsCrossFade(vec3 worldRay, vec3 cameraPosition)
{
vec3 intersectionPoint = intersectWithCloudLayer(normalize(worldRay), cameraPosition, anchorPosition);
vec3 worldRayRotated = rotateDirectionToAnchorPoint(rotationMatrixClouds, normalize(intersectionPoint));
vec3 worldRayRotatedCorrected = correctForPlanetCurvature(worldRayRotated);
vec4 cloudData = getCloudData(worldRayRotatedCorrected, false);
vec4 cloudColor = vec4(calculateCloudColor(cameraPosition, normalize(-worldRay), cloudData), cloudData.a);
intersectionPoint = intersectWithCloudLayer(normalize(worldRay), cameraPosition, anchorPositionCrossFade);
worldRayRotated = rotateDirectionToAnchorPoint(rotationMatrixCloudsCrossFade, normalize(intersectionPoint));
worldRayRotatedCorrected = correctForPlanetCurvature(worldRayRotated);
cloudData = getCloudData(worldRayRotatedCorrected, fadeTextureChannels);
vec4 cloudColorCrossFade = vec4(calculateCloudColor(cameraPosition, normalize(-worldRay), cloudData), cloudData.a);
cloudColor = mix(cloudColor, cloudColorCrossFade, crossFadeAnchorFactor);
float totalTransmittance = clamp(cloudColor.a * (1.0 - totalFadeInOut) + totalFadeInOut, 0.0 , 1.0);
if (length(cloudColor.rgb) == 0.0) {
totalTransmittance = 1.0;
}
return vec4(cloudColor.rgb, totalTransmittance);
}`),I.code.add(_.H`vec4 renderClouds(vec3 worldRay, vec3 cameraPosition)
{
return crossFade ? renderCloudsCrossFade(worldRay, cameraPosition) : renderCloudsNoFade(worldRay, cameraPosition);
}`)}var te=a(35387);function k(y,I){y.include(b.g,I),y.include(g),y.include(m.E),I.hasCloudsReflections&&y.include(se,I),I.hasScreenSpaceReflections&&y.include(q.P,I);const B=y.fragment;B.constants.add("fresnelSky","vec3",[.02,1,15]).add("fresnelMaterial","vec2",[.02,.1]).add("roughness","float",.015).add("foamIntensityExternal","float",1.7).add("ssrIntensity","float",.65).add("ssrHeightFadeStart","float",3e5).add("ssrHeightFadeEnd","float",5e5).add("waterDiffusion","float",.92).add("waterSeaColorMod","float",.8).add("correctionViewingPowerFactor","float",.4).add("skyZenitColor","vec3",[.52,.68,.9]).add("skyColor","vec3",[.67,.79,.9]).add("cloudFresnelModifier","vec2",[1.2,.01]),B.code.add(_.H`PBRShadingWater shadingInfo;
vec3 getSkyGradientColor(in float cosTheta, in vec3 horizon, in vec3 zenit) {
float exponent = pow((1.0 - cosTheta), fresnelSky[2]);
return mix(zenit, horizon, exponent);
}`),B.uniforms.add([new O.p("lightingSpecularStrength",(L,Y)=>Y.lighting.mainLight.specularStrength),new O.p("lightingEnvironmentStrength",(L,Y)=>Y.lighting.mainLight.environmentStrength)]),B.code.add(_.H`vec3 getSeaColor(in vec3 n, in vec3 v, in vec3 l, vec3 color, in vec3 lightIntensity, in vec3 localUp, in float shadow, float foamIntensity, vec3 viewPosition, vec3 position) {
float reflectionHit = 0.0;
float reflectionHitDiffused = 0.0;
vec3 seaWaterColor = linearizeGamma(color);
vec3 h = normalize(l + v);
shadingInfo.NdotL = clamp(dot(n, l), 0.0, 1.0);
shadingInfo.NdotV = clamp(dot(n, v), 0.001, 1.0);
shadingInfo.VdotN = clamp(dot(v, n), 0.001, 1.0);
shadingInfo.NdotH = clamp(dot(n, h), 0.0, 1.0);
shadingInfo.VdotH = clamp(dot(v, h), 0.0, 1.0);
shadingInfo.LdotH = clamp(dot(l, h), 0.0, 1.0);
float upDotV = max(dot(localUp,v), 0.0);
vec3 skyHorizon = linearizeGamma(skyColor);
vec3 skyZenit = linearizeGamma(skyZenitColor);
vec3 skyColor = getSkyGradientColor(upDotV, skyHorizon, skyZenit );
float upDotL = max(dot(localUp,l),0.0);
float daytimeMod = 0.1 + upDotL * 0.9;
skyColor *= daytimeMod;
float shadowModifier = clamp(shadow, 0.8, 1.0);
vec3 fresnelModifier = fresnelReflection(shadingInfo.VdotN, vec3(fresnelSky[0]), fresnelSky[1]);
vec3 reflSky = lightingEnvironmentStrength * fresnelModifier * skyColor * shadowModifier;
vec3 reflSea = seaWaterColor * mix(skyColor, upDotL * lightIntensity * LIGHT_NORMALIZATION, 2.0 / 3.0) * shadowModifier;
vec3 specular = vec3(0.0);
if(upDotV > 0.0 && upDotL > 0.0) {
vec3 specularSun = brdfSpecularWater(shadingInfo, roughness, vec3(fresnelMaterial[0]), fresnelMaterial[1]);
vec3 incidentLight = lightIntensity * LIGHT_NORMALIZATION * shadow;
specular = lightingSpecularStrength * shadingInfo.NdotL * incidentLight * specularSun;
}
vec3 foam = vec3(0.0);
if(upDotV > 0.0) {
foam = foamIntensity2FoamColor(foamIntensityExternal, foamIntensity, skyZenitColor, daytimeMod);
}
float correctionViewingFactor = pow(max(dot(v, localUp), 0.0), correctionViewingPowerFactor);
vec3 normalCorrectedClouds = mix(localUp, n, correctionViewingFactor);
vec3 reflectedWorld = normalize(reflect(-v, normalCorrectedClouds));`),I.hasCloudsReflections&&B.code.add(_.H`vec4 cloudsColor = renderClouds(reflectedWorld, position);
cloudsColor.a = 1.0 - cloudsColor.a;
cloudsColor = pow(cloudsColor, vec4(GAMMA));
cloudsColor *= clamp(fresnelModifier.y*cloudFresnelModifier[0] - cloudFresnelModifier[1], 0.0, 1.0) * clamp((1.0 - totalFadeInOut), 0.0, 1.0);`),I.hasScreenSpaceReflections?(B.uniforms.add([new U.g("view",(L,Y)=>Y.ssr.camera.viewMatrix),new te.A("lastFrameColorTexture",(L,Y)=>Y.ssr.lastFrameColorTexture),new O.p("fadeFactor",(L,Y)=>Y.ssr.fadeFactor)]),B.code.add(_.H`vec3 viewDir = normalize(viewPosition);
vec4 viewNormalVectorCoordinate = view *vec4(n, 0.0);
vec3 viewNormal = normalize(viewNormalVectorCoordinate.xyz);
vec4 viewUp = view * vec4(localUp, 0.0);
vec3 viewNormalCorrectedSSR = mix(viewUp.xyz, viewNormal, correctionViewingFactor);
vec3 reflected = normalize(reflect(viewDir, viewNormalCorrectedSSR));
vec3 hitCoordinate = screenSpaceIntersection(reflected, viewPosition, viewDir, viewUp.xyz);
vec3 reflectedColor = vec3(0.0);
if (hitCoordinate.z > 0.0)
{
vec2 reprojectedCoordinate = reprojectionCoordinate(hitCoordinate);
vec2 dCoords = smoothstep(0.3, 0.6, abs(vec2(0.5, 0.5) - hitCoordinate.xy));
float heightMod = smoothstep(ssrHeightFadeEnd, ssrHeightFadeStart, -viewPosition.z);
reflectionHit = clamp(1.0 - (1.3 * dCoords.y), 0.0, 1.0) * heightMod * fadeFactor;
reflectionHitDiffused = waterDiffusion * reflectionHit;
reflectedColor = linearizeGamma(texture2D(lastFrameColorTexture, reprojectedCoordinate).xyz) *
reflectionHitDiffused * fresnelModifier.y * ssrIntensity;
}
float seaColorMod =  mix(waterSeaColorMod, waterSeaColorMod * 0.5, reflectionHitDiffused);
vec3 waterRenderedColor = tonemapACES((1.0 - reflectionHitDiffused) * reflSky + reflectedColor +
reflSea * seaColorMod + specular + foam);`)):B.code.add(_.H`vec3 waterRenderedColor = tonemapACES(reflSky + reflSea * waterSeaColorMod + specular + foam);`),B.code.add(I.hasCloudsReflections?I.hasScreenSpaceReflections?_.H`return waterRenderedColor * (1.0 - (1.0 - reflectionHit) * cloudsColor.a) + (1.0 - reflectionHit) * cloudsColor.xyz;
}`:_.H`return waterRenderedColor * (1.0 - cloudsColor.a) + cloudsColor.xyz;
}`:_.H`return waterRenderedColor;
}`)}},45780:(Ve,Ee,a)=>{a.d(Ee,{M:()=>W});var m=a(67831),_=a(99770),g=a(993),b=a(4794),q=a(45027),M=a(95285),c=a(69960),V=a(17625),H=a(35387);function W(O){O.fragment.uniforms.add(new H.A("texWaveNormal",U=>U.waveNormal)),O.fragment.uniforms.add(new H.A("texWavePerturbation",U=>U.wavePertubation)),O.fragment.uniforms.add([new c.N("waveParams",U=>(0,g.s)($,U.waveStrength,U.waveTextureRepeat,U.flowStrength,U.flowOffset)),new M.A("waveDirection",U=>(0,m.s)(X,U.waveDirection[0]*U.waveVelocity,U.waveDirection[1]*U.waveVelocity))]),O.include(q.K),O.fragment.code.add(V.H`const vec2  FLOW_JUMP = vec2(6.0/25.0, 5.0/24.0);
vec2 textureDenormalized2D(sampler2D _tex, vec2 _uv) {
return 2.0 * texture2D(_tex, _uv).rg - 1.0;
}
float sampleNoiseTexture(vec2 _uv) {
return texture2D(texWavePerturbation, _uv).b;
}
vec3 textureDenormalized3D(sampler2D _tex, vec2 _uv) {
return 2.0 * texture2D(_tex, _uv).rgb - 1.0;
}
float computeProgress(vec2 uv, float time) {
return fract(time);
}
float computeWeight(vec2 uv, float time) {
float progress = computeProgress(uv, time);
return 1.0 - abs(1.0 - 2.0 * progress);
}
vec3 computeUVPerturbedWeigth(sampler2D texFlow, vec2 uv, float time, float phaseOffset) {
float flowStrength = waveParams[2];
float flowOffset = waveParams[3];
vec2 flowVector = textureDenormalized2D(texFlow, uv) * flowStrength;
float progress = computeProgress(uv, time + phaseOffset);
float weight = computeWeight(uv, time + phaseOffset);
vec2 result = uv;
result -= flowVector * (progress + flowOffset);
result += phaseOffset;
result += (time - progress) * FLOW_JUMP;
return vec3(result, weight);
}
const float TIME_NOISE_TEXTURE_REPEAT = 0.3737;
const float TIME_NOISE_STRENGTH = 7.77;
vec3 getWaveLayer(sampler2D _texNormal, sampler2D _dudv, vec2 _uv, vec2 _waveDir, float time) {
float waveStrength = waveParams[0];
vec2 waveMovement = time * -_waveDir;
float timeNoise = sampleNoiseTexture(_uv * TIME_NOISE_TEXTURE_REPEAT) * TIME_NOISE_STRENGTH;
vec3 uv_A = computeUVPerturbedWeigth(_dudv, _uv + waveMovement, time + timeNoise, 0.0);
vec3 uv_B = computeUVPerturbedWeigth(_dudv, _uv + waveMovement, time + timeNoise, 0.5);
vec3 normal_A = textureDenormalized3D(_texNormal, uv_A.xy) * uv_A.z;
vec3 normal_B = textureDenormalized3D(_texNormal, uv_B.xy) * uv_B.z;
vec3 mixNormal = normalize(normal_A + normal_B);
mixNormal.xy *= waveStrength;
mixNormal.z = sqrt(1.0 - dot(mixNormal.xy, mixNormal.xy));
return mixNormal;
}
vec4 getSurfaceNormalAndFoam(vec2 _uv, float _time) {
float waveTextureRepeat = waveParams[1];
vec3 normal = getWaveLayer(texWaveNormal, texWavePerturbation, _uv * waveTextureRepeat, waveDirection, _time);
float foam  = normals2FoamIntensity(normal, waveParams[0]);
return vec4(normal, foam);
}`)}const $=(0,b.c)(),X=(0,_.a)()},59598:(Ve,Ee,a)=>{a.d(Ee,{V:()=>P});var Y,m=a(17626),_=a(14517),g=a(63290),b=a(21286),q=a(23841),M=a(77712),H=(a(90912),a(85931),a(76898)),W=a(28347),x=a(43703),$=a(67831),X=a(99770),O=a(84161),U=a(28093),ce=a(993),ye=a(4794),F=a(8834),se=a(70562),te=a(34054),k=a(59617);let P=Y=class extends _.Z{constructor(v={}){super(v),this._center=(0,U.c)(),this._up=(0,U.c)(),this._viewUp=(0,U.c)(),this._viewForward=(0,U.c)(),this._viewRight=(0,U.c)(),this._ray=(0,se.Ue)(),this._viewport=(0,ye.f)(0,0,1,1),this._padding=(0,ye.f)(0,0,0,0),this._fov=55/180*Math.PI,this._nearFar=(0,X.f)(1,1e3),this._viewDirty=!0,this._viewMatrix=(0,x.c)(),this._viewProjectionDirty=!0,this._viewProjectionMatrix=(0,x.c)(),this._viewInverseTransposeMatrixDirty=!0,this._viewInverseTransposeMatrix=(0,x.c)(),this._frustumDirty=!0,this._frustum=(0,F.Ue)(),this._fullViewport=(0,ye.c)(),this._pixelRatio=1,this.relativeElevation=0}get pixelRatio(){return this._pixelRatio}set pixelRatio(v){this._pixelRatio=v>0?v:1}get eye(){return this._ray.origin}set eye(v){this._compareAndSetView(v,this._ray.origin)}get center(){return this._center}set center(v){this._compareAndSetView(v,this._center,"_center")}get ray(){return(0,O.b)(this._ray.direction,this.center,this.eye),this._ray}get up(){return this._up}set up(v){this._compareAndSetView(v,this._up,"_up")}get viewMatrix(){return this._ensureViewClean(),this._viewMatrix}set viewMatrix(v){(0,W.c)(this._viewMatrix,v),this._viewDirty=!1,this._viewInverseTransposeMatrixDirty=!0,this._viewProjectionDirty=!0,this._frustumDirty=!0}get viewForward(){return this._ensureViewClean(),this._viewForward}get viewUp(){return this._ensureViewClean(),this._viewUp}get viewRight(){return this._ensureViewClean(),this._viewRight}get nearFar(){return this._nearFar}get near(){return this._nearFar[0]}set near(v){this._nearFar[0]!==v&&(this._nearFar[0]=v,this._viewProjectionDirty=!0,this._frustumDirty=!0,this.notifyChange("_nearFar"))}get far(){return this._nearFar[1]}set far(v){this._nearFar[1]!==v&&(this._nearFar[1]=v,this._viewProjectionDirty=!0,this._frustumDirty=!0,this.notifyChange("_nearFar"))}get viewport(){return this._viewport}set viewport(v){this.x=v[0],this.y=v[1],this.width=v[2],this.height=v[3]}get screenViewport(){if(1===this.pixelRatio)return this._viewport;const v=(0,ce.b)((0,ye.c)(),this._viewport,1/this.pixelRatio),E=this._get("screenViewport");return E&&(0,ce.h)(v,E)?E:v}get x(){return this._viewport[0]}set x(v){this._viewport[0]!==(v+=this._padding[ie.LEFT])&&(this._viewport[0]=v,this._viewProjectionDirty=!0,this._frustumDirty=!0,this.notifyChange("_viewport"))}get y(){return this._viewport[1]}set y(v){this._viewport[1]!==(v+=this._padding[ie.BOTTOM])&&(this._viewport[1]=v,this._viewProjectionDirty=!0,this._frustumDirty=!0,this.notifyChange("_viewport"))}get width(){return this._viewport[2]}set width(v){this._viewport[2]!==v&&(this._viewport[2]=v,this._viewProjectionDirty=!0,this._frustumDirty=!0,this.notifyChange("_viewport"))}get height(){return this._viewport[3]}set height(v){this._viewport[3]!==v&&(this._viewport[3]=v,this._viewProjectionDirty=!0,this._frustumDirty=!0,this.notifyChange("_viewport"))}get fullWidth(){return this._viewport[2]+this._padding[ie.RIGHT]+this._padding[ie.LEFT]}set fullWidth(v){this.width=v-(this._padding[ie.RIGHT]+this._padding[ie.LEFT])}get fullHeight(){return this._viewport[3]+this._padding[ie.TOP]+this._padding[ie.BOTTOM]}set fullHeight(v){this.height=v-(this._padding[ie.TOP]+this._padding[ie.BOTTOM])}get fullViewport(){return this._fullViewport[0]=this._viewport[0]-this._padding[ie.LEFT],this._fullViewport[1]=this._viewport[1]-this._padding[ie.BOTTOM],this._fullViewport[2]=this.fullWidth,this._fullViewport[3]=this.fullHeight,this._fullViewport}get _aspect(){return this.width/this.height}get padding(){return this._padding}set padding(v){(0,ce.g)(this._padding,v)||(this._viewport[0]+=v[ie.LEFT]-this._padding[ie.LEFT],this._viewport[1]+=v[ie.BOTTOM]-this._padding[ie.BOTTOM],this._viewport[2]-=v[ie.RIGHT]+v[ie.LEFT]-(this._padding[ie.RIGHT]+this._padding[ie.LEFT]),this._viewport[3]-=v[ie.TOP]+v[ie.BOTTOM]-(this._padding[ie.TOP]+this._padding[ie.BOTTOM]),(0,ce.c)(this._padding,v),this._viewProjectionDirty=!0,this._frustumDirty=!0,this.notifyChange("_padding"),this.notifyChange("_viewport"))}get viewProjectionMatrix(){return this._viewProjectionDirty&&((0,W.m)(this._viewProjectionMatrix,this.projectionMatrix,this.viewMatrix),this._viewProjectionDirty=!1),this._viewProjectionMatrix}get projectionMatrix(){const v=this.width,E=this.height,K=this.near*Math.tan(this.fovY/2),ue=K*this._aspect,Me=(0,W.q)((0,x.c)(),-ue*(1+2*this._padding[ie.LEFT]/v),ue*(1+2*this._padding[ie.RIGHT]/v),-K*(1+2*this._padding[ie.BOTTOM]/E),K*(1+2*this._padding[ie.TOP]/E),this.near,this.far),Le=this._get("projectionMatrix");return Le&&(0,W.h)(Le,Me)?Le:Me}get inverseProjectionMatrix(){return(0,W.a)((0,x.c)(),this.projectionMatrix)||this._get("inverseProjectionMatrix")||(0,x.c)()}get fov(){return this._fov}set fov(v){this._fov=v,this._viewProjectionDirty=!0,this._frustumDirty=!0}get fovX(){return function B(v,E,K){return 2*Math.atan(E*Math.tan(.5*v)/Math.sqrt(E*E+K*K))}(this._fov,this.width,this.height)}set fovX(v){this._fov=function y(v,E,K){return 2*Math.atan(Math.sqrt(E*E+K*K)*Math.tan(.5*v)/E)}(v,this.width,this.height),this._viewProjectionDirty=!0,this._frustumDirty=!0}get fovY(){return function L(v,E,K){return 2*Math.atan(K*Math.tan(.5*v)/Math.sqrt(E*E+K*K))}(this._fov,this.width,this.height)}set fovY(v){this._fov=function I(v,E,K){return 2*Math.atan(Math.sqrt(E*E+K*K)*Math.tan(.5*v)/K)}(v,this.width,this.height),this._viewProjectionDirty=!0,this._frustumDirty=!0}get distance(){return(0,O.i)(this.center,this.eye)}get frustum(){return this._recomputeFrustum(),this._frustum}get viewInverseTransposeMatrix(){return(this._viewInverseTransposeMatrixDirty||this._viewDirty)&&((0,W.a)(this._viewInverseTransposeMatrix,this.viewMatrix),(0,W.t)(this._viewInverseTransposeMatrix,this._viewInverseTransposeMatrix),this._viewInverseTransposeMatrixDirty=!1),this._viewInverseTransposeMatrix}depthNDCToWorld(v){return 2*this.near*this.far/(this.far+this.near-(2*v-1)*(this.far-this.near))}get perRenderPixelRatio(){return Math.tan(this.fovX/2)/(this.width/2)}get perScreenPixelRatio(){return this.perRenderPixelRatio*this.pixelRatio}get aboveGround(){return null!=this.relativeElevation&&this.relativeElevation>=0}copyFrom(v){(0,O.c)(this._ray.origin,v.eye),this.center=v.center,this.up=v.up,(0,ce.c)(this._viewport,v.viewport),this.notifyChange("_viewport"),(0,ce.c)(this._padding,v.padding),this.notifyChange("_padding"),(0,$.c)(this._nearFar,v.nearFar),this.notifyChange("_nearFar"),this._fov=v.fov,this.relativeElevation=v.relativeElevation;const E=v;return this._viewDirty=E._viewDirty,this._viewDirty||((0,W.c)(this._viewMatrix,v.viewMatrix),(0,O.c)(this._viewRight,v.viewRight),(0,O.c)(this._viewUp,v.viewUp),(0,O.c)(this._viewForward,v.viewForward)),this._viewProjectionDirty=!0,this._frustumDirty=E._frustumDirty,this._frustumDirty||((0,F.JG)(this._frustum,v.frustum),this._frustumDirty=!1),E._viewInverseTransposeMatrixDirty?this._viewInverseTransposeMatrixDirty=!0:((0,W.c)(this._viewInverseTransposeMatrix,v.viewInverseTransposeMatrix),this._viewInverseTransposeMatrixDirty=!1),(0,ce.c)(this._fullViewport,v.fullViewport),this.pixelRatio=v.pixelRatio,this}copyViewFrom(v){this.eye=v.eye,this.center=v.center,this.up=v.up}clone(){return(new Y).copyFrom(this)}equals(v){return(0,O.k)(this.eye,v.eye)&&(0,O.k)(this.center,v.center)&&(0,O.k)(this.up,v.up)&&(0,ce.g)(this._viewport,v.viewport)&&(0,ce.g)(this._padding,v.padding)&&(0,$.m)(this.nearFar,v.nearFar)&&this._fov===v.fov&&this.pixelRatio===v.pixelRatio&&this.relativeElevation===v.relativeElevation}almostEquals(v){if(Math.abs(v.fov-this._fov)>=.001||(0,ce.i)(v.padding,this._padding)>=.5||(0,ce.i)(this.screenViewport,v.screenViewport)>=.5)return!1;(0,O.w)(w,v.eye,v.center),(0,O.w)(C,this.eye,this.center);const E=(0,O.e)(w,C),K=(0,O.D)(w),ue=(0,O.D)(C);return E*E>=(1-1e-10)*K*ue&&(0,O.E)(v.eye,this.eye)<5e-4*Math.max(K,ue)*5e-4}computeRenderPixelSizeAt(v){return this.computeRenderPixelSizeAtDist(this._viewDirectionDistance(v))}computeRenderPixelSizeAtDist(v){return v*this.perRenderPixelRatio}computeScreenPixelSizeAt(v){return this.computeScreenPixelSizeAtDist(this._viewDirectionDistance(v))}_viewDirectionDistance(v){return Math.abs((0,te.SR)(this.viewForward,(0,O.b)(w,v,this.eye)))}computeScreenPixelSizeAtDist(v){return v*this.perScreenPixelRatio}computeDistanceFromRadius(v,E){return v/Math.tan(Math.min(this.fovX,this.fovY)/(2*(E||1)))}getScreenCenter(v=(0,q.s1)()){return v[0]=(this.padding[ie.LEFT]+this.width/2)/this.pixelRatio,v[1]=(this.padding[ie.TOP]+this.height/2)/this.pixelRatio,v}getRenderCenter(v,E=.5,K=.5){return v[0]=this.padding[ie.LEFT]+this.width*E,v[1]=this.padding[ie.BOTTOM]+this.height*K,v[2]=.5,v}setGLViewport(v){const E=this.viewport,K=this.padding;v.setViewport(E[0]-K[3],E[1]-K[2],E[2]+K[1]+K[3],E[3]+K[0]+K[2])}applyProjection(v,E){v!==T&&(0,O.c)(T,v),T[3]=1,(0,ce.t)(T,T,this.projectionMatrix);const K=Math.abs(T[3]);(0,O.g)(T,T,1/K);const ue=this.fullViewport;E[0]=(0,b.t7)(0,ue[0]+ue[2],.5+.5*T[0]),E[1]=(0,b.t7)(0,ue[1]+ue[3],.5+.5*T[1]),E[2]=.5*(T[2]+1),E[3]=K}unapplyProjection(v,E){const K=this.fullViewport;T[0]=(v[0]/(K[0]+K[2])*2-1)*v[3],T[1]=(v[1]/(K[1]+K[3])*2-1)*v[3],T[2]=(2*v[2]-1)*v[3],T[3]=v[3],null!=this.inverseProjectionMatrix&&((0,ce.t)(T,T,this.inverseProjectionMatrix),E[0]=T[0],E[1]=T[1],E[2]=T[2])}projectToScreen(v,E){return this.projectToRenderScreen(v,J),this.renderToScreen(J,E),E}projectToRenderScreen(v,E){if(T[0]=v[0],T[1]=v[1],T[2]=v[2],T[3]=1,(0,ce.t)(T,T,this.viewProjectionMatrix),0===T[3])return null;(0,O.g)(T,T,1/Math.abs(T[3]));const K=this.fullViewport;return"x"in E?(E.x=(0,b.t7)(0,K[0]+K[2],.5+.5*T[0]),E.y=(0,b.t7)(0,K[1]+K[3],.5+.5*T[1])):(E[0]=(0,b.t7)(0,K[0]+K[2],.5+.5*T[0]),E[1]=(0,b.t7)(0,K[1]+K[3],.5+.5*T[1]),E.length>2&&(E[2]=.5*(T[2]+1))),E}unprojectFromScreen(v,E){return this.unprojectFromRenderScreen(this.screenToRender(v,J),E)}unprojectFromRenderScreen(v,E){if((0,W.m)(Q,this.projectionMatrix,this.viewMatrix),!(0,W.a)(Q,Q))return null;const K=this.fullViewport;return T[0]=2*(v[0]-K[0])/K[2]-1,T[1]=2*(v[1]-K[1])/K[3]-1,T[2]=2*v[2]-1,T[3]=1,(0,ce.t)(T,T,Q),0===T[3]?null:(E[0]=T[0]/T[3],E[1]=T[1]/T[3],E[2]=T[2]/T[3],E)}constrainWindowSize(v,E,K,ue){const Me=v*this.pixelRatio,Le=E*this.pixelRatio,Fe=Math.max(Me-K/2,0),He=Math.max(this.fullHeight-Le-ue/2,0),Ke=-Math.min(Me-K/2,0),Xe=-Math.min(this.fullHeight-Le-ue/2,0);return[Fe,He,K-Ke- -Math.min(this.fullWidth-Me-K/2,0),ue-Xe- -Math.min(Le-ue/2,0)]}computeUp(v){v===k.JY.Global?this._computeUpGlobal():this._computeUpLocal()}screenToRender(v,E){const ue=this.fullHeight-v[1]*this.pixelRatio;return E[0]=v[0]*this.pixelRatio,E[1]=ue,E}renderToScreen(v,E){const ue=(this.fullHeight-v[1])/this.pixelRatio;E[0]=v[0]/this.pixelRatio,E[1]=ue}_computeUpGlobal(){(0,O.b)(w,this.center,this.eye);const v=(0,O.l)(this.center);v<1?((0,O.s)(this._up,0,0,1),this._markViewDirty(),this.notifyChange("_up")):Math.abs((0,O.e)(w,this.center))>.9999*(0,O.l)(w)*v||((0,O.f)(this._up,w,this.center),(0,O.f)(this._up,this._up,w),(0,O.n)(this._up,this._up),this.notifyChange("_up"),this._markViewDirty())}_computeUpLocal(){(0,O.r)(w,this.eye,this.center),Math.abs(w[2])<=.9999&&((0,O.g)(w,w,w[2]),(0,O.s)(this._up,-w[0],-w[1],1-w[2]),(0,O.n)(this._up,this._up),this.notifyChange("_up"),this._markViewDirty())}_compareAndSetView(v,E,K=""){"number"==typeof v[0]&&isFinite(v[0])&&"number"==typeof v[1]&&isFinite(v[1])&&"number"==typeof v[2]&&isFinite(v[2])?(0,O.k)(v,E)||((0,O.c)(E,v),this._markViewDirty(),K.length&&this.notifyChange(K)):g.Z.getLogger("esri.views.3d.webgl-engine.lib.Camera").warn("Camera vector contains invalid number, ignoring value")}_markViewDirty(){this._viewDirty=!0,this._frustumDirty=!0,this._viewProjectionDirty=!0}_recomputeFrustum(){this._frustumDirty&&((0,F.q_)(this.viewMatrix,this.projectionMatrix,this._frustum),this._frustumDirty=!1)}_ensureViewClean(){this._viewDirty&&((0,W.u)(this._viewMatrix,this.eye,this.center,this.up),(0,O.s)(this._viewForward,-this._viewMatrix[2],-this._viewMatrix[6],-this._viewMatrix[10]),(0,O.s)(this._viewUp,this._viewMatrix[1],this._viewMatrix[5],this._viewMatrix[9]),(0,O.s)(this._viewRight,this._viewMatrix[0],this._viewMatrix[4],this._viewMatrix[8]),this._viewDirty=!1,this._viewInverseTransposeMatrixDirty=!0)}};(0,m._)([(0,M.Cb)()],P.prototype,"_center",void 0),(0,m._)([(0,M.Cb)()],P.prototype,"_up",void 0),(0,m._)([(0,M.Cb)()],P.prototype,"_viewport",void 0),(0,m._)([(0,M.Cb)()],P.prototype,"_padding",void 0),(0,m._)([(0,M.Cb)()],P.prototype,"_fov",void 0),(0,m._)([(0,M.Cb)()],P.prototype,"_nearFar",void 0),(0,m._)([(0,M.Cb)()],P.prototype,"_pixelRatio",void 0),(0,m._)([(0,M.Cb)()],P.prototype,"pixelRatio",null),(0,m._)([(0,M.Cb)()],P.prototype,"eye",null),(0,m._)([(0,M.Cb)()],P.prototype,"center",null),(0,m._)([(0,M.Cb)()],P.prototype,"up",null),(0,m._)([(0,M.Cb)({readOnly:!0})],P.prototype,"nearFar",null),(0,m._)([(0,M.Cb)()],P.prototype,"near",null),(0,m._)([(0,M.Cb)()],P.prototype,"far",null),(0,m._)([(0,M.Cb)()],P.prototype,"viewport",null),(0,m._)([(0,M.Cb)({readOnly:!0})],P.prototype,"screenViewport",null),(0,m._)([(0,M.Cb)()],P.prototype,"x",null),(0,m._)([(0,M.Cb)()],P.prototype,"y",null),(0,m._)([(0,M.Cb)()],P.prototype,"width",null),(0,m._)([(0,M.Cb)()],P.prototype,"height",null),(0,m._)([(0,M.Cb)()],P.prototype,"fullWidth",null),(0,m._)([(0,M.Cb)()],P.prototype,"fullHeight",null),(0,m._)([(0,M.Cb)({readOnly:!0})],P.prototype,"_aspect",null),(0,m._)([(0,M.Cb)()],P.prototype,"padding",null),(0,m._)([(0,M.Cb)({readOnly:!0})],P.prototype,"projectionMatrix",null),(0,m._)([(0,M.Cb)({readOnly:!0})],P.prototype,"inverseProjectionMatrix",null),(0,m._)([(0,M.Cb)()],P.prototype,"fov",null),(0,m._)([(0,M.Cb)()],P.prototype,"fovX",null),(0,m._)([(0,M.Cb)()],P.prototype,"fovY",null),P=Y=(0,m._)([(0,H.j)("esri.views.3d.webgl-engine.lib.Camera")],P);const T=(0,ye.c)(),Q=(0,x.c)(),w=(0,U.c)(),C=(0,U.c)(),J=(0,q.J$)();var ie,v;(v=ie||(ie={}))[v.TOP=0]="TOP",v[v.RIGHT=1]="RIGHT",v[v.BOTTOM=2]="BOTTOM",v[v.LEFT=3]="LEFT"},6040:(Ve,Ee,a)=>{a.d(Ee,{QZ:()=>g,Rq:()=>b,bg:()=>_});var m=a(55713);function _(q,M=!1){return q<=m.DB?M?new Array(q).fill(0):new Array(q):new Float64Array(q)}function g(q){return length<=m.DB?Array.from(q):new Float64Array(q)}function b(q,M,c){return Array.isArray(q)?q.slice(M,M+c):q.subarray(M,M+c)}},25833:(Ve,Ee,a)=>{a.d(Ee,{AA:()=>b,XO:()=>g,xx:()=>_});var m=a(55713);function _(q,M=!1){return q<=m.DB?M?new Array(q).fill(0):new Array(q):new Float32Array(q)}function g(q){return length<=m.DB?Array.from(q):new Float32Array(q)}function b(q,M,c){return Array.isArray(q)?q.slice(M,M+c):q.subarray(M,M+c)}},32393:(Ve,Ee,a)=>{a.d(Ee,{p:()=>g});var m=a(62208),_=a(42743);class g{constructor(q,M){this._material=q,this._repository=M,this._map=new Map}destroy(){this._map.forEach((q,M)=>{(0,m.pC)(q)&&this._repository.release(this._material,M)})}load(q,M,c){if(!this._material.requiresSlot(M,c))return null;this._map.has(c)||this._map.set(c,this._repository.acquire(this._material,M,c));const V=this._map.get(c);if((0,m.pC)(V)){if(V.ensureResources(q)===_.Rw.LOADED)return V;this._repository.requestRender()}return null}}},57521:(Ve,Ee,a)=>{a.d(Ee,{Cr:()=>Et,IG:()=>I,QL:()=>qe,nb:()=>vt,B2:()=>T,DA:()=>At,x2:()=>it,dV:()=>Ye,mj:()=>Ge,rh:()=>yt,PI:()=>Xe,AW:()=>Ke,PD:()=>Dt,Ay:()=>Qe,mx:()=>Ot});var V,re,m=a(62208),_=a(84161),g=a(14658),b=a(28093),q=a(90014),M=a(70562),c=a(94255);(re=V||(V={})).length=function ne(ae,ge){const xe=ae[ge],Oe=ae[ge+1],de=ae[ge+2];return Math.sqrt(xe*xe+Oe*Oe+de*de)},re.normalize=function ve(ae,ge){const xe=ae[ge],Oe=ae[ge+1],de=ae[ge+2],me=1/Math.sqrt(xe*xe+Oe*Oe+de*de);ae[ge]*=me,ae[ge+1]*=me,ae[ge+2]*=me},re.scale=function Z(ae,ge,xe){ae[ge]*=xe,ae[ge+1]*=xe,ae[ge+2]*=xe},re.add=function j(ae,ge,xe,Oe,de,me=ge){(de=de||ae)[me]=ae[ge]+xe[Oe],de[me+1]=ae[ge+1]+xe[Oe+1],de[me+2]=ae[ge+2]+xe[Oe+2]},re.subtract=function he(ae,ge,xe,Oe,de,me=ge){(de=de||ae)[me]=ae[ge]-xe[Oe],de[me+1]=ae[ge+1]-xe[Oe+1],de[me+2]=ae[ge+2]-xe[Oe+2]};var H=a(24425),W=a(6040),x=a(25833),$=a(44968),X=a(37187),O=a(2282),U=a(16396);const ce=V,ye=[[-.5,-.5,.5],[.5,-.5,.5],[.5,.5,.5],[-.5,.5,.5],[-.5,-.5,-.5],[.5,-.5,-.5],[.5,.5,-.5],[-.5,.5,-.5]],F=[0,0,1,-1,0,0,1,0,0,0,-1,0,0,1,0,0,0,-1],se=[0,0,1,0,1,1,0,1],te=[0,1,2,2,3,0,4,0,3,3,7,4,1,5,6,6,2,1,1,0,4,4,5,1,3,2,6,6,7,3,5,4,7,7,6,5],k=new Array(36);for(let re=0;re<6;re++)for(let ne=0;ne<6;ne++)k[6*re+ne]=re;const y=new Array(36);for(let re=0;re<6;re++)y[6*re+0]=0,y[6*re+1]=1,y[6*re+2]=2,y[6*re+3]=2,y[6*re+4]=3,y[6*re+5]=0;function I(re,ne){Array.isArray(ne)||(ne=[ne,ne,ne]);const ve=new Array(24);for(let Z=0;Z<8;Z++)ve[3*Z]=ye[Z][0]*ne[0],ve[3*Z+1]=ye[Z][1]*ne[1],ve[3*Z+2]=ye[Z][2]*ne[2];return new $.Z(re,[[U.T.POSITION,new c.a(ve,3,!0)],[U.T.NORMAL,new c.a(F,3)],[U.T.UV0,new c.a(se,2)]],[[U.T.POSITION,te],[U.T.NORMAL,k],[U.T.UV0,y]])}const B=[[-.5,0,-.5],[.5,0,-.5],[.5,0,.5],[-.5,0,.5],[0,-.5,0],[0,.5,0]],L=[0,1,-1,1,1,0,0,1,1,-1,1,0,0,-1,-1,1,-1,0,0,-1,1,-1,-1,0],Y=[5,1,0,5,2,1,5,3,2,5,0,3,4,0,1,4,1,2,4,2,3,4,3,0],P=[0,0,0,1,1,1,2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,7,7];function T(re,ne){Array.isArray(ne)||(ne=[ne,ne,ne]);const ve=new Array(18);for(let Z=0;Z<6;Z++)ve[3*Z]=B[Z][0]*ne[0],ve[3*Z+1]=B[Z][1]*ne[1],ve[3*Z+2]=B[Z][2]*ne[2];return new $.Z(re,[[U.T.POSITION,new c.a(ve,3,!0)],[U.T.NORMAL,new c.a(L,3)]],[[U.T.POSITION,Y],[U.T.NORMAL,P]])}const Q=(0,g.f)(-.5,0,-.5),w=(0,g.f)(.5,0,-.5),C=(0,g.f)(0,0,.5),J=(0,g.f)(0,.5,0),ie=(0,g.c)(),v=(0,g.c)(),E=(0,g.c)(),K=(0,g.c)(),ue=(0,g.c)();(0,_.b)(ie,Q,J),(0,_.b)(v,Q,w),(0,_.f)(E,ie,v),(0,_.n)(E,E),(0,_.b)(ie,w,J),(0,_.b)(v,w,C),(0,_.f)(K,ie,v),(0,_.n)(K,K),(0,_.b)(ie,C,J),(0,_.b)(v,C,Q),(0,_.f)(ue,ie,v),(0,_.n)(ue,ue);const Me=[Q,w,C,J],Le=[0,-1,0,E[0],E[1],E[2],K[0],K[1],K[2],ue[0],ue[1],ue[2]],Fe=[0,1,2,3,1,0,3,2,1,3,0,2],He=[0,0,0,1,1,1,2,2,2,3,3,3];function Ke(re,ne){Array.isArray(ne)||(ne=[ne,ne,ne]);const ve=new Array(12);for(let Z=0;Z<4;Z++)ve[3*Z]=Me[Z][0]*ne[0],ve[3*Z+1]=Me[Z][1]*ne[1],ve[3*Z+2]=Me[Z][2]*ne[2];return new $.Z(re,[[U.T.POSITION,new c.a(ve,3,!0)],[U.T.NORMAL,new c.a(Le,3)]],[[U.T.POSITION,Fe],[U.T.NORMAL,He]])}function Xe(re,ne,ve,Z,j={uv:!0}){const he=-Math.PI,ae=2*Math.PI,ge=-Math.PI/2,xe=Math.PI,Oe=Math.max(3,Math.floor(ve)),de=Math.max(2,Math.floor(Z)),me=(Oe+1)*(de+1),oe=(0,x.xx)(3*me),be=(0,x.xx)(3*me),je=(0,x.xx)(2*me),Te=[];let ee=0;for(let Se=0;Se<=de;Se++){const Ae=[],De=Se/de,Ue=ge+De*xe,Re=Math.cos(Ue);for(let Ie=0;Ie<=Oe;Ie++){const rt=Ie/Oe,Pe=he+rt*ae,Je=Math.cos(Pe)*Re,ut=Math.sin(Ue),ot=-Math.sin(Pe)*Re;oe[3*ee]=Je*ne,oe[3*ee+1]=ut*ne,oe[3*ee+2]=ot*ne,be[3*ee]=Je,be[3*ee+1]=ut,be[3*ee+2]=ot,je[2*ee]=rt,je[2*ee+1]=De,Ae.push(ee),++ee}Te.push(Ae)}const fe=new Array;for(let Se=0;Se<de;Se++)for(let Ae=0;Ae<Oe;Ae++){const De=Te[Se][Ae],Ue=Te[Se][Ae+1],Re=Te[Se+1][Ae+1],Ie=Te[Se+1][Ae];0===Se?(fe.push(De),fe.push(Re),fe.push(Ie)):Se===de-1?(fe.push(De),fe.push(Ue),fe.push(Re)):(fe.push(De),fe.push(Ue),fe.push(Re),fe.push(Re),fe.push(Ie),fe.push(De))}const le=[[U.T.POSITION,fe],[U.T.NORMAL,fe]],pe=[[U.T.POSITION,new c.a(oe,3,!0)],[U.T.NORMAL,new c.a(be,3,!0)]];return j.uv&&(pe.push([U.T.UV0,new c.a(je,2,!0)]),le.push([U.T.UV0,fe])),j.offset&&(le[0][0]=U.T.OFFSET,pe[0][0]=U.T.OFFSET,le.push([U.T.POSITION,new Array(fe.length).fill(0)]),pe.push([U.T.POSITION,new c.a(Float64Array.from(j.offset),3,!0)])),new $.Z(re,pe,le)}function Ge(re,ne,ve,Z){const{vertexAttributes:j,indices:he}=function tt(re,ne,ve){const Z=re;let j,he;if(ve)j=[0,-1,0,1,0,0,0,0,1,-1,0,0,0,0,-1,0,1,0],he=[0,1,2,0,2,3,0,3,4,0,4,1,1,5,2,2,5,3,3,5,4,4,5,1];else{const de=Z*(1+Math.sqrt(5))/2;j=[-Z,de,0,Z,de,0,-Z,-de,0,Z,-de,0,0,-Z,de,0,Z,de,0,-Z,-de,0,Z,-de,de,0,-Z,de,0,Z,-de,0,-Z,-de,0,Z],he=[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1]}for(let de=0;de<j.length;de+=3)ce.scale(j,de,re/ce.length(j,de));let ae={};function ge(de,me){de>me&&([de,me]=[me,de]);const oe=de.toString()+"."+me.toString();if(ae[oe])return ae[oe];let be=j.length;return j.length+=3,ce.add(j,3*de,j,3*me,j,be),ce.scale(j,be,re/ce.length(j,be)),be/=3,ae[oe]=be,be}for(let de=0;de<ne;de++){const me=he.length,oe=new Array(4*me);for(let be=0;be<me;be+=3){const je=he[be],Te=he[be+1],ee=he[be+2],fe=ge(je,Te),le=ge(Te,ee),pe=ge(ee,je),Se=4*be;oe[Se]=je,oe[Se+1]=fe,oe[Se+2]=pe,oe[Se+3]=Te,oe[Se+4]=le,oe[Se+5]=fe,oe[Se+6]=ee,oe[Se+7]=pe,oe[Se+8]=le,oe[Se+9]=fe,oe[Se+10]=le,oe[Se+11]=pe}he=oe,ae={}}const xe=(0,x.XO)(j);for(let de=0;de<xe.length;de+=3)ce.normalize(xe,de);const Oe=[[U.T.POSITION,he],[U.T.NORMAL,he]];return{vertexAttributes:[[U.T.POSITION,new c.a((0,x.XO)(j),3,!0)],[U.T.NORMAL,new c.a(xe,3,!0)]],indices:Oe}}(ne,ve,Z);return new $.Z(re,j,he)}function Ye(re,ne,ve,Z,j,he,ae,ge,xe=null){const Oe=ve?[ve[0],ve[1],ve[2]]:[0,0,0],de=ne?[ne[0],ne[1],ne[2]]:[0,0,1];ae=ae||[0,0];const me=Z?[255*Z[0],255*Z[1],255*Z[2],Z.length>3?255*Z[3]:255]:[255,255,255,255],oe=(0,m.pC)(j)&&2===j.length?j:[1,1],be=[[U.T.POSITION,new c.a(Oe,3,!0)],[U.T.NORMAL,new c.a(de,3,!0)],[U.T.UV0,new c.a(ae,ae.length)],[U.T.COLOR,new c.a(me,4,!0)],[U.T.SIZE,new c.a(oe,2)]];return null!=he&&be.push([U.T.AUXPOS1,new c.a([he[0],he[1],he[2],he[3]],4)]),null!=ge&&be.push([U.T.AUXPOS2,new c.a([ge[0],ge[1],ge[2],ge[3]],4)]),new $.Z(re,be,null,null,H.U.Point,xe)}function qe(re,ne,ve,Z,j,he=!0,ae=!0){let ge=0;const xe=ve,Oe=ne;let de=(0,g.f)(0,ge,0),me=(0,g.f)(0,ge+Oe,0),oe=(0,g.f)(0,-1,0),be=(0,g.f)(0,1,0);j&&(ge=Oe,me=(0,g.f)(0,0,0),de=(0,g.f)(0,ge,0),oe=(0,g.f)(0,1,0),be=(0,g.f)(0,-1,0));const je=[me,de],Te=[oe,be],ee=Z+2,fe=Math.sqrt(Oe*Oe+xe*xe);if(j)for(let Re=Z-1;Re>=0;Re--){const Ie=Re*(2*Math.PI/Z),rt=(0,g.f)(Math.cos(Ie)*xe,ge,Math.sin(Ie)*xe);je.push(rt);const Pe=(0,g.f)(Oe*Math.cos(Ie)/fe,-xe/fe,Oe*Math.sin(Ie)/fe);Te.push(Pe)}else for(let Re=0;Re<Z;Re++){const Ie=Re*(2*Math.PI/Z),rt=(0,g.f)(Math.cos(Ie)*xe,ge,Math.sin(Ie)*xe);je.push(rt);const Pe=(0,g.f)(Oe*Math.cos(Ie)/fe,xe/fe,Oe*Math.sin(Ie)/fe);Te.push(Pe)}const le=new Array,pe=new Array;if(he){for(let Re=3;Re<je.length;Re++)le.push(1),le.push(Re-1),le.push(Re),pe.push(0),pe.push(0),pe.push(0);le.push(je.length-1),le.push(2),le.push(1),pe.push(0),pe.push(0),pe.push(0)}if(ae){for(let Re=3;Re<je.length;Re++)le.push(Re),le.push(Re-1),le.push(0),pe.push(Re),pe.push(Re-1),pe.push(1);le.push(0),le.push(2),le.push(je.length-1),pe.push(1),pe.push(2),pe.push(Te.length-1)}const Se=(0,x.xx)(3*ee);for(let Re=0;Re<ee;Re++)Se[3*Re]=je[Re][0],Se[3*Re+1]=je[Re][1],Se[3*Re+2]=je[Re][2];const Ae=(0,x.xx)(3*ee);for(let Re=0;Re<ee;Re++)Ae[3*Re]=Te[Re][0],Ae[3*Re+1]=Te[Re][1],Ae[3*Re+2]=Te[Re][2];const De=[[U.T.POSITION,le],[U.T.NORMAL,pe]],Ue=[[U.T.POSITION,new c.a(Se,3,!0)],[U.T.NORMAL,new c.a(Ae,3,!0)]];return new $.Z(re,Ue,De)}function vt(re,ne,ve,Z,j,he,ae){const ge=j?(0,g.b)(j):(0,g.f)(1,0,0),xe=he?(0,g.b)(he):(0,g.f)(0,0,0);ae=ae??!0;const Oe=(0,g.c)();(0,_.n)(Oe,ge);const de=(0,g.c)();(0,_.g)(de,Oe,Math.abs(ne));const me=(0,g.c)();(0,_.g)(me,de,-.5),(0,_.a)(me,me,xe);const oe=(0,g.f)(0,1,0);Math.abs(1-(0,_.e)(Oe,oe))<.2&&(0,_.s)(oe,0,0,1);const be=(0,g.c)();(0,_.f)(be,Oe,oe),(0,_.n)(be,be),(0,_.f)(oe,be,Oe);const je=2*Z+(ae?2:0),Te=Z+(ae?2:0),ee=(0,x.xx)(3*je),fe=(0,x.xx)(3*Te),le=(0,x.xx)(2*je),pe=new Array(3*Z*(ae?4:2)),Se=new Array(3*Z*(ae?4:2));ae&&(ee[3*(je-2)+0]=me[0],ee[3*(je-2)+1]=me[1],ee[3*(je-2)+2]=me[2],le[2*(je-2)]=0,le[2*(je-2)+1]=0,ee[3*(je-1)+0]=ee[3*(je-2)+0]+de[0],ee[3*(je-1)+1]=ee[3*(je-2)+1]+de[1],ee[3*(je-1)+2]=ee[3*(je-2)+2]+de[2],le[2*(je-1)]=1,le[2*(je-1)+1]=1,fe[3*(Te-2)+0]=-Oe[0],fe[3*(Te-2)+1]=-Oe[1],fe[3*(Te-2)+2]=-Oe[2],fe[3*(Te-1)+0]=Oe[0],fe[3*(Te-1)+1]=Oe[1],fe[3*(Te-1)+2]=Oe[2]);const Ae=(Pe,Je,ut)=>{pe[Pe]=Je,Se[Pe]=ut};let De=0;const Ue=(0,g.c)(),Re=(0,g.c)();for(let Pe=0;Pe<Z;Pe++){const Je=Pe*(2*Math.PI/Z);(0,_.g)(Ue,oe,Math.sin(Je)),(0,_.g)(Re,be,Math.cos(Je)),(0,_.a)(Ue,Ue,Re),fe[3*Pe+0]=Ue[0],fe[3*Pe+1]=Ue[1],fe[3*Pe+2]=Ue[2],(0,_.g)(Ue,Ue,ve),(0,_.a)(Ue,Ue,me),ee[3*Pe+0]=Ue[0],ee[3*Pe+1]=Ue[1],ee[3*Pe+2]=Ue[2],le[2*Pe+0]=Pe/Z,le[2*Pe+1]=0,ee[3*(Pe+Z)+0]=ee[3*Pe+0]+de[0],ee[3*(Pe+Z)+1]=ee[3*Pe+1]+de[1],ee[3*(Pe+Z)+2]=ee[3*Pe+2]+de[2],le[2*(Pe+Z)+0]=Pe/Z,le[2*Pe+1]=1;const ut=(Pe+1)%Z;Ae(De++,Pe,Pe),Ae(De++,Pe+Z,Pe),Ae(De++,ut,ut),Ae(De++,ut,ut),Ae(De++,Pe+Z,Pe),Ae(De++,ut+Z,ut)}if(ae){for(let Pe=0;Pe<Z;Pe++){const Je=(Pe+1)%Z;Ae(De++,je-2,Te-2),Ae(De++,Pe,Te-2),Ae(De++,Je,Te-2)}for(let Pe=0;Pe<Z;Pe++){const Je=(Pe+1)%Z;Ae(De++,Pe+Z,Te-1),Ae(De++,je-1,Te-1),Ae(De++,Je+Z,Te-1)}}const Ie=[[U.T.POSITION,pe],[U.T.NORMAL,Se],[U.T.UV0,pe]],rt=[[U.T.POSITION,new c.a(ee,3,!0)],[U.T.NORMAL,new c.a(fe,3,!0)],[U.T.UV0,new c.a(le,2,!0)]];return new $.Z(re,rt,Ie)}function Dt(re,ne,ve,Z,j,he){Z=Z||10,j=null==j||j,(0,O.hu)(ne.length>1);const ge=[],xe=[];for(let Oe=0;Oe<Z;Oe++){ge.push([0,-Oe-1,-(Oe+1)%Z-1]);const de=Oe/Z*2*Math.PI;xe.push([Math.cos(de)*ve,Math.sin(de)*ve])}return it(re,xe,ne,[[0,0,0]],ge,j,he)}function it(re,ne,ve,Z,j,he,ae=(0,g.f)(0,0,0)){const ge=ne.length,xe=(0,x.xx)(ve.length*ge*3+(6*Z.length||0)),Oe=(0,x.xx)(ve.length*ge*3+(Z?6:0)),de=new Array,me=new Array;let oe=0,be=0;const je=(0,g.c)(),Te=(0,g.c)(),ee=(0,g.c)(),fe=(0,g.c)(),le=(0,g.c)(),pe=(0,g.c)(),Se=(0,g.c)(),Ae=(0,b.c)(),De=(0,g.c)(),Ue=(0,g.c)(),Re=(0,g.c)(),Ie=(0,g.c)(),rt=(0,g.c)(),Pe=(0,q.Ue)();(0,_.s)(De,0,1,0),(0,_.b)(Te,ve[1],ve[0]),(0,_.n)(Te,Te),he?((0,_.a)(Ae,ve[0],ae),(0,_.n)(ee,Ae)):(0,_.s)(ee,0,0,1),Qe(Te,ee,De,De,le,ee,G),(0,_.c)(fe,ee),(0,_.c)(Ie,le);for(let Ne=0;Ne<Z.length;Ne++)(0,_.g)(pe,le,Z[Ne][0]),(0,_.g)(Ae,ee,Z[Ne][2]),(0,_.a)(pe,pe,Ae),(0,_.a)(pe,pe,ve[0]),xe[oe++]=pe[0],xe[oe++]=pe[1],xe[oe++]=pe[2];Oe[be++]=-Te[0],Oe[be++]=-Te[1],Oe[be++]=-Te[2];for(let Ne=0;Ne<j.length;Ne++)de.push(j[Ne][0]>0?j[Ne][0]:-j[Ne][0]-1+Z.length),de.push(j[Ne][1]>0?j[Ne][1]:-j[Ne][1]-1+Z.length),de.push(j[Ne][2]>0?j[Ne][2]:-j[Ne][2]-1+Z.length),me.push(0),me.push(0),me.push(0);let Je=Z.length;const ut=Z.length-1;for(let Ne=0;Ne<ve.length;Ne++){let lt=!1;Ne>0&&((0,_.c)(je,Te),Ne<ve.length-1?((0,_.b)(Te,ve[Ne+1],ve[Ne]),(0,_.n)(Te,Te)):lt=!0,(0,_.a)(Ue,je,Te),(0,_.n)(Ue,Ue),(0,_.a)(Re,ve[Ne-1],fe),(0,q.Yq)(ve[Ne],Ue,Pe),(0,q.BR)(Pe,(0,M.re)(Re,je),Ae)?((0,_.b)(Ae,Ae,ve[Ne]),(0,_.n)(ee,Ae),(0,_.f)(le,Ue,ee),(0,_.n)(le,le)):Qe(Ue,fe,Ie,De,le,ee,G),(0,_.c)(fe,ee),(0,_.c)(Ie,le)),he&&((0,_.a)(Ae,ve[Ne],ae),(0,_.n)(rt,Ae));for(let gt=0;gt<ge;gt++)if((0,_.g)(pe,le,ne[gt][0]),(0,_.g)(Ae,ee,ne[gt][1]),(0,_.a)(pe,pe,Ae),(0,_.n)(Se,pe),Oe[be++]=Se[0],Oe[be++]=Se[1],Oe[be++]=Se[2],(0,_.a)(pe,pe,ve[Ne]),xe[oe++]=pe[0],xe[oe++]=pe[1],xe[oe++]=pe[2],!lt){const mt=(gt+1)%ge;de.push(Je+gt),de.push(Je+ge+gt),de.push(Je+mt),de.push(Je+mt),de.push(Je+ge+gt),de.push(Je+ge+mt);for(let St=0;St<6;St++)me.push(de[de.length-6+St]-ut)}Je+=ge}const ot=ve[ve.length-1];for(let Ne=0;Ne<Z.length;Ne++)(0,_.g)(pe,le,Z[Ne][0]),(0,_.g)(Ae,ee,Z[Ne][1]),(0,_.a)(pe,pe,Ae),(0,_.a)(pe,pe,ot),xe[oe++]=pe[0],xe[oe++]=pe[1],xe[oe++]=pe[2];const Tt=be/3;Oe[be++]=Te[0],Oe[be++]=Te[1],Oe[be++]=Te[2];const ft=Je-ge;for(let Ne=0;Ne<j.length;Ne++)de.push(j[Ne][0]>=0?Je+j[Ne][0]:-j[Ne][0]-1+ft),de.push(j[Ne][2]>=0?Je+j[Ne][2]:-j[Ne][2]-1+ft),de.push(j[Ne][1]>=0?Je+j[Ne][1]:-j[Ne][1]-1+ft),me.push(Tt),me.push(Tt),me.push(Tt);const at=[[U.T.POSITION,de],[U.T.NORMAL,me]],nt=[[U.T.POSITION,new c.a(xe,3,!0)],[U.T.NORMAL,new c.a(Oe,3,!0)]];return new $.Z(re,nt,at)}function yt(re,ne,ve,Z){(0,O.hu)(ne.length>1,"createPolylineGeometry(): polyline needs at least 2 points"),(0,O.hu)(3===ne[0].length,"createPolylineGeometry(): malformed vertex"),(0,O.hu)(null==ve||ve.length===ne.length,"createPolylineGeometry: need same number of points and normals"),(0,O.hu)(null==ve||3===ve[0].length,"createPolylineGeometry(): malformed normal");const j=(0,W.bg)(3*ne.length),he=new Array(2*(ne.length-1));let ae=0,ge=0;for(let de=0;de<ne.length;de++){for(let me=0;me<3;me++)j[ae++]=ne[de][me];de>0&&(he[ge++]=de-1,he[ge++]=de)}const xe=[],Oe=[];if(xe.push([U.T.POSITION,he]),Oe.push([U.T.POSITION,new c.a(j,3,!0)]),ve){const de=(0,x.xx)(3*ve.length);let me=0;for(let oe=0;oe<ne.length;oe++)for(let be=0;be<3;be++)de[me++]=ve[oe][be];xe.push([U.T.NORMAL,he]),Oe.push([U.T.NORMAL,new c.a(de,3,!0)])}return Z&&(Oe.push([U.T.COLOR,new c.a(Z,4)]),xe.push([U.T.COLOR,(0,X.p)(Z.length/4)])),new $.Z(re,Oe,xe,null,H.U.Line)}function At(re,ne,ve,Z,j,he=0){const ae=new Array(18),ge=[[-ve,he,j/2],[Z,he,j/2],[0,ne+he,j/2],[-ve,he,-j/2],[Z,he,-j/2],[0,ne+he,-j/2]];for(let Oe=0;Oe<6;Oe++)ae[3*Oe]=ge[Oe][0],ae[3*Oe+1]=ge[Oe][1],ae[3*Oe+2]=ge[Oe][2];return new $.Z(re,[[U.T.POSITION,new c.a(ae,3,!0)]],[[U.T.POSITION,[0,1,2,3,0,2,2,5,3,1,4,5,5,2,1,1,0,3,3,4,1,4,3,5]]])}function Ot(re,ne){const ve=re.getMutableAttribute(U.T.POSITION).data;for(let Z=0;Z<ve.length;Z+=3)(0,_.s)(_e,ve[Z],ve[Z+1],ve[Z+2]),(0,_.m)(_e,_e,ne),ve[Z]=_e[0],ve[Z+1]=_e[1],ve[Z+2]=_e[2]}function Et(re,ne=re){const ve=re.vertexAttributes,Z=ve.get(U.T.POSITION).data,j=ve.get(U.T.NORMAL).data;if(j){const he=ne.getMutableAttribute(U.T.NORMAL).data;for(let ae=0;ae<j.length;ae+=3){const ge=j[ae+1];he[ae+1]=-j[ae+2],he[ae+2]=ge}}if(Z){const he=ne.getMutableAttribute(U.T.POSITION).data;for(let ae=0;ae<Z.length;ae+=3){const ge=Z[ae+1];he[ae+1]=-Z[ae+2],he[ae+2]=ge}}}function ct(re,ne,ve,Z,j){return!(Math.abs((0,_.e)(ne,re))>j||((0,_.f)(ve,re,ne),(0,_.n)(ve,ve),(0,_.f)(Z,ve,re),(0,_.n)(Z,Z),0))}function Qe(re,ne,ve,Z,j,he,ae){return ct(re,ne,j,he,ae)||ct(re,ve,j,he,ae)||ct(re,Z,j,he,ae)}const G=.99619469809,_e=(0,g.c)()},32042:(Ve,Ee,a)=>{a.d(Ee,{C:()=>ye});var m=a(62208),_=a(86236),g=a(84161),b=a(28093),q=a(4794),M=a(55915),c=a(94255),V=a(24425),H=a(44968),W=a(30993),x=a(97272);var O=a(16396),U=a(34103),ce=a(92222);class ye{constructor(te){this._originSR=te,this._origins=new Map,this._objects=new Map,this._gridSize=5e5,this._rootOriginId="root/"+(0,_.D)()}getOrigin(te){const k=this._origins.get(this._rootOriginId);if(null==k){const Q=null;if((0,m.pC)(Q))return this._origins.set(this._rootOriginId,(0,W.a)(Q[0],Q[1],Q[2],this._rootOriginId)),this.getOrigin(te);const w=(0,W.a)(te[0]+Math.random()-.5,te[1]+Math.random()-.5,te[2]+Math.random()-.5,this._rootOriginId);return this._origins.set(this._rootOriginId,w),w}const y=this._gridSize,I=Math.round(te[0]/y),B=Math.round(te[1]/y),L=Math.round(te[2]/y),Y=`${I}/${B}/${L}`;let P=this._origins.get(Y);const T=.5*y;if((0,g.b)(F,te,k.vec3),F[0]=Math.abs(F[0]),F[1]=Math.abs(F[1]),F[2]=Math.abs(F[2]),F[0]<T&&F[1]<T&&F[2]<T){if(P){const Q=Math.max(...F);if((0,g.b)(F,te,P.vec3),F[0]=Math.abs(F[0]),F[1]=Math.abs(F[1]),F[2]=Math.abs(F[2]),Math.max(...F)<Q)return P}return k}return P||(P=(0,W.a)(I*y,B*y,L*y,Y),this._origins.set(Y,P)),P}_drawOriginBox(te,k=(0,q.f)(1,1,0,1)){const y=window.view,I=y._stage,B=k.toString();if(!this._objects.has(B)){this._material=new ce.U({width:2,color:k}),I.add(this._material);const J=new U.F({pickable:!1}),ie=new x.T({castShadow:!1});I.add(ie),J.add(ie),I.add(J),this._objects.set(B,ie)}const L=this._objects.get(B),Y=[0,1,5,4,0,2,1,7,6,2,0,1,3,7,5,4,6,2,0],P=Y.length,T=new Array(3*P),Q=new Array,w=.5*this._gridSize;for(let J=0;J<P;J++)T[3*J+0]=te[0]+(1&Y[J]?w:-w),T[3*J+1]=te[1]+(2&Y[J]?w:-w),T[3*J+2]=te[2]+(4&Y[J]?w:-w),J>0&&Q.push(J-1,J);(0,M.CM)(T,this._originSR,0,T,y.renderSpatialReference,0,P);const C=new H.Z(this._material,[[O.T.POSITION,new c.a(T,3,!0)]],[[O.T.POSITION,Q]],null,V.U.Line);I.add(C),L.addGeometry(C)}get test(){const te=this;return{set gridSize(k){te._gridSize=k}}}}const F=(0,b.c)()},62483:(Ve,Ee,a)=>{a.d(Ee,{LP:()=>te,Z8:()=>ce});var m=a(62208),_=a(28347),g=a(43703),b=a(84161),q=a(28093),M=a(993),c=a(4794),V=a(70562),H=a(59617),W=a(67857),x=a(9502),$=a(91480),X=a(40841);const O=1e-5;class U{constructor(B){this.options=new W.om,this._results=new ye,this.transform=new X.yn,this.tolerance=O,this.verticalOffset=null,this._ray=(0,V.Ue)(),this._rayEnd=(0,q.c)(),this._rayBeginTransformed=(0,q.c)(),this._rayEndTransformed=(0,q.c)(),this.viewingMode=B??H.JY.Global}get results(){return this._results}get ray(){return this._ray}get rayBegin(){return this._ray.origin}get rayEnd(){return this._rayEnd}reset(B,L,Y){this.resetWithRay((0,V.zk)(B,L,this._ray),Y)}resetWithRay(B,L){this.camera=L,B!==this._ray&&(0,V.JG)(B,this._ray),0!==this.options.verticalOffset?this.viewingMode===H.JY.Local?this._ray.origin[2]-=this.options.verticalOffset:this.verticalOffset=this.options.verticalOffset:this.verticalOffset=null,(0,b.a)(this._rayEnd,this._ray.origin,this._ray.direction),this._results.init(this._ray)}intersect(B=null,L,Y,P,T){this.point=L,this.filterPredicate=P,this.tolerance=Y??O;const Q=(0,X.W9)(this.verticalOffset);if((0,m.pC)(B)&&B.length>0){const w=T?C=>{T(C)&&this.intersectObject(C)}:C=>{this.intersectObject(C)};for(const C of B){const J=C.getSpatialQueryAccelerator&&C.getSpatialQueryAccelerator();(0,m.pC)(J)?((0,m.pC)(Q)?J.forEachAlongRayWithVerticalOffset(this._ray.origin,this._ray.direction,w,Q):J.forEachAlongRay(this._ray.origin,this._ray.direction,w),this.options.selectionMode&&this.options.hud&&J.forEachDegenerateObject(w)):C.objects.forAll(ie=>w(ie))}}this.sortResults()}intersectObject(B){const L=B.geometries;if(!L)return;const Y=B.transformation,P=(0,X.W9)(this.verticalOffset);for(const T of L){if(!T.visible)continue;const{material:Q,id:w}=T;this.transform.setAndInvalidateLazyTransforms(Y,T.shaderTransformation),(0,b.m)(this._rayBeginTransformed,this.rayBegin,this.transform.inverse),(0,b.m)(this._rayEndTransformed,this.rayEnd,this.transform.inverse);const C=this.transform.transform;(0,m.pC)(P)&&(P.objectTransform=this.transform),Q.intersect(T,this.transform.transform,this,this._rayBeginTransformed,this._rayEndTransformed,(J,ie,v,E,K,ue)=>{if(J>=0){if((0,m.pC)(this.filterPredicate)&&!this.filterPredicate(this._ray.origin,this._rayEnd,J))return;const Me=E?this._results.hud:this._results,Le=E?Fe=>{const He=new x.RA(B,w,v,ue);Fe.set(W.q7.HUD,He,J,ie,g.I,K)}:Fe=>Fe.set(W.q7.OBJECT,{object:B,geometryId:w,triangleNr:v},J,ie,C,K);if((null==Me.min.drapedLayerOrder||K>=Me.min.drapedLayerOrder)&&(null==Me.min.dist||J<Me.min.dist)&&Le(Me.min),this.options.store!==W.eC.MIN&&(null==Me.max.drapedLayerOrder||K<Me.max.drapedLayerOrder)&&(null==Me.max.dist||J>Me.max.dist)&&Le(Me.max),this.options.store===W.eC.ALL)if(E){const Fe=new se(this._ray);Le(Fe),this._results.hud.all.push(Fe)}else{const Fe=new F(this._ray);Le(Fe),this._results.all.push(Fe)}}})}}sortResults(B=this._results.all){B.sort((L,Y)=>L.dist!==Y.dist?(0,m.Pt)(L.dist,0)-(0,m.Pt)(Y.dist,0):L.drapedLayerOrder!==Y.drapedLayerOrder?(0,m.Pt)(L.drapedLayerOrder,Number.MAX_VALUE)-(0,m.Pt)(Y.drapedLayerOrder,Number.MAX_VALUE):(0,m.Pt)(Y.drapedLayerGraphicOrder,Number.MIN_VALUE)-(0,m.Pt)(L.drapedLayerGraphicOrder,Number.MIN_VALUE))}}function ce(I){return new U(I)}class ye{constructor(){this.min=new F((0,V.Ue)()),this.max=new F((0,V.Ue)()),this.hud={min:new se((0,V.Ue)()),max:new se((0,V.Ue)()),all:new Array},this.ground=new F((0,V.Ue)()),this.all=[]}init(B){this.min.init(B),this.max.init(B),this.ground.init(B),this.all.length=0,this.hud.min.init(B),this.hud.max.init(B),this.hud.all.length=0}}class F{get ray(){return this._ray}get distanceInRenderSpace(){return(0,m.pC)(this.dist)?((0,b.g)(k,this.ray.direction,this.dist),(0,b.l)(k)):null}getIntersectionPoint(B){return!!(0,$.nn)(this)&&((0,b.g)(k,this.ray.direction,this.dist),(0,b.a)(B,this.ray.origin,k),!0)}getTransformedNormal(B){return(0,b.c)(y,this.normal),y[3]=0,(0,M.t)(y,y,this.transformation),(0,b.c)(B,y),(0,b.n)(B,B)}constructor(B){this.intersector=W.q7.OBJECT,this.normal=(0,q.c)(),this.transformation=(0,g.c)(),this._ray=(0,V.Ue)(),this.init(B)}init(B){this.dist=null,this.target=null,this.drapedLayerOrder=null,this.drapedLayerGraphicOrder=null,this.intersector=W.q7.OBJECT,(0,V.JG)(B,this._ray)}set(B,L,Y,P,T,Q,w){this.intersector=B,this.dist=Y,(0,b.c)(this.normal,(0,m.Pt)(P,q.U)),(0,_.c)(this.transformation,(0,m.Pt)(T,g.I)),this.target=L,this.drapedLayerOrder=Q,this.drapedLayerGraphicOrder=w}copy(B){(0,V.JG)(B.ray,this._ray),this.intersector=B.intersector,this.dist=B.dist,this.target=B.target,this.drapedLayerOrder=B.drapedLayerOrder,this.drapedLayerGraphicOrder=B.drapedLayerGraphicOrder,(0,b.c)(this.normal,B.normal),(0,_.c)(this.transformation,B.transformation)}}class se extends F{constructor(){super(...arguments),this.intersector=W.q7.HUD}}function te(I){return new F(I)}const k=(0,q.c)(),y=(0,c.c)()},67857:(Ve,Ee,a)=>{var m,_,b;a.d(Ee,{eC:()=>_,om:()=>g,q7:()=>m}),(b=m||(m={}))[b.OBJECT=0]="OBJECT",b[b.HUD=1]="HUD",b[b.TERRAIN=2]="TERRAIN",b[b.OVERLAY=3]="OVERLAY",b[b.I3S=4]="I3S",b[b.PCL=5]="PCL",b[b.LOD=6]="LOD",b[b.VOXEL=7]="VOXEL";class g{constructor(){this.verticalOffset=0,this.selectionMode=!1,this.hud=!0,this.selectOpaqueTerrainOnly=!0,this.invisibleTerrain=!1,this.backfacesTerrain=!0,this.isFiltered=!1,this.filteredLayerUids=[],this.store=_.ALL}}!function(b){b[b.MIN=0]="MIN",b[b.MINMAX=1]="MINMAX",b[b.ALL=2]="ALL"}(_||(_={}))},9502:(Ve,Ee,a)=>{a.d(Ee,{Dx:()=>c,RA:()=>b});var m=a(62208),_=a(28093);class g{constructor(H,W,x){this.object=H,this.geometryId=W,this.triangleNr=x}}class b extends g{constructor(H,W,x,$){super(H,W,x),this.center=(0,m.pC)($)?(0,_.a)($):null}}class M{constructor(H){this.layerUid=H}}class c extends M{constructor(H,W){super(H),this.graphicUid=W}}},30993:(Ve,Ee,a)=>{a.d(Ee,{a:()=>g});var m=a(28093);class _{constructor(q,M){this.vec3=q,this.id=M}}function g(b,q,M,c){return new _((0,m.f)(b,q,M),c)}},54840:(Ve,Ee,a)=>{var m,_,g;a.d(Ee,{$:()=>_,T:()=>m}),(g=m||(m={}))[g.ADD=0]="ADD",g[g.UPDATE=1]="UPDATE",g[g.REMOVE=2]="REMOVE",function(g){g[g.NONE=0]="NONE",g[g.VISIBILITY=1]="VISIBILITY",g[g.GEOMETRY=2]="GEOMETRY",g[g.TRANSFORMATION=4]="TRANSFORMATION",g[g.HIGHLIGHT=8]="HIGHLIGHT",g[g.OCCLUDEE=16]="OCCLUDEE"}(_||(_={}))},97272:(Ve,Ee,a)=>{a.d(Ee,{T:()=>O});var m=a(62208),_=a(28347),g=a(43703),b=a(84161),q=a(28093),M=a(97126),c=a(98943),V=a(42743),H=a(12699),W=a(24425),x=a(7167),$=a(2282),X=a(65073);class O extends H.c{get geometries(){return this._geometries}get transformation(){return this._transformation}set transformation(y){(0,_.c)(this._transformation,y),this._invalidateBoundingVolume(),this._emit("objectTransformation",this)}constructor(y={}){super(),this.type=W.U.Object,this._geometries=new Array,this._transformation=(0,g.c)(),this._bvObjectSpace=new ce,this._bvWorldSpace=new ce,this._bvDirty=!0,this._hasVolatileTransformation=!1,this._visible=!0,this.castShadow=null==y.castShadow||y.castShadow,this.metadata=y.metadata,this.metadata&&this.metadata.isElevationSource&&(this.metadata.lastValidElevationBB=new U);const I=y.geometries;(0,m.pC)(I)&&(this._geometries=Array.from(I))}dispose(){this._geometries.length=0}get parentLayer(){return this._parentLayer}set parentLayer(y){(0,$.hu)(null==this._parentLayer||null==y,"Object3D can only be added to a single Layer"),this._parentLayer=y}addGeometry(y){y.visible=this._visible,this._geometries.push(y),this._hasVolatileTransformation=this._hasVolatileTransformation||y.hasVolatileTransformation,this._emit("objectGeometryAdded",{object:this,geometry:y}),this._invalidateBoundingVolume()}removeGeometry(y){const I=this._geometries.splice(y,1)[0];I&&(this._emit("objectGeometryRemoved",{object:this,geometry:I}),this._invalidateBoundingVolume())}removeAllGeometries(){for(;this._geometries.length>0;)this.removeGeometry(0)}geometryVertexAttrsUpdated(y){this._emit("objectGeometryUpdated",{object:this,geometry:y}),this._invalidateBoundingVolume()}get visible(){return this._visible}set visible(y){if(this._visible!==y){this._visible=y;for(const I of this._geometries)I.visible=this._visible;this._emit("visibilityChanged",this)}}maskOccludee(){const y=new x.O(V.V_.MaskOccludee);for(const I of this._geometries)I.occludees=(0,X.lr)(I.occludees,y);return this._emit("occlusionChanged",this),y}removeOcclude(y){for(const I of this._geometries)I.occludees=(0,X.U_)(I.occludees,y);this._emit("occlusionChanged",this)}highlight(){const y=new x.O(V.V_.Highlight);for(const I of this._geometries)I.highlights=(0,X.lr)(I.highlights,y);return this._emit("highlightChanged",this),y}removeHighlight(y){for(const I of this._geometries)I.highlights=(0,X.U_)(I.highlights,y);this._emit("highlightChanged",this)}getCombinedStaticTransformation(y,I){return(0,_.m)(I,this.transformation,y.transformation)}_getCombinedShaderTransformation(y){return(0,_.m)((0,g.c)(),this.transformation,y.shaderTransformation)}hasVolativeTransformation(){return this._hasVolatileTransformation}get boundingVolumeWorldSpace(){return this._validateBoundingVolume(),this._bvWorldSpace}get boundingVolumeObjectSpace(){return this._validateBoundingVolume(),this._bvObjectSpace}_validateBoundingVolume(){if(!this._bvDirty&&!this._hasVolatileTransformation)return;this._bvObjectSpace.init(),this._bvWorldSpace.init();for(const L of this._geometries){const Y=L.boundingInfo;(0,m.pC)(Y)&&(ye(Y,this._bvObjectSpace,L.shaderTransformation),ye(Y,this._bvWorldSpace,this._getCombinedShaderTransformation(L)))}(0,b.h)(this._bvObjectSpace.bounds,this._bvObjectSpace.min,this._bvObjectSpace.max,.5),(0,b.h)(this._bvWorldSpace.bounds,this._bvWorldSpace.min,this._bvWorldSpace.max,.5);const y=(0,q.c)(),I=(0,q.c)(),B=(0,c.u1)(this.transformation);for(const L of this._geometries){const Y=L.boundingInfo;if((0,m.Wi)(Y))continue;const P=L.shaderTransformation,T=(0,c.u1)(P);(0,b.m)(y,Y.center,P);const Q=(0,b.i)(y,this._bvObjectSpace.bounds),w=Y.radius*T;this._bvObjectSpace.bounds[3]=Math.max(this._bvObjectSpace.bounds[3],Q+w),(0,b.m)(I,y,this.transformation);const C=(0,b.i)(I,this._bvWorldSpace.bounds);this._bvWorldSpace.bounds[3]=Math.max(this._bvWorldSpace.bounds[3],C+w*B)}this._bvDirty=!1}_invalidateBoundingVolume(){this._bvDirty=!0,(0,m.pC)(this._parentLayer)&&this._parentLayer.notifyObjectBBChanged(this,this._bvWorldSpace.bounds)}_emit(y,I){(0,m.pC)(this._parentLayer)&&this._parentLayer.events.emit(y,I)}get test(){const y=this;return{hasGeometry:I=>y._geometries.includes(I),getGeometryIndex:I=>y._geometries.indexOf(I)}}}class U{constructor(){this.min=(0,q.f)(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),this.max=(0,q.f)(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE)}isEmpty(){return this.max[0]<this.min[0]&&this.max[1]<this.min[1]&&this.max[2]<this.min[2]}}class ce extends U{constructor(){super(...arguments),this.bounds=(0,M.c)()}init(){(0,b.s)(this.min,Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),(0,b.s)(this.max,-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE),(0,M.l)(this.bounds)}}function ye(k,y,I){const B=k.bbMin,L=k.bbMax;if((0,_.y)(I)){const Y=(0,b.s)(F,I[12],I[13],I[14]);(0,b.a)(se,B,Y),(0,b.a)(te,L,Y);for(let P=0;P<3;++P)y.min[P]=Math.min(y.min[P],se[P]),y.max[P]=Math.max(y.max[P],te[P])}else if((0,b.m)(se,B,I),(0,b.k)(B,L))for(let Y=0;Y<3;++Y)y.min[Y]=Math.min(y.min[Y],se[Y]),y.max[Y]=Math.max(y.max[Y],se[Y]);else{(0,b.m)(te,L,I);for(let Y=0;Y<3;++Y)y.min[Y]=Math.min(y.min[Y],se[Y],te[Y]),y.max[Y]=Math.max(y.max[Y],se[Y],te[Y]);for(let Y=0;Y<3;++Y){(0,b.c)(se,B),(0,b.c)(te,L),se[Y]=L[Y],te[Y]=B[Y],(0,b.m)(se,se,I),(0,b.m)(te,te,I);for(let P=0;P<3;++P)y.min[P]=Math.min(y.min[P],se[P],te[P]),y.max[P]=Math.max(y.max[P],se[P],te[P])}}}const F=(0,q.c)(),se=(0,q.c)(),te=(0,q.c)()},64232:(Ve,Ee,a)=>{a.d(Ee,{z:()=>V});var m=a(62208),_=a(86236),g=a(28347),b=a(43703),q=a(84161),M=a(4794),c=a(98943);class V{constructor(x,$={}){this.geometry=x,this.boundingSphere=(0,M.c)(),this.screenToWorldRatio=1,this._transformation=(0,b.c)(),this._shaderTransformationDirty=!0,this.id=(0,_.D)(),this.layerUid=$.layerUid,this.graphicUid=$.graphicUid,this.boundingInfo=$.boundingInfo,this.shaderTransformer=$.shaderTransformer,this.castShadow=!!$.castShadow&&$.castShadow}get transformation(){return this._transformation}updateTransformation(x){x(this._transformation),this._shaderTransformationDirty=!0,this.computeBoundingSphere(this._transformation,this.boundingSphere)}shaderTransformationChanged(){this._shaderTransformationDirty=!0}computeBoundingSphere(x,$,X=(0,c.u1)(x)){(0,m.Wi)(this.boundingInfo)||((0,q.m)($,this.boundingInfo.center,x),$[3]=this.boundingInfo.radius*X)}get hasShaderTransformation(){return(0,m.pC)(this.shaderTransformer)}get material(){return this.geometry.material}get type(){return this.geometry.type}get shaderTransformation(){return(0,m.Wi)(this.shaderTransformer)?this.transformation:(this._shaderTransformationDirty&&(this._shaderTransformation||(this._shaderTransformation=(0,b.c)()),(0,g.c)(this._shaderTransformation,this.shaderTransformer(this.transformation)),this._shaderTransformationDirty=!1),this._shaderTransformation)}get indices(){return this.geometry.indices}get vertexAttributes(){return this.geometry.vertexAttributes}get highlights(){return this.geometry.highlights}get occludees(){return this.geometry.occludees}get visible(){return this.geometry.visible}set visible(x){this.geometry.visible=x}}},23147:(Ve,Ee,a)=>{var m,_;a.d(Ee,{j:()=>m}),(_=m||(m={}))[_.ASYNC=0]="ASYNC",_[_.SYNC=1]="SYNC"},34103:(Ve,Ee,a)=>{a.d(Ee,{F:()=>W});var m=a(61885),_=a(72392),g=a(62208),b=a(77029),q=a(12699),M=a(24425);const c=["layerObjectAdded","layerObjectRemoved","layerObjectsAdded","layerObjectsRemoved","shaderTransformationChanged","objectTransformation","visibilityChanged","occlusionChanged","highlightChanged","objectGeometryAdded","objectGeometryRemoved","objectGeometryUpdated"];var V=a(82274),H=a(23147);class W extends q.c{get objects(){return this._objects}constructor(X,O=""){super(),this.apiLayerUid=O,this.type=M.U.Layer,this.events=new m.Z,this.sliceable=!1,this._objects=new b.Z,this._objectsAdded=new b.Z,this._stageHandles=new _.Z,this.apiLayerUid=O,this.visible=X?.visible??!0,this.pickable=X?.pickable??!0,this.updatePolicy=X?.updatePolicy??H.j.ASYNC,this._disableOctree=X?.disableOctree??!1}destroy(){this.detachStage(),this._stage=null}attachStage(X){this.detachStage(),this._stage=X;for(const O of c)this._stageHandles.add(this.events.on(O,U=>X.handleEvent(O,U)))}detachStage(){this._stageHandles.removeAll(),this.invalidateSpatialQueryAccelerator()}add(X){this._objects.push(X),X.parentLayer=this,this.events.emit("layerObjectAdded",{layer:this,object:X}),(0,g.pC)(this._octree)&&this._objectsAdded.push(X)}remove(X){this._objects.removeUnordered(X)&&(X.parentLayer=null,this.events.emit("layerObjectRemoved",{layer:this,object:X}),(0,g.pC)(this._octree)&&(this._objectsAdded.removeUnordered(X)||this._octree.remove([X])))}addMany(X){this._objects.pushArray(X);for(const O of X)O.parentLayer=this;this.events.emit("layerObjectsAdded",{layer:this,objects:X}),(0,g.pC)(this._octree)&&this._objectsAdded.pushArray(X)}removeMany(X){const O=new Array;if(this._objects.removeUnorderedMany(X,X.length,O),0!==O.length){for(const U of O)U.parentLayer=null;if(this.events.emit("layerObjectsRemoved",{layer:this,objects:O}),(0,g.pC)(this._octree)){for(let U=0;U<O.length;)this._objectsAdded.removeUnordered(O[U])?(O[U]=O[O.length-1],O.length-=1):++U;this._octree.remove(O)}}}sync(){(0,g.pC)(this._stage)&&this.updatePolicy!==H.j.SYNC&&this._stage.syncLayer(this.id)}notifyObjectBBChanged(X,O){(0,g.pC)(this._octree)&&!this._objectsAdded.includes(X)&&this._octree.update(X,O)}getSpatialQueryAccelerator(){return(0,g.Wi)(this._octree)&&this._objects.length>50&&!this._disableOctree?(this._octree=new V.Z(X=>X.boundingVolumeWorldSpace.bounds),this._octree.add(this._objects.data,this._objects.length)):(0,g.pC)(this._octree)&&this._objectsAdded.length>0&&(this._octree.add(this._objectsAdded.data,this._objectsAdded.length),this._objectsAdded.clear()),this._octree}shaderTransformationChanged(){this.invalidateSpatialQueryAccelerator(),this.events.emit("shaderTransformationChanged",this)}invalidateSpatialQueryAccelerator(){this._octree=(0,g.SC)(this._octree),this._objectsAdded.clear()}}},91480:(Ve,Ee,a)=>{a.d(Ee,{nn:()=>M});var m=a(62208),g=(a(84161),a(28093));function M(x){return(0,m.pC)(x)&&(0,m.pC)(x.dist)}a(41743),a(67857),(0,g.c)()},92972:(Ve,Ee,a)=>{a.d(Ee,{E:()=>P});var m=a(8314),_=a(4794),g=a(13934),b=a(42743),q=a(60881),M=a(40723),c=a(88569),V=a(5894),H=a(2770),W=a(66131),x=a(15842),$=a(651),X=a(91056),O=a(39114),U=a(12407),ce=a(64127),ye=a(44835),F=a(89652),se=a(57596),te=a(2078);class k extends X.A{initializeConfiguration(C,J){J.hasWebGL2Context=C.rctx.type===se.zO.WEBGL2}initializeProgram(C){return new U.$(C.rctx,k.shader.get().build(this.configuration),O.i)}_createPipeline(C,J){const ie=this.configuration,v=C===ye.A.NONE,E=C===ye.A.FrontFace;return(0,te.sm)({blending:ie.output!==g.H.Color&&ie.output!==g.H.Alpha||!ie.transparent?null:v?c.wu:(0,c.j7)(C),culling:(0,te.zp)(ie.cullFace),depthTest:{func:(0,c.Bh)(C)},depthWrite:(v||E)&&ie.writeDepth?te.LZ:null,colorWrite:te.BK,stencilWrite:ie.hasOccludees?ce.s3:null,stencilTest:ie.hasOccludees?J?ce.eD:ce.RY:null,polygonOffset:v||E?ie.polygonOffset?y:null:(0,c.je)(ie.enableOffset)})}initializePipeline(){return this._occludeePipelineState=this._createPipeline(this.configuration.transparencyPassType,!0),this._createPipeline(this.configuration.transparencyPassType,!1)}getPipelineState(C,J){return J?this._occludeePipelineState:super.getPipelineState(C,J)}}k.shader=new $.J(F.C,()=>a.e(1362).then(a.bind(a,11362)));const y={factor:1,units:1};var I=a(17626),B=a(87601),L=a(41528);class Y extends L.W{constructor(){super(...arguments),this.output=g.H.Color,this.cullFace=b.Vr.None,this.hasSlicePlane=!1,this.hasVertexColors=!1,this.transparent=!1,this.polygonOffset=!1,this.enableOffset=!0,this.writeDepth=!0,this.hasOccludees=!1,this.transparencyPassType=ye.A.NONE,this.hasMultipassTerrain=!1,this.cullAboveGround=!1,this.objectAndLayerIdColorInstanced=!1}}(0,I._)([(0,B.o)({count:g.H.COUNT})],Y.prototype,"output",void 0),(0,I._)([(0,B.o)({count:b.Vr.COUNT})],Y.prototype,"cullFace",void 0),(0,I._)([(0,B.o)()],Y.prototype,"hasSlicePlane",void 0),(0,I._)([(0,B.o)()],Y.prototype,"hasVertexColors",void 0),(0,I._)([(0,B.o)()],Y.prototype,"transparent",void 0),(0,I._)([(0,B.o)()],Y.prototype,"polygonOffset",void 0),(0,I._)([(0,B.o)()],Y.prototype,"enableOffset",void 0),(0,I._)([(0,B.o)()],Y.prototype,"writeDepth",void 0),(0,I._)([(0,B.o)()],Y.prototype,"hasOccludees",void 0),(0,I._)([(0,B.o)({count:ye.A.COUNT})],Y.prototype,"transparencyPassType",void 0),(0,I._)([(0,B.o)()],Y.prototype,"hasMultipassTerrain",void 0),(0,I._)([(0,B.o)()],Y.prototype,"cullAboveGround",void 0),(0,I._)([(0,B.o)()],Y.prototype,"objectAndLayerIdColorInstanced",void 0);class P extends x.c{constructor(C){super(C,new Q),this.supportsEdges=!0,this._configuration=new Y}getConfiguration(C,J){return this._configuration.output=C,this._configuration.cullFace=this.parameters.cullFace,this._configuration.hasVertexColors=this.parameters.hasVertexColors,this._configuration.hasSlicePlane=this.parameters.hasSlicePlane,this._configuration.transparent=this.parameters.transparent,this._configuration.polygonOffset=this.parameters.polygonOffset,this._configuration.writeDepth=this.parameters.writeDepth,this._configuration.hasOccludees=this.parameters.hasOccludees,this._configuration.transparencyPassType=J.transparencyPassType,this._configuration.enableOffset=J.camera.relativeElevation<c.ve,this._configuration.hasMultipassTerrain=J.multipassTerrain.enabled,this._configuration.cullAboveGround=J.multipassTerrain.cullAboveGround,this._configuration}requiresSlot(C,J){return!!(J===g.H.Color||J===g.H.Alpha||J===g.H.Highlight||J===g.H.Depth&&this.parameters.writeLinearDepth||J===g.H.ObjectAndLayerIdColor)&&(C===V.r.DRAPED_MATERIAL||(J===g.H.Highlight?C===V.r.OPAQUE_MATERIAL:C===(this.parameters.transparent?this.parameters.writeDepth?V.r.TRANSPARENT_MATERIAL:V.r.TRANSPARENT_DEPTH_WRITE_DISABLED_MATERIAL:V.r.OPAQUE_MATERIAL)))}createGLMaterial(C){return new T(C)}createBufferWriter(){return new H.G((0,m.Z)("enable-feature:objectAndLayerId-rendering")?W.ck:W.IM)}}class T extends q.Z{_updateOccludeeState(C){C.hasOccludees!==this._material.parameters.hasOccludees&&this._material.setParameters({hasOccludees:C.hasOccludees})}beginSlot(C){return this._output!==g.H.Color&&this._output!==g.H.Alpha||this._updateOccludeeState(C),this.ensureTechnique(k,C)}}class Q extends M.Mt{constructor(){super(...arguments),this.color=_.Z,this.transparent=!1,this.writeDepth=!0,this.writeLinearDepth=!1,this.hasVertexColors=!1,this.polygonOffset=!1,this.hasSlicePlane=!1,this.cullFace=b.Vr.None,this.hasOccludees=!1}}},66131:(Ve,Ee,a)=>{a.d(Ee,{IM:()=>q,W1:()=>b,ck:()=>V,wp:()=>g});var m=a(19625),_=a(16396);const g=(0,m.U$)().vec3f(_.T.POSITION),b=(0,m.U$)().vec3f(_.T.POSITION).vec2f(_.T.UV0),q=(0,m.U$)().vec3f(_.T.POSITION).vec4u8(_.T.COLOR),V=((0,m.U$)().vec3f(_.T.POSITION).vec4u8(_.T.OBJECTANDLAYERIDCOLOR),(0,m.U$)().vec3f(_.T.POSITION).vec2f(_.T.UV0).vec4u8(_.T.OBJECTANDLAYERIDCOLOR),(0,m.U$)().vec3f(_.T.POSITION).vec4u8(_.T.COLOR).vec4u8(_.T.OBJECTANDLAYERIDCOLOR))},10285:(Ve,Ee,a)=>{a.d(Ee,{A:()=>vt});var m=a(8314),_=a(21286),g=a(62208),b=a(30217),q=a(550),M=a(28347),c=a(43703),V=a(67831),H=a(99770),W=a(84161),x=a(28093),$=a(4794);var ce=a(65401),ye=a(60479),F=a(93605),se=a(19625),te=a(13934),k=a(3090),y=a(33470),I=a(40723),B=a(5894),L=a(17962),Y=a(2282),P=a(16396);class Q{constructor(){this.scale=0,this.factor=0,this.minPixelSize=0,this.paddingPixels=0}}var w=a(42037),C=a(57623),J=a(6467),ie=a(59617),v=a(651),E=a(91056),K=a(39114),ue=a(88569),Me=a(12407),Le=a(44835),Fe=a(57596),He=a(67969),Ke=a(2078);class Xe extends E.A{initializeConfiguration(ee,fe){fe.hasWebGL2Context=ee.rctx.type===Fe.zO.WEBGL2,fe.spherical=ee.viewingMode===ie.JY.Global}initializeProgram(ee){return new Me.$(ee.rctx,Xe.shader.get().build(this.configuration),K.i)}_setPipelineState(ee){const fe=this.configuration,le=ee===Le.A.NONE,Se=this.configuration.hasPolygonOffset?Ge:null,Ae=!le&&ee!==Le.A.FrontFace||fe.output===te.H.Highlight||!fe.depthEnabled&&!fe.occlusionPass?null:Ke.LZ;return(0,Ke.sm)({blending:fe.output===te.H.Color||fe.output===te.H.Alpha||fe.output===te.H.Highlight?le?tt:(0,ue.j7)(ee):null,depthTest:{func:He.wb.LEQUAL},depthWrite:Ae,colorWrite:Ke.BK,polygonOffset:Se})}initializePipeline(){return this._setPipelineState(this.configuration.transparencyPassType)}get primitiveType(){return this.configuration.occlusionPass?He.MX.POINTS:He.MX.TRIANGLES}}Xe.shader=new v.J(J.H,()=>a.e(6771).then(a.bind(a,46771)));const Ge={factor:0,units:-4},tt=(0,Ke.if)(He.zi.ONE,He.zi.ONE_MINUS_SRC_ALPHA);var Ye=a(17626),ke=a(87601),Ut=a(41528);class qe extends Ut.W{constructor(){super(...arguments),this.output=te.H.Color,this.screenCenterOffsetUnitsEnabled=k.d.World,this.transparencyPassType=Le.A.NONE,this.spherical=!1,this.occlusionTestEnabled=!0,this.signedDistanceFieldEnabled=!1,this.vvSize=!1,this.vvColor=!1,this.hasVerticalOffset=!1,this.hasScreenSizePerspective=!1,this.debugDrawLabelBorder=!1,this.binaryHighlightOcclusionEnabled=!0,this.hasSlicePlane=!1,this.hasPolygonOffset=!1,this.depthEnabled=!0,this.pixelSnappingEnabled=!0,this.isDraped=!1,this.hasMultipassGeometry=!1,this.hasMultipassTerrain=!1,this.cullAboveGround=!1,this.occlusionPass=!1,this.objectAndLayerIdColorInstanced=!1}}(0,Ye._)([(0,ke.o)({count:te.H.COUNT})],qe.prototype,"output",void 0),(0,Ye._)([(0,ke.o)({count:k.d.COUNT})],qe.prototype,"screenCenterOffsetUnitsEnabled",void 0),(0,Ye._)([(0,ke.o)({count:Le.A.COUNT})],qe.prototype,"transparencyPassType",void 0),(0,Ye._)([(0,ke.o)()],qe.prototype,"spherical",void 0),(0,Ye._)([(0,ke.o)()],qe.prototype,"occlusionTestEnabled",void 0),(0,Ye._)([(0,ke.o)()],qe.prototype,"signedDistanceFieldEnabled",void 0),(0,Ye._)([(0,ke.o)()],qe.prototype,"vvSize",void 0),(0,Ye._)([(0,ke.o)()],qe.prototype,"vvColor",void 0),(0,Ye._)([(0,ke.o)()],qe.prototype,"hasVerticalOffset",void 0),(0,Ye._)([(0,ke.o)()],qe.prototype,"hasScreenSizePerspective",void 0),(0,Ye._)([(0,ke.o)()],qe.prototype,"debugDrawLabelBorder",void 0),(0,Ye._)([(0,ke.o)()],qe.prototype,"binaryHighlightOcclusionEnabled",void 0),(0,Ye._)([(0,ke.o)()],qe.prototype,"hasSlicePlane",void 0),(0,Ye._)([(0,ke.o)()],qe.prototype,"hasPolygonOffset",void 0),(0,Ye._)([(0,ke.o)()],qe.prototype,"depthEnabled",void 0),(0,Ye._)([(0,ke.o)()],qe.prototype,"pixelSnappingEnabled",void 0),(0,Ye._)([(0,ke.o)()],qe.prototype,"isDraped",void 0),(0,Ye._)([(0,ke.o)()],qe.prototype,"hasMultipassGeometry",void 0),(0,Ye._)([(0,ke.o)()],qe.prototype,"hasMultipassTerrain",void 0),(0,Ye._)([(0,ke.o)()],qe.prototype,"cullAboveGround",void 0),(0,Ye._)([(0,ke.o)()],qe.prototype,"occlusionPass",void 0),(0,Ye._)([(0,ke.o)()],qe.prototype,"objectAndLayerIdColorInstanced",void 0),(0,Ye._)([(0,ke.o)({constValue:!0})],qe.prototype,"hasSliceInVertexProgram",void 0),(0,Ye._)([(0,ke.o)({constValue:!1})],qe.prototype,"hasVvInstancing",void 0);class vt extends I.F5{constructor(ee){super(ee,new me),this._configuration=new qe}getConfiguration(ee,fe){return this._configuration.output=ee,this._configuration.hasSlicePlane=this.parameters.hasSlicePlane,this._configuration.hasVerticalOffset=!!this.parameters.verticalOffset,this._configuration.hasScreenSizePerspective=!!this.parameters.screenSizePerspective,this._configuration.screenCenterOffsetUnitsEnabled="screen"===this.parameters.centerOffsetUnits?k.d.Screen:k.d.World,this._configuration.hasPolygonOffset=this.parameters.polygonOffset,this._configuration.isDraped=this.parameters.isDraped,this._configuration.occlusionTestEnabled=this.parameters.occlusionTest,this._configuration.pixelSnappingEnabled=this.parameters.pixelSnappingEnabled,this._configuration.signedDistanceFieldEnabled=this.parameters.textureIsSignedDistanceField,this._configuration.vvSize=!!this.parameters.vvSizeEnabled,this._configuration.vvColor=!!this.parameters.vvColorEnabled,this._configuration.occlusionPass=fe.slot===B.r.OCCLUSION_PIXELS&&this.parameters.occlusionTest&&(ee===te.H.Color||ee===te.H.Alpha),ee===te.H.Color&&(this._configuration.debugDrawLabelBorder=!!F.Z.LABELS_SHOW_BORDER),ee===te.H.Highlight&&(this._configuration.binaryHighlightOcclusionEnabled=this.parameters.binaryHighlightOcclusion),this._configuration.depthEnabled=this.parameters.depthEnabled,this._configuration.transparencyPassType=fe.transparencyPassType,this._configuration.hasMultipassGeometry=fe.multipassGeometry.enabled,this._configuration.hasMultipassTerrain=fe.multipassTerrain.enabled,this._configuration.cullAboveGround=fe.multipassTerrain.cullAboveGround,this._configuration}intersect(ee,fe,le,pe,Se,Ae){if(!le.options.selectionMode||!le.options.hud||!ee.visible)return;const De=this.parameters;let Ue=1,Re=1;if((0,b.f)(ne,fe),(0,g.pC)(ee.shaderTransformer)){const at=ee.shaderTransformer(ae);Ue=at[0],Re=at[5],function yt(Te){const ee=Te[0],fe=Te[1],le=Te[2],pe=Te[3],Se=Te[4],Ae=Te[5],De=Te[6],Ue=Te[7],Re=Te[8],Ie=1/Math.sqrt(ee*ee+fe*fe+le*le),rt=1/Math.sqrt(pe*pe+Se*Se+Ae*Ae),Pe=1/Math.sqrt(De*De+Ue*Ue+Re*Re);Te[0]=ee*Ie,Te[1]=fe*Ie,Te[2]=le*Ie,Te[3]=pe*rt,Te[4]=Se*rt,Te[5]=Ae*rt,Te[6]=De*Pe,Te[7]=Ue*Pe,Te[8]=Re*Pe}(ne)}const Ie=ee.vertexAttributes.get(P.T.POSITION),rt=ee.vertexAttributes.get(P.T.SIZE),Pe=ee.vertexAttributes.get(P.T.NORMAL),Je=ee.vertexAttributes.get(P.T.AUXPOS1);(0,Y.hu)(Ie.size>=3);const ut=le.point,ot=le.camera,Tt=(0,J.c)(De);Ue*=ot.pixelRatio,Re*=ot.pixelRatio;const ft="screen"===this.parameters.centerOffsetUnits;for(let at=0;at<Ie.data.length/Ie.size;at++){const nt=at*Ie.size;(0,W.s)(ct,Ie.data[nt],Ie.data[nt+1],Ie.data[nt+2]),(0,W.m)(ct,ct,fe);const Ne=at*rt.size;Oe[0]=rt.data[Ne]*Ue,Oe[1]=rt.data[Ne+1]*Re,(0,W.m)(ct,ct,ot.viewMatrix);const lt=at*Je.size;if((0,W.s)(j,Je.data[lt+0],Je.data[lt+1],Je.data[lt+2]),!ft&&(ct[0]+=j[0],ct[1]+=j[1],0!==j[2])){const mt=j[2];(0,W.n)(j,ct),(0,W.b)(ct,ct,(0,W.g)(j,j,mt))}const gt=at*Pe.size;if((0,W.s)(Qe,Pe.data[gt],Pe.data[gt+1],Pe.data[gt+2]),this._normalAndViewAngle(Qe,ne,ot,he),this._applyVerticalOffsetTransformationView(ct,he,ot,Ot),ot.applyProjection(ct,G),G[0]>-1){G[0]=Math.floor(G[0]),G[1]=Math.floor(G[1]),ft&&(j[0]||j[1])&&(G[0]+=j[0],0!==j[1]&&(G[1]+=(0,L.sX)(j[1],Ot.factorAlignment)),ot.unapplyProjection(G,ct)),G[0]+=this.parameters.screenOffset[0],G[1]+=this.parameters.screenOffset[1],(0,L.TU)(Oe,Ot.factor,Oe);let St=0;if(De.textureIsSignedDistanceField&&(St=De.outlineSize*ot.pixelRatio/2),ut&&At(ut,G[0],G[1],Oe,ge*ot.pixelRatio,St,De,Tt)){const It=le.ray;if((0,W.m)(re,ct,(0,M.a)(Z,ot.viewMatrix)),G[0]=ut[0],G[1]=ut[1],ot.unprojectFromRenderScreen(G,ct)){const Ct=(0,x.c)();(0,W.c)(Ct,It.direction);const zt=1/(0,W.l)(Ct);(0,W.g)(Ct,Ct,zt),Ae((0,W.i)(It.origin,ct)*zt,Ct,-1,!0,1,re)}}}}}intersectDraped(ee,fe,le,pe,Se,Ae){const De=ee.vertexAttributes.get(P.T.POSITION),Ue=ee.vertexAttributes.get(P.T.SIZE),Re=this.parameters,Ie=(0,J.c)(Re);let rt=1,Pe=1;if((0,g.pC)(ee.shaderTransformer)){const ut=ee.shaderTransformer(ae);rt=ut[0],Pe=ut[5]}rt*=ee.screenToWorldRatio,Pe*=ee.screenToWorldRatio;const Je=xe*ee.screenToWorldRatio;for(let ut=0;ut<De.data.length/De.size;ut++){const ot=ut*De.size,Tt=De.data[ot],ft=De.data[ot+1],at=ut*Ue.size;Oe[0]=Ue.data[at]*rt,Oe[1]=Ue.data[at+1]*Pe;let nt=0;Re.textureIsSignedDistanceField&&(nt=Re.outlineSize*ee.screenToWorldRatio/2),At(pe,Tt,ft,Oe,Je,nt,Re,Ie)&&Se(Ae.dist,Ae.normal,-1,!1)}}createBufferWriter(){return new je(this)}_normalAndViewAngle(ee,fe,le,pe){return function U(Te){return function X(Te){return Te instanceof Float32Array&&Te.length>=16}(Te)||function O(Te){return Array.isArray(Te)&&Te.length>=16}(Te)}(fe)&&(fe=(0,b.f)(ve,fe)),(0,W.t)(pe.normal,ee,fe),(0,W.m)(pe.normal,pe.normal,le.viewInverseTransposeMatrix),pe.cosAngle=(0,W.e)(_e,de),pe}_updateScaleInfo(ee,fe,le){const pe=this.parameters;(0,g.pC)(pe.screenSizePerspective)?(0,L.PV)(le,fe,pe.screenSizePerspective,ee.factor):(ee.factor.scale=1,ee.factor.factor=0,ee.factor.minPixelSize=0,ee.factor.paddingPixels=0),(0,g.pC)(pe.screenSizePerspectiveAlignment)?(0,L.PV)(le,fe,pe.screenSizePerspectiveAlignment,ee.factorAlignment):(ee.factorAlignment.factor=ee.factor.factor,ee.factorAlignment.scale=ee.factor.scale,ee.factorAlignment.minPixelSize=ee.factor.minPixelSize,ee.factorAlignment.paddingPixels=ee.factor.paddingPixels)}applyShaderOffsetsView(ee,fe,le,pe,Se,Ae,De){const Ue=this._normalAndViewAngle(fe,le,Se,he);return this._applyVerticalGroundOffsetView(ee,Ue,Se,De),this._applyVerticalOffsetTransformationView(De,Ue,Se,Ae),this._applyPolygonOffsetView(De,Ue,pe[3],Se,De),this._applyCenterOffsetView(De,pe,De),De}applyShaderOffsetsNDC(ee,fe,le,pe,Se){return this._applyCenterOffsetNDC(ee,fe,le,pe),(0,g.pC)(Se)&&(0,W.c)(Se,pe),this._applyPolygonOffsetNDC(pe,fe,le,pe),pe}_applyPolygonOffsetView(ee,fe,le,pe,Se){const Ae=pe.aboveGround?1:-1;let De=Math.sign(le);0===De&&(De=Ae);const Ue=Ae*De;if(this.parameters.shaderPolygonOffset<=0)return(0,W.c)(Se,ee);const Re=(0,_.uZ)(Math.abs(fe.cosAngle),.01,1),Ie=1-Math.sqrt(1-Re*Re)/Re/pe.viewport[2];return(0,W.g)(Se,ee,Ue>0?Ie:1/Ie),Se}_applyVerticalGroundOffsetView(ee,fe,le,pe){const Se=(0,W.l)(ee),Ae=le.aboveGround?1:-1,De=.5*le.computeRenderPixelSizeAtDist(Se),Ue=(0,W.g)(ct,fe.normal,Ae*De);return(0,W.a)(pe,ee,Ue),pe}_applyVerticalOffsetTransformationView(ee,fe,le,pe){const Se=this.parameters;if(!Se.verticalOffset||!Se.verticalOffset.screenLength){if(Se.screenSizePerspective||Se.screenSizePerspectiveAlignment){const Re=(0,W.l)(ee);this._updateScaleInfo(pe,Re,fe.cosAngle)}else pe.factor.scale=1,pe.factorAlignment.scale=1;return ee}const Ae=(0,W.l)(ee),De=(0,g.Pt)(Se.screenSizePerspectiveAlignment,Se.screenSizePerspective),Ue=(0,C.Hx)(le,Ae,Se.verticalOffset,fe.cosAngle,De);return this._updateScaleInfo(pe,Ae,fe.cosAngle),(0,W.g)(fe.normal,fe.normal,Ue),(0,W.a)(ee,ee,fe.normal)}_applyCenterOffsetView(ee,fe,le){const pe="screen"!==this.parameters.centerOffsetUnits;return le!==ee&&(0,W.c)(le,ee),pe&&(le[0]+=fe[0],le[1]+=fe[1],fe[2]&&((0,W.n)(Qe,le),(0,W.a)(le,le,(0,W.g)(Qe,Qe,fe[2])))),le}_applyCenterOffsetNDC(ee,fe,le,pe){const Se="screen"!==this.parameters.centerOffsetUnits;return pe!==ee&&(0,W.c)(pe,ee),Se||(pe[0]+=fe[0]/le.fullWidth*2,pe[1]+=fe[1]/le.fullHeight*2),pe}_applyPolygonOffsetNDC(ee,fe,le,pe){const Se=this.parameters.shaderPolygonOffset;if(ee!==pe&&(0,W.c)(pe,ee),Se){const Ae=le.aboveGround?1:-1,De=Ae*Math.sign(fe[3]);pe[2]-=(De||Ae)*Se}return pe}requiresSlot(ee,fe){if(fe===te.H.Color||fe===te.H.Alpha||fe===te.H.Highlight||fe===te.H.ObjectAndLayerIdColor){if(ee===B.r.DRAPED_MATERIAL)return!0;const{drawInSecondSlot:le,occlusionTest:pe}=this.parameters;return ee===(le?B.r.LABEL_MATERIAL:B.r.HUD_MATERIAL)||pe&&ee===B.r.OCCLUSION_PIXELS}return!1}createGLMaterial(ee){return new Dt(ee)}calculateRelativeScreenBounds(ee,fe,le=(0,ce.Ue)()){return function it(Te,ee,fe,le=Et){(0,V.c)(le,Te.anchorPosition),le[0]*=-ee[0],le[1]*=-ee[1],le[0]+=Te.screenOffset[0]*fe,le[1]+=Te.screenOffset[1]*fe}(this.parameters,ee,fe,le),le[2]=le[0]+ee[0],le[3]=le[1]+ee[1],le}}class Dt extends y.F{constructor(ee){super({...ee,...ee.material.parameters})}selectProgram(ee){return this.ensureTechnique(Xe,ee)}beginSlot(ee){return this.updateTexture(this._material.parameters.textureId),this._material.setParameters(this.textureBindParameters),this.selectProgram(ee)}}function At(Te,ee,fe,le,pe,Se,Ae,De){let Ue=ee-pe-(De[0]>0?le[0]*De[0]:0),Re=Ue+le[0]+2*pe,Ie=fe-pe-(De[1]>0?le[1]*De[1]:0),rt=Ie+le[1]+2*pe;const Pe=Ae.distanceFieldBoundingBox;return Ae.textureIsSignedDistanceField&&(0,g.pC)(Pe)&&(Ue+=le[0]*Pe[0],Ie+=le[1]*Pe[1],Re-=le[0]*(1-Pe[2]),rt-=le[1]*(1-Pe[3]),Ue-=Se,Re+=Se,Ie-=Se,rt+=Se),Te[0]>Ue&&Te[0]<Re&&Te[1]>Ie&&Te[1]<rt}const Ot=new class T{constructor(){this.factor=new Q,this.factorAlignment=new Q}},Et=(0,H.a)(),ct=(0,x.c)(),Qe=(0,x.c)(),G=(0,$.c)(),_e=(0,x.c)(),re=(0,x.c)(),ne=(0,q.c)(),ve=(0,q.c)(),Z=(0,c.c)(),j=(0,x.c)(),he={normal:_e,cosAngle:0},ae=(0,c.c)(),ge=1,xe=2,Oe=[0,0],de=(0,x.f)(0,0,1);class me extends y.E{constructor(){super(...arguments),this.renderOccluded=I.yD.Occlude,this.color=(0,$.f)(1,1,1,1),this.texCoordScale=[1,1],this.polygonOffset=!1,this.anchorPosition=(0,H.f)(.5,.5),this.screenOffset=[0,0],this.shaderPolygonOffset=1e-5,this.textureIsSignedDistanceField=!1,this.outlineColor=(0,$.f)(1,1,1,1),this.outlineSize=0,this.vvSizeEnabled=!1,this.vvSizeMinSize=[1,1,1],this.vvSizeMaxSize=[100,100,100],this.vvSizeOffset=[0,0,0],this.vvSizeFactor=[1,1,1],this.vvColorEnabled=!1,this.vvColorValues=[0,0,0,0,0,0,0,0],this.vvColorColors=[1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0],this.hasSlicePlane=!1,this.pixelSnappingEnabled=!0,this.occlusionTest=!0,this.binaryHighlightOcclusion=!0,this.centerOffsetUnits="world",this.drawInSecondSlot=!1,this.depthEnabled=!0,this.isDraped=!1}}const oe=(0,se.U$)().vec3f(P.T.POSITION).vec3f(P.T.NORMAL).vec2f(P.T.UV0).vec4u8(P.T.COLOR).vec2f(P.T.SIZE).vec4f(P.T.AUXPOS1).vec4f(P.T.AUXPOS2),be=oe.clone().vec4u8(P.T.OBJECTANDLAYERIDCOLOR);class je{constructor(ee){this._material=ee,this.vertexBufferLayout=(0,m.Z)("enable-feature:objectAndLayerId-rendering")?be:oe}allocate(ee){return this.vertexBufferLayout.createBuffer(ee)}elementCount(ee){return 6*ee.indices.get(P.T.POSITION).length}write(ee,fe,le,pe,Se){(0,w.ho)(le.indices.get(P.T.POSITION),le.vertexAttributes.get(P.T.POSITION).data,ee,pe.position,Se,6),(0,w.s5)(le.indices.get(P.T.NORMAL),le.vertexAttributes.get(P.T.NORMAL).data,fe,pe.normal,Se,6);const Ae=le.vertexAttributes.get(P.T.UV0).data;let De,Ue,Re,Ie;if(null==Ae||Ae.length<4){const ft=this._material.parameters;De=0,Ue=0,Re=ft.texCoordScale[0],Ie=ft.texCoordScale[1]}else De=Ae[0],Ue=Ae[1],Re=Ae[2],Ie=Ae[3];Re=Math.min(1.99999,Re+1),Ie=Math.min(1.99999,Ie+1);let rt=le.indices.get(P.T.POSITION).length,Pe=Se;const Je=pe.uv0;for(let ft=0;ft<rt;++ft)Je.set(Pe,0,De),Je.set(Pe,1,Ue),Pe+=1,Je.set(Pe,0,Re),Je.set(Pe,1,Ue),Pe+=1,Je.set(Pe,0,Re),Je.set(Pe,1,Ie),Pe+=1,Je.set(Pe,0,Re),Je.set(Pe,1,Ie),Pe+=1,Je.set(Pe,0,De),Je.set(Pe,1,Ie),Pe+=1,Je.set(Pe,0,De),Je.set(Pe,1,Ue),Pe+=1;(0,w.Vs)(le.indices.get(P.T.COLOR),le.vertexAttributes.get(P.T.COLOR).data,4,pe.color,Se,6);const ut=le.indices.get(P.T.SIZE),ot=le.vertexAttributes.get(P.T.SIZE).data;rt=ut.length;const Tt=pe.size;Pe=Se;for(let ft=0;ft<rt;++ft){const at=ot[2*ut[ft]],nt=ot[2*ut[ft]+1];for(let Ne=0;Ne<6;++Ne)Tt.set(Pe,0,at),Tt.set(Pe,1,nt),Pe+=1}if(le.indices.get(P.T.AUXPOS1)&&le.vertexAttributes.get(P.T.AUXPOS1)?(0,w.SW)(le.indices.get(P.T.AUXPOS1),le.vertexAttributes.get(P.T.AUXPOS1).data,pe.auxpos1,Se,6):(0,w.h)(pe.auxpos1,Se,6*rt),le.indices.get(P.T.AUXPOS2)&&le.vertexAttributes.get(P.T.AUXPOS2)?(0,w.SW)(le.indices.get(P.T.AUXPOS2),le.vertexAttributes.get(P.T.AUXPOS2).data,pe.auxpos2,Se,6):(0,w.h)(pe.auxpos2,Se,6*rt),(0,g.pC)(le.objectAndLayerIdColor)&&le.indices.get(P.T.POSITION)){const ft=le.indices.get(P.T.POSITION).length,at=pe.getField(P.T.OBJECTANDLAYERIDCOLOR,ye.mc);(0,w.xP)(le.objectAndLayerIdColor,at,ft,Se,6)}}}},49580:(Ve,Ee,a)=>{a.d(Ee,{Y:()=>ue});var m=a(63290),_=a(21286),g=a(62208),b=a(23841),q=a(67831),M=a(84161),c=a(28093),V=a(4794),H=a(8834),W=a(10992),x=a(90014),$=a(60479),X=a(13934),O=a(60881),U=a(40723),ce=a(5894),ye=a(2282),F=a(16396),se=a(2770),te=a(66131),k=a(42037),y=a(651),I=a(91056),B=a(39114),L=a(12407),Y=a(64127),P=a(32616),T=a(57596),Q=a(67969),w=a(2078);class C extends I.A{get _stippleEnabled(){return this.configuration.stippleEnabled&&this.configuration.output!==X.H.Highlight}initializeConfiguration(G,_e){_e.hasWebGL2Context=G.rctx.type===T.zO.WEBGL2}initializeProgram(G){return new L.$(G.rctx,C.shader.get().build(this.configuration),B.i)}initializePipeline(){const G=this.configuration,_e=(0,w.wK)(Q.zi.SRC_ALPHA,Q.zi.ONE,Q.zi.ONE_MINUS_SRC_ALPHA,Q.zi.ONE_MINUS_SRC_ALPHA),re=(ne,ve=null,Z=null)=>(0,w.sm)({blending:ve,depthTest:Y.JN,depthWrite:Z,colorWrite:w.BK,stencilWrite:G.hasOccludees?Y.s3:null,stencilTest:G.hasOccludees?ne?Y.eD:Y.RY:null});return G.output===X.H.Color?(this._occludeePipelineState=re(!0,G.transparent||this._stippleEnabled?_e:null,w.LZ),re(!1,G.transparent||this._stippleEnabled?_e:null,w.LZ)):re(!1)}get primitiveType(){return Q.MX.LINES}getPipelineState(G,_e){return _e?this._occludeePipelineState:super.getPipelineState(G,_e)}}C.shader=new y.J(P.N,()=>a.e(310).then(a.bind(a,20310)));var K,Qe,J=a(17626),ie=a(87601),v=a(41528);class E extends v.W{constructor(){super(...arguments),this.output=X.H.Color,this.hasSlicePlane=!1,this.hasVertexColors=!1,this.transparent=!1,this.draped=!1,this.stippleEnabled=!1,this.stippleOffColorEnabled=!1,this.stipplePreferContinuous=!0,this.hasOccludees=!1}}(0,J._)([(0,ie.o)({count:X.H.COUNT})],E.prototype,"output",void 0),(0,J._)([(0,ie.o)()],E.prototype,"hasSlicePlane",void 0),(0,J._)([(0,ie.o)()],E.prototype,"hasVertexColors",void 0),(0,J._)([(0,ie.o)()],E.prototype,"transparent",void 0),(0,J._)([(0,ie.o)()],E.prototype,"draped",void 0),(0,J._)([(0,ie.o)()],E.prototype,"stippleEnabled",void 0),(0,J._)([(0,ie.o)()],E.prototype,"stippleOffColorEnabled",void 0),(0,J._)([(0,ie.o)()],E.prototype,"stipplePreferContinuous",void 0),(0,J._)([(0,ie.o)()],E.prototype,"hasOccludees",void 0),(0,J._)([(0,ie.o)({constValue:!1})],E.prototype,"stippleRequiresClamp",void 0),(0,J._)([(0,ie.o)({constValue:!1})],E.prototype,"stippleScaleWithLineWidth",void 0),(0,J._)([(0,ie.o)({constValue:!1})],E.prototype,"stippleRequiresStretchMeasure",void 0),(Qe=K||(K={}))[Qe.START=0]="START",Qe[Qe.END=1]="END";class ue extends U.F5{constructor(G){super(G,new Fe),this._configuration=new E}getConfiguration(G,_e){this._configuration.output=G,this._configuration.hasSlicePlane=this.parameters.hasSlicePlane,this._configuration.hasVertexColors=this.parameters.hasVertexColors,this._configuration.transparent=this.parameters.color[3]<1||this.parameters.width<1,this._configuration.draped=_e.slot===ce.r.DRAPED_MATERIAL;const re=(0,g.pC)(this.parameters.stipplePattern);return this._configuration.stippleEnabled=re,this._configuration.stippleOffColorEnabled=re&&(0,g.pC)(this.parameters.stippleOffColor),this._configuration.hasOccludees=this.parameters.hasOccludees,this._configuration.stipplePreferContinuous=this.parameters.stipplePreferContinuous,this._configuration}intersect(G,_e,re,ne,ve,Z){if(!re.options.selectionMode||!G.visible)return;if(!(0,ye.kG)(_e))return void m.Z.getLogger("esri.views.3d.webgl-engine.materials.NativeLineMaterial").error("intersection assumes a translation-only matrix");const j=G.vertexAttributes.get(F.T.POSITION).data,he=re.camera,ae=Dt;(0,q.c)(ae,re.point),(0,M.s)(it[0],ae[0]-2,ae[1]+2,0),(0,M.s)(it[1],ae[0]+2,ae[1]+2,0),(0,M.s)(it[2],ae[0]+2,ae[1]-2,0),(0,M.s)(it[3],ae[0]-2,ae[1]-2,0);for(let oe=0;oe<4;oe++)if(!he.unprojectFromRenderScreen(it[oe],yt[oe]))return;(0,x.zk)(he.eye,yt[0],yt[1],At),(0,x.zk)(he.eye,yt[1],yt[2],Ot),(0,x.zk)(he.eye,yt[2],yt[3],Et),(0,x.zk)(he.eye,yt[3],yt[0],ct);let xe=Number.MAX_VALUE,Oe=0;for(let oe=0;oe<j.length-5;oe+=3){if(He[0]=j[oe]+_e[12],He[1]=j[oe+1]+_e[13],He[2]=j[oe+2]+_e[14],Ke[0]=j[oe+3]+_e[12],Ke[1]=j[oe+4]+_e[13],Ke[2]=j[oe+5]+_e[14],(0,x.jH)(At,He)<0&&(0,x.jH)(At,Ke)<0||(0,x.jH)(Ot,He)<0&&(0,x.jH)(Ot,Ke)<0||(0,x.jH)(Et,He)<0&&(0,x.jH)(Et,Ke)<0||(0,x.jH)(ct,He)<0&&(0,x.jH)(ct,Ke)<0)continue;if(he.projectToRenderScreen(He,tt),he.projectToRenderScreen(Ke,Ye),tt[2]<0&&Ye[2]>0){(0,M.b)(Xe,He,Ke);const je=he.frustum,Te=-(0,x.jH)(je[H.Nu.NEAR],He)/(0,M.e)(Xe,(0,x.mJ)(je[H.Nu.NEAR]));(0,M.g)(Xe,Xe,Te),(0,M.a)(He,He,Xe),he.projectToRenderScreen(He,tt)}else if(tt[2]>0&&Ye[2]<0){(0,M.b)(Xe,Ke,He);const je=he.frustum,Te=-(0,x.jH)(je[H.Nu.NEAR],Ke)/(0,M.e)(Xe,(0,x.mJ)(je[H.Nu.NEAR]));(0,M.g)(Xe,Xe,Te),(0,M.a)(Ke,Ke,Xe),he.projectToRenderScreen(Ke,Ye)}else if(tt[2]<0&&Ye[2]<0)continue;tt[2]=0,Ye[2]=0;const be=(0,W.Jk)((0,W.zk)(tt,Ye,qe),ae);be<xe&&(xe=be,(0,M.c)(ke,He),(0,M.c)(Ut,Ke),Oe=oe/3)}const de=re.rayBegin,me=re.rayEnd;if(xe<4){let oe=Number.MAX_VALUE;if((0,W.AR)((0,W.zk)(ke,Ut,qe),(0,W.zk)(de,me,vt),Ge)){(0,M.b)(Ge,Ge,de);const be=(0,M.l)(Ge);(0,M.g)(Ge,Ge,1/be),oe=be/(0,M.i)(de,me)}Z(oe,Ge,Oe,!1)}}intersectDraped(G,_e,re,ne,ve,Z){if(!re.options.selectionMode)return;const j=G.vertexAttributes.get(F.T.POSITION).data,he=G.vertexAttributes.get(F.T.SIZE),ge=ne[0],xe=ne[1],Oe=(((he?he.data[0]:0)+1)/2+4)*G.screenToWorldRatio;let de=Number.MAX_VALUE,me=0;for(let oe=0;oe<j.length-5;oe+=3){const be=j[oe],je=j[oe+1],Te=ge-be,ee=xe-je,fe=j[oe+3]-be,le=j[oe+4]-je,pe=(0,_.uZ)((fe*Te+le*ee)/(fe*fe+le*le),0,1),Se=fe*pe-Te,Ae=le*pe-ee,De=Se*Se+Ae*Ae;De<de&&(de=De,me=oe/3)}de<Oe*Oe&&ve(Z.dist,Z.normal,me,!1)}requiresSlot(G,_e){return!(_e!==X.H.Color&&_e!==X.H.Highlight&&_e!==X.H.ObjectAndLayerIdColor||G!==ce.r.OPAQUE_MATERIAL&&G!==ce.r.DRAPED_MATERIAL)}createGLMaterial(G){return new Me(G)}createBufferWriter(){const G=this.parameters.hasVertexColors?te.IM:te.wp;return(0,g.Wi)(this.parameters.stipplePattern)?new se.G(G):new Le(G.clone().vec3f(F.T.AUXPOS1).vec2f(F.T.UV0))}}class Me extends O.Z{constructor(){super(...arguments),this._stipplePattern=null}dispose(){super.dispose(),this._stippleTextureRepository.release(this._stipplePattern),this._stipplePattern=null}_updateOccludeeState(G){G.hasOccludees!==this._material.parameters.hasOccludees&&this._material.setParameters({hasOccludees:G.hasOccludees})}beginSlot(G){this._output===X.H.Color&&this._updateOccludeeState(G);const _e=this._material.parameters.stipplePattern;return this._stipplePattern!==_e&&(this._material.setParameters(this._stippleTextureRepository.swap(this._stipplePattern,_e)),this._stipplePattern=_e),this.ensureTechnique(C,G)}}class Le{constructor(G){this.vertexBufferLayout=G}allocate(G){return this.vertexBufferLayout.createBuffer(G)}elementCount(G){return G.indices.get(F.T.POSITION).length}write(G,_e,re,ne,ve){(0,k.NK)(re,this.vertexBufferLayout,G,_e,ne,ve),this._writeAuxpos1(G,re,ne,ve),this._writeUV0(G,re,ne,ve)}_writeAuxpos1(G,_e,re,ne){const ve=re.getField(F.T.AUXPOS1,$.ct),Z=_e.indices.get(F.T.POSITION),j=_e.vertexAttributes.get(F.T.POSITION).data,he=G,ae=ve.typedBufferStride,ge=ve.typedBuffer;ne*=ae;for(let xe=0;xe<Z.length-1;xe+=2)for(const Oe of[1,0]){const de=3*Z[xe+Oe],me=j[de],oe=j[de+1],be=j[de+2],Te=he[1]*me+he[5]*oe+he[9]*be+he[13],ee=he[2]*me+he[6]*oe+he[10]*be+he[14];ge[ne]=he[0]*me+he[4]*oe+he[8]*be+he[12],ge[ne+1]=Te,ge[ne+2]=ee,ne+=ae}}_writeUV0(G,_e,re,ne){const ve=re.getField(F.T.UV0,$.Eu),Z=_e.indices.get(F.T.POSITION),j=_e.vertexAttributes.get(F.T.POSITION).data,he=_e.vertexAttributes.get(F.T.DISTANCETOSTART)?.data,ae=ve.typedBufferStride,ge=ve.typedBuffer;let xe=0;ge[ne*=ae]=K.START,ge[ne+1]=xe,ne+=ae;const Oe=3*Z[0],de=(0,M.s)(He,j[Oe],j[Oe+1],j[Oe+2]);G&&(0,M.m)(de,de,G);const me=Ke,oe=Z.length-1;let be=1;const je=he?(ee,fe,le)=>xe=he[le]:(ee,fe,le)=>xe+=(0,M.i)(ee,fe);for(let ee=1;ee<oe;ee+=2){const fe=3*Z[ee];(0,M.s)(me,j[fe],j[fe+1],j[fe+2]),G&&(0,M.m)(me,me,G),je(de,me,be++);for(let le=0;le<2;++le)ge[ne]=1-le,ge[ne+1]=xe,ne+=ae;(0,M.c)(de,me)}const Te=3*Z[oe];(0,M.s)(me,j[Te],j[Te+1],j[Te+2]),G&&(0,M.m)(me,me,G),je(de,me,be),ge[ne]=K.END,ge[ne+1]=xe}}class Fe extends U.Mt{constructor(){super(...arguments),this.color=V.O,this.hasVertexColors=!1,this.hasSlicePlane=!1,this.width=1,this.stipplePreferContinuous=!0,this.hasOccludees=!1,this.stippleTexture=null}}const He=(0,c.c)(),Ke=(0,c.c)(),Xe=(0,c.c)(),Ge=(0,c.c)(),tt=(0,b.J$)(),Ye=(0,b.J$)(),ke=(0,c.c)(),Ut=(0,c.c)(),qe=(0,W.Ue)(),vt=(0,W.Ue)(),Dt=(0,c.c)(),it=[(0,b.J$)(),(0,b.J$)(),(0,b.J$)(),(0,b.J$)()],yt=[(0,c.c)(),(0,c.c)(),(0,c.c)(),(0,c.c)()],At=(0,x.Ue)(),Ot=(0,x.Ue)(),Et=(0,x.Ue)(),ct=(0,x.Ue)()},92222:(Ve,Ee,a)=>{a.d(Ee,{U:()=>K});var m=a(8314),_=a(63290),g=a(21286),b=a(62208),q=a(23841),M=a(67831),c=a(84161),V=a(28093),H=a(4794),W=a(8834),x=a(10992),$=a(90014),X=a(19625),O=a(13934),U=a(60881),ce=a(40723),ye=a(5894),F=a(2282),se=a(16396),te=a(41857),k=a(46359),y=a(3393),I=a(651),B=a(91056),L=a(88569),Y=a(12407),P=a(64127),T=a(44835),Q=a(67969),w=a(2078);const C=new Map([[se.T.POSITION,0],[se.T.SUBDIVISIONFACTOR,1],[se.T.UV0,2],[se.T.AUXPOS1,3],[se.T.AUXPOS2,4],[se.T.COLOR,5],[se.T.COLORFEATUREATTRIBUTE,5],[se.T.SIZE,6],[se.T.SIZEFEATUREATTRIBUTE,6],[se.T.OPACITYFEATUREATTRIBUTE,7],[se.T.OBJECTANDLAYERIDCOLOR,8]]);class J extends B.A{initializeProgram(j){return new Y.$(j.rctx,J.shader.get().build(this.configuration),C)}_makePipelineState(j,he){const ae=this.configuration,ge=j===T.A.NONE,xe=j===T.A.FrontFace;return(0,w.sm)({blending:ae.output===O.H.Color||ae.output===O.H.Alpha?ge?L.wu:(0,L.j7)(j):null,depthTest:{func:(0,L.Bh)(j)},depthWrite:ge?ae.writeDepth?w.LZ:null:(0,L.K5)(j),colorWrite:w.BK,stencilWrite:ae.hasOccludees?P.s3:null,stencilTest:ae.hasOccludees?he?P.eD:P.RY:null,polygonOffset:ge||xe?ae.hasPolygonOffset?ie:null:L.E0})}initializePipeline(){const j=this.configuration;if(j.occluder){const he=j.hasPolygonOffset?ie:null;this._occluderPipelineTransparent=(0,w.sm)({blending:L.wu,polygonOffset:he,depthTest:P.zV,depthWrite:null,colorWrite:w.BK,stencilWrite:null,stencilTest:P.YD}),this._occluderPipelineOpaque=(0,w.sm)({blending:L.wu,polygonOffset:he,depthTest:P.zV,depthWrite:null,colorWrite:w.BK,stencilWrite:P.P7,stencilTest:P.ii}),this._occluderPipelineMaskWrite=(0,w.sm)({blending:null,polygonOffset:he,depthTest:P.JN,depthWrite:null,colorWrite:null,stencilWrite:P.s3,stencilTest:P.eD})}return this._occludeePipelineState=this._makePipelineState(this.configuration.transparencyPassType,!0),this._makePipelineState(this.configuration.transparencyPassType,!1)}get primitiveType(){return this.configuration.wireframe?Q.MX.LINES:Q.MX.TRIANGLE_STRIP}getPipelineState(j,he){return he?this._occludeePipelineState:this.configuration.occluder?j===ye.r.TRANSPARENT_OCCLUDER_MATERIAL?this._occluderPipelineTransparent:j===ye.r.OCCLUDER_MATERIAL?this._occluderPipelineOpaque:this._occluderPipelineMaskWrite:super.getPipelineState(j,he)}}J.shader=new I.J(y.a,()=>a.e(4346).then(a.bind(a,84346)));const ie={factor:0,units:-4};var E,Z,v=a(39401);(Z=E||(E={}))[Z.LEFT_JOIN_START=-2]="LEFT_JOIN_START",Z[Z.LEFT_JOIN_END=-1]="LEFT_JOIN_END",Z[Z.LEFT_CAP_START=-4]="LEFT_CAP_START",Z[Z.LEFT_CAP_END=-5]="LEFT_CAP_END",Z[Z.RIGHT_JOIN_START=2]="RIGHT_JOIN_START",Z[Z.RIGHT_JOIN_END=1]="RIGHT_JOIN_END",Z[Z.RIGHT_CAP_START=4]="RIGHT_CAP_START",Z[Z.RIGHT_CAP_END=5]="RIGHT_CAP_END";class K extends ce.F5{constructor(j){super(j,new Me),this._configuration=new v.G,this._vertexAttributeLocations=C,this._layout=this.createLayout()}isClosed(j,he){return Ke(this.parameters,j,he)}getConfiguration(j,he){this._configuration.output=j,this._configuration.draped=he.slot===ye.r.DRAPED_MATERIAL;const ae=(0,b.pC)(this.parameters.stipplePattern)&&j!==O.H.Highlight;return this._configuration.stippleEnabled=ae,this._configuration.stippleOffColorEnabled=ae&&(0,b.pC)(this.parameters.stippleOffColor),this._configuration.stippleScaleWithLineWidth=ae&&this.parameters.stippleScaleWithLineWidth,this._configuration.stipplePreferContinuous=ae&&this.parameters.stipplePreferContinuous,this._configuration.hasSlicePlane=this.parameters.hasSlicePlane,this._configuration.hasOccludees=this.parameters.hasOccludees,this._configuration.roundJoins="round"===this.parameters.join,this._configuration.capType=this.parameters.cap,this._configuration.applyMarkerOffset=!!(0,b.pC)(this.parameters.markerParameters)&&function Xe(Z){return Z.anchor===k.i5.Tip&&Z.hideOnShortSegments&&"begin-end"===Z.placement&&Z.worldSpace}(this.parameters.markerParameters),this._configuration.hasPolygonOffset=this.parameters.hasPolygonOffset,this._configuration.writeDepth=this.parameters.writeDepth,this._configuration.vvColor=this.parameters.vvColorEnabled,this._configuration.vvOpacity=this.parameters.vvOpacityEnabled,this._configuration.vvSize=this.parameters.vvSizeEnabled,this._configuration.innerColorEnabled=this.parameters.innerWidth>0&&(0,b.pC)(this.parameters.innerColor),this._configuration.falloffEnabled=this.parameters.falloff>0,this._configuration.occluder=this.parameters.renderOccluded===ce.yD.OccludeAndTransparentStencil,this._configuration.transparencyPassType=he.transparencyPassType,this._configuration.hasMultipassTerrain=he.multipassTerrain.enabled,this._configuration.cullAboveGround=he.multipassTerrain.cullAboveGround,this._configuration.wireframe=this.parameters.wireframe,this._configuration}intersectDraped(j,he,ae,ge,xe,Oe){if(!ae.options.selectionMode)return;const de=j.vertexAttributes.get(se.T.POSITION).data,me=j.vertexAttributes.get(se.T.SIZE);let oe=this.parameters.width;if(this.parameters.vvSizeEnabled){const le=j.vertexAttributes.get(se.T.SIZEFEATUREATTRIBUTE).data[0];oe*=(0,g.uZ)(this.parameters.vvSizeOffset[0]+le*this.parameters.vvSizeFactor[0],this.parameters.vvSizeMinSize[0],this.parameters.vvSizeMaxSize[0])}else me&&(oe*=me.data[0]);const be=ge[0],je=ge[1],Te=(oe/2+4)*j.screenToWorldRatio;let ee=Number.MAX_VALUE,fe=0;for(let le=0;le<de.length-5;le+=3){const pe=de[le],Se=de[le+1],Ae=be-pe,De=je-Se,Ue=de[le+3]-pe,Re=de[le+4]-Se,Ie=(0,g.uZ)((Ue*Ae+Re*De)/(Ue*Ue+Re*Re),0,1),rt=Ue*Ie-Ae,Pe=Re*Ie-De,Je=rt*rt+Pe*Pe;Je<ee&&(ee=Je,fe=le/3)}ee<Te*Te&&xe(Oe.dist,Oe.normal,fe,!1)}intersect(j,he,ae,ge,xe,Oe){if(!ae.options.selectionMode||!j.visible)return;if(!(0,F.kG)(he))return void _.Z.getLogger("esri.views.3d.webgl-engine.materials.RibbonLineMaterial").error("intersection assumes a translation-only matrix");const de=j.vertexAttributes,me=de.get(se.T.POSITION).data;let oe=this.parameters.width;if(this.parameters.vvSizeEnabled){const Ae=de.get(se.T.SIZEFEATUREATTRIBUTE).data[0];oe*=(0,g.uZ)(this.parameters.vvSizeOffset[0]+Ae*this.parameters.vvSizeFactor[0],this.parameters.vvSizeMinSize[0],this.parameters.vvSizeMaxSize[0])}else de.has(se.T.SIZE)&&(oe*=de.get(se.T.SIZE).data[0]);const be=ae.camera,je=Ut;(0,M.c)(je,ae.point);const Te=oe*be.pixelRatio/2+4*be.pixelRatio;(0,c.s)(Qe[0],je[0]-Te,je[1]+Te,0),(0,c.s)(Qe[1],je[0]+Te,je[1]+Te,0),(0,c.s)(Qe[2],je[0]+Te,je[1]-Te,0),(0,c.s)(Qe[3],je[0]-Te,je[1]-Te,0);for(let Ae=0;Ae<4;Ae++)if(!be.unprojectFromRenderScreen(Qe[Ae],G[Ae]))return;(0,$.zk)(be.eye,G[0],G[1],_e),(0,$.zk)(be.eye,G[1],G[2],re),(0,$.zk)(be.eye,G[2],G[3],ne),(0,$.zk)(be.eye,G[3],G[0],ve);let ee=Number.MAX_VALUE,fe=0;const le=He(this.parameters,de,j.indices)?me.length-2:me.length-5;for(let Ae=0;Ae<le;Ae+=3){Ge[0]=me[Ae]+he[12],Ge[1]=me[Ae+1]+he[13],Ge[2]=me[Ae+2]+he[14];const De=(Ae+3)%me.length;if(tt[0]=me[De]+he[12],tt[1]=me[De+1]+he[13],tt[2]=me[De+2]+he[14],(0,$.jH)(_e,Ge)<0&&(0,$.jH)(_e,tt)<0||(0,$.jH)(re,Ge)<0&&(0,$.jH)(re,tt)<0||(0,$.jH)(ne,Ge)<0&&(0,$.jH)(ne,tt)<0||(0,$.jH)(ve,Ge)<0&&(0,$.jH)(ve,tt)<0)continue;if(be.projectToRenderScreen(Ge,qe),be.projectToRenderScreen(tt,vt),qe[2]<0&&vt[2]>0){(0,c.b)(Ye,Ge,tt);const Re=be.frustum,Ie=-(0,$.jH)(Re[W.Nu.NEAR],Ge)/(0,c.e)(Ye,(0,$.mJ)(Re[W.Nu.NEAR]));(0,c.g)(Ye,Ye,Ie),(0,c.a)(Ge,Ge,Ye),be.projectToRenderScreen(Ge,qe)}else if(qe[2]>0&&vt[2]<0){(0,c.b)(Ye,tt,Ge);const Re=be.frustum,Ie=-(0,$.jH)(Re[W.Nu.NEAR],tt)/(0,c.e)(Ye,(0,$.mJ)(Re[W.Nu.NEAR]));(0,c.g)(Ye,Ye,Ie),(0,c.a)(tt,tt,Ye),be.projectToRenderScreen(tt,vt)}else if(qe[2]<0&&vt[2]<0)continue;qe[2]=0,vt[2]=0;const Ue=(0,x.Jk)((0,x.zk)(qe,vt,yt),je);Ue<ee&&(ee=Ue,(0,c.c)(Dt,Ge),(0,c.c)(it,tt),fe=Ae/3)}const pe=ae.rayBegin,Se=ae.rayEnd;if(ee<Te*Te){let Ae=Number.MAX_VALUE;if((0,x.AR)((0,x.zk)(Dt,it,yt),(0,x.zk)(pe,Se,At),ke)){(0,c.b)(ke,ke,pe);const De=(0,c.l)(ke);(0,c.g)(ke,ke,1/De),Ae=De/(0,c.i)(pe,Se)}Oe(Ae,ke,fe,!1)}}createLayout(){const j=(0,X.U$)().vec3f(se.T.POSITION).f32(se.T.SUBDIVISIONFACTOR).vec2f(se.T.UV0).vec3f(se.T.AUXPOS1).vec3f(se.T.AUXPOS2);return j.f32(this.parameters.vvSizeEnabled?se.T.SIZEFEATUREATTRIBUTE:se.T.SIZE),this.parameters.vvColorEnabled?j.f32(se.T.COLORFEATUREATTRIBUTE):j.vec4f(se.T.COLOR),this.parameters.vvOpacityEnabled&&j.f32(se.T.OPACITYFEATUREATTRIBUTE),(0,m.Z)("enable-feature:objectAndLayerId-rendering")&&j.vec4u8(se.T.OBJECTANDLAYERIDCOLOR),j}createBufferWriter(){return new Le(this._layout,this.parameters)}requiresSlot(j,he){return!(he!==O.H.Color&&he!==O.H.Alpha&&he!==O.H.Highlight&&he!==O.H.Depth&&he!==O.H.ObjectAndLayerIdColor||j!==ye.r.DRAPED_MATERIAL&&(this.parameters.renderOccluded===ce.yD.OccludeAndTransparentStencil?j!==ye.r.OPAQUE_MATERIAL&&j!==ye.r.OCCLUDER_MATERIAL&&j!==ye.r.TRANSPARENT_OCCLUDER_MATERIAL:he===O.H.Color||he===O.H.Alpha?j!==(this.parameters.writeDepth?ye.r.TRANSPARENT_MATERIAL:ye.r.TRANSPARENT_DEPTH_WRITE_DISABLED_MATERIAL):j!==ye.r.OPAQUE_MATERIAL))}createGLMaterial(j){return new ue(j)}validateParameters(j){"miter"!==j.join&&(j.miterLimit=0),(0,b.pC)(j.markerParameters)&&(j.markerScale=j.markerParameters.width/j.width)}}class ue extends U.Z{constructor(){super(...arguments),this._stipplePattern=null}dispose(){super.dispose(),this._stippleTextureRepository.release(this._stipplePattern),this._stipplePattern=null}_updateOccludeeState(j){j.hasOccludees!==this._material.parameters.hasOccludees&&this._material.setParameters({hasOccludees:j.hasOccludees})}beginSlot(j){this._output!==O.H.Color&&this._output!==O.H.Alpha||this._updateOccludeeState(j);const he=this._material.parameters.stipplePattern;return this._stipplePattern!==he&&(this._material.setParameters(this._stippleTextureRepository.swap(this._stipplePattern,he)),this._stipplePattern=he),this.ensureTechnique(J,j)}}class Me extends te.n{constructor(){super(...arguments),this.width=0,this.color=H.O,this.join="miter",this.cap=v.R.BUTT,this.miterLimit=5,this.writeDepth=!0,this.hasPolygonOffset=!1,this.stippleTexture=null,this.stippleScaleWithLineWidth=!1,this.stipplePreferContinuous=!0,this.markerParameters=null,this.markerScale=1,this.hasSlicePlane=!1,this.vvFastUpdate=!1,this.isClosed=!1,this.falloff=0,this.innerWidth=0,this.hasOccludees=!1,this.wireframe=!1}}class Le{constructor(j,he){this._parameters=he,this.numJoinSubdivisions=0,this.vertexBufferLayout=j;const ae=he.stipplePattern?1:0;switch(this._parameters.join){case"miter":case"bevel":this.numJoinSubdivisions=ae;break;case"round":this.numJoinSubdivisions=y.R+ae}}_isClosed(j){return He(this._parameters,j.vertexAttributes,j.indices)}allocate(j){return this.vertexBufferLayout.createBuffer(j)}elementCount(j){const ae=j.indices.get(se.T.POSITION).length/2+1,ge=this._isClosed(j);let xe=ge?2:4;return xe+=((ge?ae:ae-1)-(ge?0:1))*(2*this.numJoinSubdivisions+4),xe+=2,this._parameters.wireframe&&(xe=2+4*(xe-2)),xe}write(j,he,ae,ge,xe){const Oe=Ot,de=Et,me=ct,oe=ae.vertexAttributes.get(se.T.POSITION).data,be=ae.indices&&ae.indices.get(se.T.POSITION),je=ae.vertexAttributes.get(se.T.DISTANCETOSTART)?.data;be&&be.length!==2*(oe.length/3-1)&&console.warn("RibbonLineMaterial does not support indices");let Te=1,ee=0;this._parameters.vvSizeEnabled?ee=ae.vertexAttributes.get(se.T.SIZEFEATUREATTRIBUTE).data[0]:ae.vertexAttributes.has(se.T.SIZE)&&(Te=ae.vertexAttributes.get(se.T.SIZE).data[0]);let fe=[1,1,1,1],le=0;this._parameters.vvColorEnabled?le=ae.vertexAttributes.get(se.T.COLORFEATUREATTRIBUTE).data[0]:ae.vertexAttributes.has(se.T.COLOR)&&(fe=ae.vertexAttributes.get(se.T.COLOR).data);const pe=(0,m.Z)("enable-feature:objectAndLayerId-rendering")?ae.objectAndLayerIdColor:null;let Se=0;this._parameters.vvOpacityEnabled&&(Se=ae.vertexAttributes.get(se.T.OPACITYFEATUREATTRIBUTE).data[0]);const Ae=oe.length/3,De=new Float32Array(ge.buffer),Ue=(0,m.Z)("enable-feature:objectAndLayerId-rendering")?new Uint8Array(ge.buffer):null,Re=this.vertexBufferLayout.stride/4;let Ie=xe*Re;const rt=Ie;let Pe=0;const Je=je?(nt,Ne,lt)=>Pe=je[lt]:(nt,Ne,lt)=>Pe+=(0,c.i)(nt,Ne),ut=(0,m.Z)("enable-feature:objectAndLayerId-rendering"),ot=(nt,Ne,lt,gt,mt,St,It)=>{if(De[Ie++]=Ne[0],De[Ie++]=Ne[1],De[Ie++]=Ne[2],De[Ie++]=gt,De[Ie++]=It,De[Ie++]=mt,De[Ie++]=nt[0],De[Ie++]=nt[1],De[Ie++]=nt[2],De[Ie++]=lt[0],De[Ie++]=lt[1],De[Ie++]=lt[2],De[Ie++]=this._parameters.vvSizeEnabled?ee:Te,this._parameters.vvColorEnabled)De[Ie++]=le;else{const Ct=Math.min(4*St,fe.length-4);De[Ie++]=fe[Ct],De[Ie++]=fe[Ct+1],De[Ie++]=fe[Ct+2],De[Ie++]=fe[Ct+3]}this._parameters.vvOpacityEnabled&&(De[Ie++]=Se),ut&&((0,b.pC)(pe)&&(Ue[4*Ie]=pe[0],Ue[4*Ie+1]=pe[1],Ue[4*Ie+2]=pe[2],Ue[4*Ie+3]=pe[3]),Ie++)};Ie+=Re,(0,c.s)(de,oe[0],oe[1],oe[2]),j&&(0,c.m)(de,de,j);const Tt=this._isClosed(ae);if(Tt){const nt=oe.length-3;(0,c.s)(Oe,oe[nt],oe[nt+1],oe[nt+2]),j&&(0,c.m)(Oe,Oe,j)}else(0,c.s)(me,oe[3],oe[4],oe[5]),j&&(0,c.m)(me,me,j),ot(de,de,me,1,E.LEFT_CAP_START,0,0),ot(de,de,me,1,E.RIGHT_CAP_START,0,0),(0,c.c)(Oe,de),(0,c.c)(de,me);const ft=Tt?0:1,at=Tt?Ae:Ae-1;for(let nt=ft;nt<at;nt++){const Ne=(nt+1)%Ae*3;(0,c.s)(me,oe[Ne],oe[Ne+1],oe[Ne+2]),j&&(0,c.m)(me,me,j),Je(Oe,de,nt),ot(Oe,de,me,0,E.LEFT_JOIN_END,nt,Pe),ot(Oe,de,me,0,E.RIGHT_JOIN_END,nt,Pe);const lt=this.numJoinSubdivisions;for(let gt=0;gt<lt;++gt){const mt=(gt+1)/(lt+1);ot(Oe,de,me,mt,E.LEFT_JOIN_END,nt,Pe),ot(Oe,de,me,mt,E.RIGHT_JOIN_END,nt,Pe)}ot(Oe,de,me,1,E.LEFT_JOIN_START,nt,Pe),ot(Oe,de,me,1,E.RIGHT_JOIN_START,nt,Pe),(0,c.c)(Oe,de),(0,c.c)(de,me)}Tt?((0,c.s)(me,oe[3],oe[4],oe[5]),j&&(0,c.m)(me,me,j),Pe=Je(Oe,de,at),ot(Oe,de,me,0,E.LEFT_JOIN_END,ft,Pe),ot(Oe,de,me,0,E.RIGHT_JOIN_END,ft,Pe)):(Pe=Je(Oe,de,at),ot(Oe,de,de,0,E.LEFT_CAP_END,at,Pe),ot(Oe,de,de,0,E.RIGHT_CAP_END,at,Pe)),Fe(De,rt+Re,De,rt,Re),Ie=Fe(De,Ie-Re,De,Ie,Re),this._parameters.wireframe&&this._addWireframeVertices(ge,rt,Ie,Re)}_addWireframeVertices(j,he,ae,ge){const xe=new Float32Array(j.buffer,ae*Float32Array.BYTES_PER_ELEMENT),Oe=new Float32Array(j.buffer,he*Float32Array.BYTES_PER_ELEMENT,ae-he);let de=0;const me=oe=>de=Fe(Oe,oe,xe,de,ge);for(let oe=0;oe<Oe.length-1;oe+=2*ge)me(oe),me(oe+2*ge),me(oe+1*ge),me(oe+2*ge),me(oe+1*ge),me(oe+3*ge)}}function Fe(Z,j,he,ae,ge){for(let xe=0;xe<ge;xe++)he[ae++]=Z[j++];return ae}function He(Z,j,he){return Ke(Z,j.get(se.T.POSITION).data,he?he.get(se.T.POSITION):null)}function Ke(Z,j,he){return!!Z.isClosed&&(he?he.length>2:j.length>6)}const Ge=(0,V.c)(),tt=(0,V.c)(),Ye=(0,V.c)(),ke=(0,V.c)(),Ut=(0,V.c)(),qe=(0,q.J$)(),vt=(0,q.J$)(),Dt=(0,V.c)(),it=(0,V.c)(),yt=(0,x.Ue)(),At=(0,x.Ue)(),Ot=(0,V.c)(),Et=(0,V.c)(),ct=(0,V.c)(),Qe=[(0,q.J$)(),(0,q.J$)(),(0,q.J$)(),(0,q.J$)()],G=[(0,V.c)(),(0,V.c)(),(0,V.c)(),(0,V.c)()],_e=(0,$.Ue)(),re=(0,$.Ue)(),ne=(0,$.Ue)(),ve=(0,$.Ue)()},51899:(Ve,Ee,a)=>{a.d(Ee,{$A:()=>W,h0:()=>M,it:()=>$,kj:()=>x});var m=a(36161),_=a(62208),g=a(17625),b=a(67969),q=a(55086);class M{constructor(O){this._rctx=O,this._cache=new Map}destroy(){this._cache.forEach(O=>(0,_.M2)(O.stippleTexture)),this._cache.clear()}_acquire(O){if((0,_.Wi)(O))return null;const U=this._patternId(O),ce=this._cache.get(U);if(ce)return ce.refCount++,ce;const{encodedData:ye,paddedPixels:F}=function V(X){const O=H(X),U=1/X.pixelRatio,ce=W(X),ye=x(X),F=(Math.floor(.5*(ye-1))+.5)*U,se=[];let te=1;for(const Y of O){for(let P=0;P<Y;P++){const T=te*(Math.min(P,Y-1-P)+.5)*U/F*.5+.5;se.push(T)}te=-te}const k=Math.round(O[0]/2),y=[...se.slice(k),...se.slice(0,k)],I=ce+$,B=new Uint8Array(4*I);let L=4;for(const Y of y)(0,m.I)(Y,B,L),L+=4;return B.copyWithin(0,L-4,L),B.copyWithin(L,4,8),{encodedData:B,paddedPixels:I}}(O),se=new c(new q.x(this._rctx,{width:F,height:1,internalFormat:b.VI.RGBA,pixelFormat:b.VI.RGBA,dataType:b.Br.UNSIGNED_BYTE,wrapMode:b.e8.CLAMP_TO_EDGE},ye));return this._cache.set(U,se),se}release(O){if((0,_.Wi)(O))return;const U=this._patternId(O),ce=this._cache.get(U);ce&&(ce.refCount--,0===ce.refCount&&((0,_.pC)(ce.stippleTexture)&&ce.stippleTexture.dispose(),this._cache.delete(U)))}swap(O,U){const ce=this._acquire(U);return this.release(O),ce}_patternId(O){return`${O.pattern.join(",")}-r${O.pixelRatio}`}}class c extends g.K{constructor(O){super(),this.stippleTexture=O,this.refCount=1}}function H(X){return X.pattern.map(O=>Math.round(O*X.pixelRatio))}function W(X){if((0,_.Wi)(X))return 1;const O=H(X);return Math.floor(O.reduce((U,ce)=>U+ce))}function x(X){return H(X).reduce((O,U)=>Math.max(O,U))}const $=2},15842:(Ve,Ee,a)=>{a.d(Ee,{c:()=>g});var m=a(40723),_=a(57623);class g extends m.F5{intersect(q,M,c,V,H,W){return(0,_.Bw)(q,c,V,H,void 0,W)}}},90978:(Ve,Ee,a)=>{a.d(Ee,{H:()=>ie,m:()=>v});var m=a(27422),_=a(99770),g=a(4794),b=a(13934),q=a(62208);class M{constructor(){this.enabled=!0,this._time=(0,m.HA)(0)}get time(){return this._time}advance({deltaTime:ue,fixedTime:Me}){return(0,q.pC)(Me)?this._time!==Me&&(this._time=Me,!0):(this._time=(0,m.HA)(this._time+ue),0!==ue)}}var V=a(40723),H=a(88569),W=a(5894),x=a(2770),$=a(66131),X=a(15842),O=a(60881),U=a(17626),ce=a(59617),ye=a(92724),se=(a(45780),a(651)),te=a(91056),k=a(87601),y=a(39114),I=a(12407),B=a(44835),L=a(41528),Y=a(61584),P=a(57596),T=a(2078);class w extends te.A{initializeConfiguration(ue,Me){Me.hasWebGL2Context=ue.rctx.type===P.zO.WEBGL2,Me.spherical=ue.viewingMode===ce.JY.Global,Me.doublePrecisionRequiresObfuscation=ue.rctx.driverTest.doublePrecisionRequiresObfuscation.result}initializeProgram(ue){return new I.$(ue.rctx,w.shader.get().build(this.configuration),y.i)}_setPipelineState(ue){const Me=this.configuration,Le=ue===B.A.NONE,Fe=ue===B.A.FrontFace;return(0,T.sm)({blending:Me.output!==b.H.Normal&&Me.output!==b.H.Highlight&&Me.transparent?Le?H.wu:(0,H.j7)(ue):null,depthTest:{func:(0,H.Bh)(ue)},depthWrite:Le?Me.writeDepth?T.LZ:null:(0,H.K5)(ue),colorWrite:T.BK,polygonOffset:Le||Fe?null:(0,H.je)(Me.enableOffset)})}initializePipeline(){return this._setPipelineState(this.configuration.transparencyPassType)}}w.shader=new se.J(Y.W,()=>a.e(4095).then(a.bind(a,74095)));class C extends L.W{constructor(){super(...arguments),this.output=b.H.Color,this.transparencyPassType=B.A.NONE,this.spherical=!1,this.receiveShadows=!1,this.hasSlicePlane=!1,this.transparent=!1,this.enableOffset=!0,this.writeDepth=!1,this.hasScreenSpaceReflections=!1,this.doublePrecisionRequiresObfuscation=!1,this.hasCloudsReflections=!1,this.isDraped=!1,this.hasMultipassTerrain=!1,this.cullAboveGround=!1}}(0,U._)([(0,k.o)({count:b.H.COUNT})],C.prototype,"output",void 0),(0,U._)([(0,k.o)({count:B.A.COUNT})],C.prototype,"transparencyPassType",void 0),(0,U._)([(0,k.o)()],C.prototype,"spherical",void 0),(0,U._)([(0,k.o)()],C.prototype,"receiveShadows",void 0),(0,U._)([(0,k.o)()],C.prototype,"hasSlicePlane",void 0),(0,U._)([(0,k.o)()],C.prototype,"transparent",void 0),(0,U._)([(0,k.o)()],C.prototype,"enableOffset",void 0),(0,U._)([(0,k.o)()],C.prototype,"writeDepth",void 0),(0,U._)([(0,k.o)()],C.prototype,"hasScreenSpaceReflections",void 0),(0,U._)([(0,k.o)()],C.prototype,"doublePrecisionRequiresObfuscation",void 0),(0,U._)([(0,k.o)()],C.prototype,"hasCloudsReflections",void 0),(0,U._)([(0,k.o)()],C.prototype,"isDraped",void 0),(0,U._)([(0,k.o)()],C.prototype,"hasMultipassTerrain",void 0),(0,U._)([(0,k.o)()],C.prototype,"cullAboveGround",void 0),(0,U._)([(0,k.o)({constValue:ye.f7.Water})],C.prototype,"pbrMode",void 0),(0,U._)([(0,k.o)({constValue:!0})],C.prototype,"useCustomDTRExponentForWater",void 0),(0,U._)([(0,k.o)({constValue:!0})],C.prototype,"highStepCount",void 0),(0,U._)([(0,k.o)({constValue:!1})],C.prototype,"useFillLights",void 0);class J extends O.Z{_updateShadowState(ue){ue.shadowMap.enabled!==this._material.parameters.receiveShadows&&this._material.setParameters({receiveShadows:ue.shadowMap.enabled})}_updateSSRState(ue){ue.ssr.enabled!==this._material.parameters.hasScreenSpaceReflections&&this._material.setParameters({hasScreenSpaceReflections:ue.ssr.enabled})}_updateCloudsReflectionState(ue){const Me=(0,q.pC)(ue.cloudsFade.data);Me!==this._material.parameters.hasCloudsReflections&&this._material.setParameters({hasCloudsReflections:Me})}ensureResources(ue){return this._techniqueRepository.constructionContext.waterTextureRepository.ensureResources(ue)}beginSlot(ue){return this._output===b.H.Color&&(this._updateShadowState(ue),this._updateSSRState(ue),this._updateCloudsReflectionState(ue)),this._material.setParameters(this._techniqueRepository.constructionContext.waterTextureRepository.passParameters),this.ensureTechnique(w,ue)}}class ie extends X.c{constructor(ue){super(ue,new v),this._configuration=new C,this.animation=new M}getConfiguration(ue,Me){return this._configuration.output=ue,this._configuration.writeDepth=this.parameters.writeDepth,this._configuration.receiveShadows=this.parameters.receiveShadows,this._configuration.hasSlicePlane=this.parameters.hasSlicePlane,this._configuration.transparent=this.parameters.transparent,this._configuration.hasScreenSpaceReflections=this.parameters.hasScreenSpaceReflections,this._configuration.hasCloudsReflections=this.parameters.hasCloudsReflections,this._configuration.isDraped=this.parameters.isDraped,this._configuration.transparencyPassType=Me.transparencyPassType,this._configuration.enableOffset=Me.camera.relativeElevation<H.ve,this._configuration.hasMultipassTerrain=Me.multipassTerrain.enabled,this._configuration.cullAboveGround=Me.multipassTerrain.cullAboveGround,this._configuration}update(ue){const Me=Math.min(ue.camera.relativeElevation,ue.camera.distance);this.animation.enabled=Math.sqrt(this.parameters.waveTextureRepeat/this.parameters.waveStrength)*Me<E;const Le=this.animation.advance(ue);return this.setParameters({timeElapsed:(0,m.D9)(this.animation.time)*this.parameters.animationSpeed},!1),this.animation.enabled&&Le}requiresSlot(ue,Me){switch(Me){case b.H.Normal:return ue===W.r.DRAPED_WATER;case b.H.Color:if(this.parameters.isDraped)return ue===W.r.DRAPED_MATERIAL;break;case b.H.Alpha:break;case b.H.Highlight:return ue===W.r.OPAQUE_MATERIAL||ue===W.r.DRAPED_MATERIAL;default:return!1}let Le=W.r.OPAQUE_MATERIAL;return this.parameters.transparent&&(Le=this.parameters.writeDepth?W.r.TRANSPARENT_MATERIAL:W.r.TRANSPARENT_DEPTH_WRITE_DISABLED_MATERIAL),ue===Le}createGLMaterial(ue){return new J(ue)}createBufferWriter(){return new x.G($.W1)}}class v extends V.Mt{constructor(){super(...arguments),this.waveStrength=.06,this.waveTextureRepeat=32,this.waveDirection=(0,_.f)(1,0),this.waveVelocity=.05,this.flowStrength=.015,this.flowOffset=-.5,this.animationSpeed=.35,this.timeElapsed=0,this.color=(0,g.f)(0,0,0,0),this.transparent=!0,this.writeDepth=!0,this.hasSlicePlane=!1,this.isDraped=!1,this.receiveShadows=!0,this.hasScreenSpaceReflections=!1,this.hasCloudsReflections=!1}}const E=35e3},54889:(Ve,Ee,a)=>{a.d(Ee,{Dp:()=>c,z5:()=>M});var m=a(62208);const _={dash:[4,3],dot:[1,3],"long-dash":[8,3],"short-dash":[4,1],"short-dot":[1,1]},g={dash:_.dash,"dash-dot":[..._.dash,..._.dot],dot:_.dot,"long-dash":_["long-dash"],"long-dash-dot":[..._["long-dash"],..._.dot],"long-dash-dot-dot":[..._["long-dash"],..._.dot,..._.dot],none:null,"short-dash":_["short-dash"],"short-dash-dot":[..._["short-dash"],..._["short-dot"]],"short-dash-dot-dot":[..._["short-dash"],..._["short-dot"],..._["short-dot"]],"short-dot":_["short-dot"],solid:null};function M(H,W=2){return{pattern:[H,H],pixelRatio:W}}function c(H){return(0,m.pC)(H)&&"style"===H.type?function V(H){return(0,m.pC)(H)?function q(H,W=2){return(0,m.Wi)(H)?H:{pattern:H.slice(),pixelRatio:W}}(g[H],8):null}(H.style):null}},46359:(Ve,Ee,a)=>{a.d(Ee,{I9:()=>M,PI:()=>V,i5:()=>c});var M,c,H,m=a(17626),_=a(13934),g=a(87601),b=a(44835),q=a(41528);(H=M||(M={}))[H.Draped=0]="Draped",H[H.Screen=1]="Screen",H[H.World=2]="World",H[H.COUNT=3]="COUNT",function(H){H[H.Center=0]="Center",H[H.Tip=1]="Tip",H[H.COUNT=2]="COUNT"}(c||(c={}));class V extends q.W{constructor(){super(...arguments),this.output=_.H.Color,this.transparencyPassType=b.A.NONE,this.occluder=!1,this.hasSlicePlane=!1,this.writeDepth=!1,this.space=M.Screen,this.hideOnShortSegments=!1,this.hasCap=!1,this.anchor=c.Center,this.hasTip=!1,this.vvSize=!1,this.vvColor=!1,this.vvOpacity=!1,this.hasOccludees=!1,this.hasMultipassTerrain=!1,this.cullAboveGround=!1}}(0,m._)([(0,g.o)({count:_.H.COUNT})],V.prototype,"output",void 0),(0,m._)([(0,g.o)({count:b.A.COUNT})],V.prototype,"transparencyPassType",void 0),(0,m._)([(0,g.o)()],V.prototype,"occluder",void 0),(0,m._)([(0,g.o)()],V.prototype,"hasSlicePlane",void 0),(0,m._)([(0,g.o)()],V.prototype,"writeDepth",void 0),(0,m._)([(0,g.o)({count:M.COUNT})],V.prototype,"space",void 0),(0,m._)([(0,g.o)()],V.prototype,"hideOnShortSegments",void 0),(0,m._)([(0,g.o)()],V.prototype,"hasCap",void 0),(0,m._)([(0,g.o)({count:c.COUNT})],V.prototype,"anchor",void 0),(0,m._)([(0,g.o)()],V.prototype,"hasTip",void 0),(0,m._)([(0,g.o)()],V.prototype,"vvSize",void 0),(0,m._)([(0,g.o)()],V.prototype,"vvColor",void 0),(0,m._)([(0,g.o)()],V.prototype,"vvOpacity",void 0),(0,m._)([(0,g.o)()],V.prototype,"hasOccludees",void 0),(0,m._)([(0,g.o)()],V.prototype,"hasMultipassTerrain",void 0),(0,m._)([(0,g.o)()],V.prototype,"cullAboveGround",void 0),(0,m._)([(0,g.o)({constValue:!0})],V.prototype,"hasVvInstancing",void 0),(0,m._)([(0,g.o)({constValue:!0})],V.prototype,"hasSliceTranslatedView",void 0)},39401:(Ve,Ee,a)=>{a.d(Ee,{G:()=>c,R:()=>M});var M,V,m=a(17626),_=a(13934),g=a(87601),b=a(44835),q=a(41528);(V=M||(M={}))[V.BUTT=0]="BUTT",V[V.SQUARE=1]="SQUARE",V[V.ROUND=2]="ROUND",V[V.COUNT=3]="COUNT";class c extends q.W{constructor(){super(...arguments),this.output=_.H.Color,this.capType=M.BUTT,this.transparencyPassType=b.A.NONE,this.occluder=!1,this.hasSlicePlane=!1,this.hasPolygonOffset=!1,this.writeDepth=!1,this.draped=!1,this.stippleEnabled=!1,this.stippleOffColorEnabled=!1,this.stippleScaleWithLineWidth=!1,this.stipplePreferContinuous=!0,this.roundJoins=!1,this.applyMarkerOffset=!1,this.vvSize=!1,this.vvColor=!1,this.vvOpacity=!1,this.falloffEnabled=!1,this.innerColorEnabled=!1,this.hasOccludees=!1,this.hasMultipassTerrain=!1,this.cullAboveGround=!1,this.wireframe=!1,this.objectAndLayerIdColorInstanced=!1}}(0,m._)([(0,g.o)({count:_.H.COUNT})],c.prototype,"output",void 0),(0,m._)([(0,g.o)({count:M.COUNT})],c.prototype,"capType",void 0),(0,m._)([(0,g.o)({count:b.A.COUNT})],c.prototype,"transparencyPassType",void 0),(0,m._)([(0,g.o)()],c.prototype,"occluder",void 0),(0,m._)([(0,g.o)()],c.prototype,"hasSlicePlane",void 0),(0,m._)([(0,g.o)()],c.prototype,"hasPolygonOffset",void 0),(0,m._)([(0,g.o)()],c.prototype,"writeDepth",void 0),(0,m._)([(0,g.o)()],c.prototype,"draped",void 0),(0,m._)([(0,g.o)()],c.prototype,"stippleEnabled",void 0),(0,m._)([(0,g.o)()],c.prototype,"stippleOffColorEnabled",void 0),(0,m._)([(0,g.o)()],c.prototype,"stippleScaleWithLineWidth",void 0),(0,m._)([(0,g.o)()],c.prototype,"stipplePreferContinuous",void 0),(0,m._)([(0,g.o)()],c.prototype,"roundJoins",void 0),(0,m._)([(0,g.o)()],c.prototype,"applyMarkerOffset",void 0),(0,m._)([(0,g.o)()],c.prototype,"vvSize",void 0),(0,m._)([(0,g.o)()],c.prototype,"vvColor",void 0),(0,m._)([(0,g.o)()],c.prototype,"vvOpacity",void 0),(0,m._)([(0,g.o)()],c.prototype,"falloffEnabled",void 0),(0,m._)([(0,g.o)()],c.prototype,"innerColorEnabled",void 0),(0,m._)([(0,g.o)()],c.prototype,"hasOccludees",void 0),(0,m._)([(0,g.o)()],c.prototype,"hasMultipassTerrain",void 0),(0,m._)([(0,g.o)()],c.prototype,"cullAboveGround",void 0),(0,m._)([(0,g.o)()],c.prototype,"wireframe",void 0),(0,m._)([(0,g.o)({constValue:!0})],c.prototype,"stippleRequiresClamp",void 0),(0,m._)([(0,g.o)({constValue:!0})],c.prototype,"stippleRequiresStretchMeasure",void 0),(0,m._)([(0,g.o)({constValue:!0})],c.prototype,"hasVvInstancing",void 0),(0,m._)([(0,g.o)({constValue:!0})],c.prototype,"hasSliceTranslatedView",void 0),(0,m._)([(0,g.o)()],c.prototype,"objectAndLayerIdColorInstanced",void 0)}}]);